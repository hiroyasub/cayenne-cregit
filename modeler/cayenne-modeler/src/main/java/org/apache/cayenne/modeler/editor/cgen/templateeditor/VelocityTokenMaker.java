begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************  *   Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *    https://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing,  *  software distributed under the License is distributed on an  *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *  KIND, either express or implied.  See the License for the  *  specific language governing permissions and limitations  *  under the License.  ****************************************************************/
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|modeler
operator|.
name|editor
operator|.
name|cgen
operator|.
name|templateeditor
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|text
operator|.
name|Segment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|fife
operator|.
name|ui
operator|.
name|rsyntaxtextarea
operator|.
name|AbstractJFlexCTokenMaker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|fife
operator|.
name|ui
operator|.
name|rsyntaxtextarea
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|fife
operator|.
name|ui
operator|.
name|rsyntaxtextarea
operator|.
name|TokenImpl
import|;
end_import

begin_comment
comment|/**  * since 4.3  */
end_comment

begin_class
specifier|public
class|class
name|VelocityTokenMaker
extends|extends
name|AbstractJFlexCTokenMaker
block|{
comment|/** This character denotes the end of file */
specifier|public
specifier|static
specifier|final
name|int
name|YYEOF
init|=
operator|-
literal|1
decl_stmt|;
comment|/** initial size of the lookahead buffer */
specifier|private
specifier|static
specifier|final
name|int
name|ZZ_BUFFERSIZE
init|=
literal|16384
decl_stmt|;
comment|/** lexical states */
specifier|public
specifier|static
specifier|final
name|int
name|EOL_COMMENT
init|=
literal|2
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|YYINITIAL
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|MLC
init|=
literal|1
decl_stmt|;
comment|/**     * Translates characters to character classes    */
specifier|private
specifier|static
specifier|final
name|String
name|ZZ_CMAP_PACKED
init|=
literal|"\11\0\1\21\1\10\1\0\1\21\1\17\22\0\1\21\1\43\1\15"
operator|+
literal|"\1\20\1\1\1\47\1\45\1\7\2\44\1\22\1\46\1\41\1\26"
operator|+
literal|"\1\24\1\50\1\4\3\16\4\6\2\3\1\54\1\41\1\71\1\70"
operator|+
literal|"\1\72\1\43\1\42\1\35\1\56\1\5\1\60\1\25\1\33\1\65"
operator|+
literal|"\1\51\1\53\1\67\1\57\1\36\1\64\1\61\1\63\1\52\1\1"
operator|+
literal|"\1\31\1\37\1\27\1\12\1\62\1\55\1\23\1\66\1\1\1\44"
operator|+
literal|"\1\11\1\44\1\73\1\2\1\0\1\35\1\14\1\5\1\60\1\25"
operator|+
literal|"\1\34\1\65\1\75\1\53\1\67\1\57\1\36\1\64\1\13\1\63"
operator|+
literal|"\1\52\1\1\1\32\1\37\1\30\1\12\1\62\1\76\1\23\1\66"
operator|+
literal|"\1\1\1\40\1\74\1\40\1\43\uff81\0"
decl_stmt|;
comment|/**     * Translates characters to character classes    */
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|ZZ_CMAP
init|=
name|zzUnpackCMap
argument_list|(
name|ZZ_CMAP_PACKED
argument_list|)
decl_stmt|;
comment|/**     * Translates DFA states to action switch labels.    */
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|ZZ_ACTION
init|=
name|zzUnpackAction
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|ZZ_ACTION_PACKED_0
init|=
literal|"\3\0\2\1\2\2\1\3\1\4\1\1\1\5\1\1"
operator|+
literal|"\1\6\1\7\2\1\1\7\3\1\1\10\3\7\2\1"
operator|+
literal|"\3\7\1\11\1\12\10\11\1\13\6\11\1\0\1\14"
operator|+
literal|"\1\0\2\14\1\3\1\15\1\0\1\3\1\1\2\5"
operator|+
literal|"\1\16\1\0\1\17\1\20\7\0\1\21\7\1\1\22"
operator|+
literal|"\2\11\2\0\2\11\2\0\2\11\2\0\2\11\3\0"
operator|+
literal|"\1\21\1\0\1\23\1\3\1\24\2\3\1\15\1\3"
operator|+
literal|"\1\1\1\5\1\25\1\5\11\0\1\26\2\0\10\1"
operator|+
literal|"\2\11\2\0\2\11\2\0\2\11\2\0\2\11\3\0"
operator|+
literal|"\1\3\1\5\11\0\1\1\1\27\6\1\1\11\1\0"
operator|+
literal|"\2\11\1\30\1\0\1\11\1\0\2\11\1\31\2\0"
operator|+
literal|"\1\3\1\5\1\0\1\26\6\0\6\1\1\11\2\0"
operator|+
literal|"\1\11\3\0\1\3\1\5\4\0\3\1\1\32\2\0"
operator|+
literal|"\14\1"
decl_stmt|;
specifier|private
specifier|static
name|int
index|[]
name|zzUnpackAction
parameter_list|()
block|{
name|int
index|[]
name|result
init|=
operator|new
name|int
index|[
literal|224
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|offset
operator|=
name|zzUnpackAction
argument_list|(
name|ZZ_ACTION_PACKED_0
argument_list|,
name|offset
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
specifier|static
name|int
name|zzUnpackAction
parameter_list|(
name|String
name|packed
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
index|[]
name|result
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* index in packed string  */
name|int
name|j
init|=
name|offset
decl_stmt|;
comment|/* index in unpacked array */
name|int
name|l
init|=
name|packed
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|l
condition|)
block|{
name|int
name|count
init|=
name|packed
operator|.
name|charAt
argument_list|(
name|i
operator|++
argument_list|)
decl_stmt|;
name|int
name|value
init|=
name|packed
operator|.
name|charAt
argument_list|(
name|i
operator|++
argument_list|)
decl_stmt|;
do|do
name|result
index|[
name|j
operator|++
index|]
operator|=
name|value
expr_stmt|;
do|while
condition|(
operator|--
name|count
operator|>
literal|0
condition|)
do|;
block|}
return|return
name|j
return|;
block|}
comment|/**     * Translates a state to a row index in the transition table    */
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|ZZ_ROWMAP
init|=
name|zzUnpackRowMap
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|ZZ_ROWMAP_PACKED_0
init|=
literal|"\0\0\0\77\0\176\0\275\0\374\0\u013b\0\u017a\0\u01b9"
operator|+
literal|"\0\275\0\u01f8\0\u0237\0\u0276\0\u02b5\0\u02f4\0\u0333\0\u0372"
operator|+
literal|"\0\u03b1\0\u03f0\0\u042f\0\u046e\0\275\0\275\0\u04ad\0\u04ec"
operator|+
literal|"\0\u052b\0\u056a\0\u05a9\0\u05e8\0\u0627\0\u0666\0\275\0\u06a5"
operator|+
literal|"\0\u06e4\0\u0723\0\u0762\0\u07a1\0\u07e0\0\u081f\0\u085e\0\275"
operator|+
literal|"\0\u089d\0\u08dc\0\u091b\0\u095a\0\u0999\0\u09d8\0\u0a17\0\u0a56"
operator|+
literal|"\0\u0333\0\u0a95\0\u0ad4\0\u0b13\0\275\0\u0b52\0\u0b91\0\u0bd0"
operator|+
literal|"\0\u0c0f\0\u0c4e\0\275\0\u0c8d\0\275\0\275\0\u0ccc\0\u0d0b"
operator|+
literal|"\0\u0d4a\0\u0d89\0\u0dc8\0\u0e07\0\u0e46\0\u0e85\0\u0ec4\0\u0f03"
operator|+
literal|"\0\u0f42\0\u0f81\0\u0fc0\0\u0fff\0\u103e\0\275\0\u107d\0\u10bc"
operator|+
literal|"\0\u10fb\0\u113a\0\u1179\0\u11b8\0\u11f7\0\u1236\0\u1275\0\u12b4"
operator|+
literal|"\0\u12f3\0\u1332\0\u1371\0\u13b0\0\u13ef\0\u142e\0\u146d\0\u14ac"
operator|+
literal|"\0\u14eb\0\u0ad4\0\u152a\0\275\0\u1569\0\u15a8\0\u0b52\0\u15e7"
operator|+
literal|"\0\u1626\0\u1665\0\275\0\u16a4\0\u16e3\0\u1722\0\u1761\0\u17a0"
operator|+
literal|"\0\u17df\0\u181e\0\u185d\0\u189c\0\u18db\0\275\0\u191a\0\u1959"
operator|+
literal|"\0\u1998\0\u19d7\0\u1a16\0\u1a55\0\u1a94\0\u1ad3\0\u1b12\0\u1b51"
operator|+
literal|"\0\u1b90\0\u1bcf\0\u1c0e\0\u1c4d\0\u1c8c\0\u1ccb\0\u1d0a\0\u1d49"
operator|+
literal|"\0\u1d88\0\u1dc7\0\u1e06\0\u1e45\0\u1e84\0\u1ec3\0\u1f02\0\u1f41"
operator|+
literal|"\0\u1f80\0\u1fbf\0\u1ffe\0\u203d\0\u207c\0\u20bb\0\u20fa\0\u2139"
operator|+
literal|"\0\u2178\0\u21b7\0\u21f6\0\u2235\0\u2274\0\374\0\u22b3\0\u22f2"
operator|+
literal|"\0\u2331\0\u2370\0\u23af\0\u23ee\0\u242d\0\u246c\0\u24ab\0\u24ea"
operator|+
literal|"\0\u2529\0\u2568\0\u25a7\0\u25e6\0\u2625\0\u2664\0\u26a3\0\u26e2"
operator|+
literal|"\0\u2721\0\u2760\0\u279f\0\u27de\0\u281d\0\u285c\0\u289b\0\u28da"
operator|+
literal|"\0\u2919\0\u2958\0\u2997\0\u29d6\0\u2a15\0\u2a54\0\u2a93\0\u2ad2"
operator|+
literal|"\0\u2b11\0\u2b50\0\u2b8f\0\u2529\0\u2bce\0\u2c0d\0\u26a3\0\u2c4c"
operator|+
literal|"\0\u2c8b\0\u2cca\0\u2d09\0\u2d48\0\u2d87\0\u2dc6\0\u2e05\0\u2e44"
operator|+
literal|"\0\u2e83\0\374\0\u2ec2\0\u2f01\0\u2f40\0\u2f7f\0\u2fbe\0\u2ffd"
operator|+
literal|"\0\u303c\0\u307b\0\u30ba\0\u30f9\0\u3138\0\u3177\0\u31b6\0\u31f5"
decl_stmt|;
specifier|private
specifier|static
name|int
index|[]
name|zzUnpackRowMap
parameter_list|()
block|{
name|int
index|[]
name|result
init|=
operator|new
name|int
index|[
literal|224
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|offset
operator|=
name|zzUnpackRowMap
argument_list|(
name|ZZ_ROWMAP_PACKED_0
argument_list|,
name|offset
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
specifier|static
name|int
name|zzUnpackRowMap
parameter_list|(
name|String
name|packed
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
index|[]
name|result
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* index in packed string  */
name|int
name|j
init|=
name|offset
decl_stmt|;
comment|/* index in unpacked array */
name|int
name|l
init|=
name|packed
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|l
condition|)
block|{
name|int
name|high
init|=
name|packed
operator|.
name|charAt
argument_list|(
name|i
operator|++
argument_list|)
operator|<<
literal|16
decl_stmt|;
name|result
index|[
name|j
operator|++
index|]
operator|=
name|high
operator||
name|packed
operator|.
name|charAt
argument_list|(
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
return|return
name|j
return|;
block|}
comment|/**     * The transition table of the DFA    */
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|ZZ_TRANS
init|=
name|zzUnpackTrans
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|ZZ_TRANS_PACKED_0
init|=
literal|"\1\4\2\5\1\6\1\7\1\5\1\6\1\10\1\11"
operator|+
literal|"\1\4\2\5\1\12\1\13\1\6\1\4\1\14\1\15"
operator|+
literal|"\1\16\1\5\1\17\1\20\1\21\2\22\2\5\2\23"
operator|+
literal|"\2\5\1\24\1\25\2\4\1\26\1\25\1\27\1\30"
operator|+
literal|"\2\16\2\5\1\31\1\26\1\5\1\12\4\5\1\32"
operator|+
literal|"\4\5\1\16\1\33\1\34\1\26\1\35\2\5\10\36"
operator|+
literal|"\1\37\11\36\1\40\10\36\1\41\1\42\14\36\1\43"
operator|+
literal|"\3\36\1\44\17\36\1\45\1\46\10\47\1\50\22\47"
operator|+
literal|"\1\51\1\52\14\47\1\53\3\47\1\54\17\47\1\55"
operator|+
literal|"\1\56\100\0\6\5\2\0\1\57\3\5\1\0\1\5"
operator|+
literal|"\4\0\1\5\1\0\1\5\1\0\11\5\11\0\3\5"
operator|+
literal|"\1\0\13\5\5\0\2\5\3\60\2\6\1\60\1\6"
operator|+
literal|"\2\0\4\60\1\0\1\6\1\0\1\60\2\0\1\60"
operator|+
literal|"\1\61\1\62\1\0\11\60\2\0\1\60\6\0\3\60"
operator|+
literal|"\1\0\13\60\5\0\5\60\2\6\1\60\1\6\2\0"
operator|+
literal|"\4\60\1\0\1\6\1\0\1\60\2\0\1\63\1\61"
operator|+
literal|"\1\62\1\0\11\60\2\0\1\60\6\0\3\60\1\0"
operator|+
literal|"\13\60\5\0\2\60\7\64\1\65\1\66\1\67\65\64"
operator|+
literal|"\1\0\6\5\2\0\1\57\3\5\1\0\1\5\4\0"
operator|+
literal|"\1\5\1\0\1\5\1\0\6\5\1\70\2\5\11\0"
operator|+
literal|"\3\5\1\0\13\5\5\0\2\5\10\13\1\71\1\72"
operator|+
literal|"\3\13\1\73\61\13\14\0\1\74\3\0\1\75\1\0"
operator|+
literal|"\1\76\2\0\1\77\5\0\2\100\2\0\1\101\12\0"
operator|+
literal|"\1\102\1\103\2\0\1\74\1\0\1\104\3\0\1\105"
operator|+
literal|"\33\0\1\15\145\0\1\26\11\0\2\106\1\0\1\106"
operator|+
literal|"\7\0\1\106\61\0\6\5\2\0\1\57\1\5\1\107"
operator|+
literal|"\1\5\1\0\1\5\4\0\1\5\1\0\1\5\1\0"
operator|+
literal|"\11\5\11\0\3\5\1\0\4\5\1\107\6\5\5\0"
operator|+
literal|"\2\5\26\0\1\26\41\0\1\26\7\0\6\5\2\0"
operator|+
literal|"\1\57\3\5\1\0\1\5\4\0\1\5\1\0\1\5"
operator|+
literal|"\1\0\2\5\2\110\5\5\11\0\3\5\1\0\13\5"
operator|+
literal|"\5\0\2\5\1\0\6\5\2\0\1\57\3\5\1\0"
operator|+
literal|"\1\5\4\0\1\5\1\0\1\5\1\0\6\5\1\111"
operator|+
literal|"\2\5\11\0\3\5\1\0\13\5\5\0\2\5\1\0"
operator|+
literal|"\6\5\2\0\1\57\1\112\2\5\1\0\1\5\4\0"
operator|+
literal|"\1\5\1\0\1\5\1\0\2\113\7\5\11\0\3\5"
operator|+
literal|"\1\0\13\5\5\0\2\5\45\0\1\26\77\0\1\26"
operator|+
literal|"\21\0\1\26\7\0\6\5\2\0\1\57\3\5\1\0"
operator|+
literal|"\1\5\4\0\1\5\1\0\1\5\1\0\11\5\11\0"
operator|+
literal|"\3\5\1\0\7\5\1\114\3\5\5\0\2\5\1\0"
operator|+
literal|"\6\5\2\0\1\57\2\5\1\115\1\0\1\5\4\0"
operator|+
literal|"\1\5\1\0\1\5\1\0\11\5\11\0\3\5\1\0"
operator|+
literal|"\1\5\1\115\11\5\5\0\2\5\71\0\1\16\77\0"
operator|+
literal|"\1\16\100\0\1\26\2\0\10\36\1\0\11\36\1\0"
operator|+
literal|"\11\36\1\0\40\36\22\0\1\116\56\0\10\36\1\0"
operator|+
literal|"\11\36\1\0\4\36\2\117\3\36\1\0\16\36\1\120"
operator|+
literal|"\21\36\31\0\2\121\22\0\1\122\23\0\10\36\1\0"
operator|+
literal|"\11\36\1\0\4\36\2\123\3\36\1\0\40\36\2\0"
operator|+
literal|"\10\36\1\0\11\36\1\0\11\36\1\0\20\36\1\124"
operator|+
literal|"\17\36\1\0\1\125\27\0\2\126\123\0\1\125\20\0"
operator|+
literal|"\1\125\10\47\1\0\23\47\1\0\40\47\2\0\10\47"
operator|+
literal|"\1\0\16\47\2\127\3\47\1\0\16\47\1\130\21\47"
operator|+
literal|"\31\0\2\131\22\0\1\132\23\0\10\47\1\0\16\47"
operator|+
literal|"\2\133\3\47\1\0\40\47\2\0\10\47\1\0\23\47"
operator|+
literal|"\1\0\20\47\1\134\17\47\1\0\1\135\27\0\2\136"
operator|+
literal|"\123\0\1\135\20\0\1\135\12\0\1\137\64\0\7\60"
operator|+
literal|"\2\0\4\60\1\0\1\60\1\0\1\60\2\0\1\60"
operator|+
literal|"\1\0\1\60\1\0\11\60\2\0\1\60\6\0\3\60"
operator|+
literal|"\1\0\13\60\5\0\5\60\2\140\1\60\1\140\2\0"
operator|+
literal|"\4\60\1\0\1\140\1\0\1\60\2\0\1\60\1\0"
operator|+
literal|"\1\60\1\141\11\60\2\0\1\60\3\0\1\141\2\0"
operator|+
literal|"\3\60\1\0\13\60\5\0\5\60\4\142\2\0\3\60"
operator|+
literal|"\1\142\1\0\1\142\1\0\1\60\2\0\1\60\1\0"
operator|+
literal|"\1\142\1\0\4\60\3\142\2\60\2\0\1\60\6\0"
operator|+
literal|"\3\60\1\0\1\60\1\142\1\60\1\142\7\60\5\0"
operator|+
literal|"\2\60\7\143\1\144\1\0\66\143\7\0\1\144\67\0"
operator|+
literal|"\4\143\1\145\1\143\1\146\1\147\1\0\1\64\1\150"
operator|+
literal|"\3\64\1\145\11\143\1\64\1\143\1\64\1\143\1\64"
operator|+
literal|"\42\143\1\0\6\5\2\0\1\57\3\5\1\0\1\5"
operator|+
literal|"\4\0\1\5\1\0\1\5\1\0\10\5\1\151\11\0"
operator|+
literal|"\3\5\1\0\13\5\5\0\2\5\11\71\1\152\3\71"
operator|+
literal|"\1\153\65\71\1\13\1\71\2\13\1\0\1\13\1\154"
operator|+
literal|"\4\13\11\71\1\13\1\71\1\13\1\71\1\13\42\71"
operator|+
literal|"\31\0\2\155\57\0\1\156\22\0\1\157\22\0\1\156"
operator|+
literal|"\1\160\77\0\1\161\40\0\1\162\1\0\2\163\103\0"
operator|+
literal|"\1\164\54\0\1\165\17\0\2\166\24\0\1\165\42\0"
operator|+
literal|"\1\167\106\0\1\170\41\0\3\60\2\106\1\60\1\106"
operator|+
literal|"\2\0\4\60\1\0\1\106\1\0\1\60\2\0\1\60"
operator|+
literal|"\1\0\1\62\1\0\11\60\2\0\1\60\6\0\3\60"
operator|+
literal|"\1\0\13\60\5\0\2\60\1\0\6\5\2\0\1\57"
operator|+
literal|"\3\5\1\0\1\5\4\0\1\5\1\0\1\5\1\0"
operator|+
literal|"\2\171\7\5\11\0\3\5\1\0\13\5\5\0\2\5"
operator|+
literal|"\1\0\6\5\2\0\1\57\1\172\2\5\1\0\1\5"
operator|+
literal|"\4\0\1\5\1\0\1\5\1\0\11\5\11\0\3\5"
operator|+
literal|"\1\0\13\5\5\0\2\5\1\0\6\5\2\0\1\57"
operator|+
literal|"\3\5\1\0\1\5\4\0\1\5\1\0\1\5\1\0"
operator|+
literal|"\7\5\1\173\1\5\11\0\3\5\1\0\13\5\5\0"
operator|+
literal|"\2\5\1\0\6\5\2\0\1\57\2\5\1\174\1\0"
operator|+
literal|"\1\5\4\0\1\5\1\0\1\5\1\0\11\5\11\0"
operator|+
literal|"\1\5\1\175\1\5\1\0\1\5\1\174\11\5\5\0"
operator|+
literal|"\2\5\1\0\6\5\2\0\1\57\3\5\1\0\1\5"
operator|+
literal|"\4\0\1\5\1\0\1\5\1\0\2\5\2\176\5\5"
operator|+
literal|"\11\0\3\5\1\0\13\5\5\0\2\5\1\0\6\5"
operator|+
literal|"\2\0\1\57\3\5\1\0\1\5\4\0\1\5\1\0"
operator|+
literal|"\1\5\1\0\11\5\11\0\1\5\1\177\1\5\1\0"
operator|+
literal|"\13\5\5\0\2\5\1\0\6\5\2\0\1\57\3\5"
operator|+
literal|"\1\0\1\5\4\0\1\5\1\0\1\5\1\0\11\5"
operator|+
literal|"\11\0\3\5\1\0\12\5\1\200\5\0\2\5\10\36"
operator|+
literal|"\1\0\11\36\1\0\11\36\1\0\15\36\1\201\22\36"
operator|+
literal|"\2\0\10\36\1\0\11\36\1\0\11\36\1\0\1\36"
operator|+
literal|"\1\202\36\36\54\0\1\203\62\0\1\204\40\0\10\36"
operator|+
literal|"\1\0\11\36\1\0\4\36\2\205\3\36\1\0\40\36"
operator|+
literal|"\2\0\10\36\1\0\11\36\1\0\11\36\1\0\20\36"
operator|+
literal|"\1\206\17\36\1\0\1\207\55\0\1\207\20\0\1\207"
operator|+
literal|"\27\0\2\210\46\0\10\47\1\0\23\47\1\0\15\47"
operator|+
literal|"\1\211\22\47\2\0\10\47\1\0\23\47\1\0\1\47"
operator|+
literal|"\1\212\36\47\54\0\1\213\62\0\1\214\40\0\10\47"
operator|+
literal|"\1\0\16\47\2\215\3\47\1\0\40\47\2\0\10\47"
operator|+
literal|"\1\0\23\47\1\0\20\47\1\216\17\47\1\0\1\217"
operator|+
literal|"\55\0\1\217\20\0\1\217\27\0\2\220\51\0\4\221"
operator|+
literal|"\5\0\1\221\1\0\1\221\6\0\1\221\5\0\3\221"
operator|+
literal|"\20\0\1\221\1\0\1\221\16\0\3\60\2\140\1\60"
operator|+
literal|"\1\140\2\0\4\60\1\0\1\140\1\0\1\60\2\0"
operator|+
literal|"\1\60\1\0\1\60\1\0\11\60\2\0\1\60\6\0"
operator|+
literal|"\3\60\1\0\13\60\5\0\2\60\3\0\2\140\1\0"
operator|+
literal|"\1\140\7\0\1\140\60\0\7\143\1\65\1\0\72\143"
operator|+
literal|"\1\146\1\143\1\146\1\144\1\0\5\143\1\146\64\143"
operator|+
literal|"\1\64\1\143\1\64\1\144\1\0\5\143\1\64\63\143"
operator|+
literal|"\4\222\1\65\1\0\3\143\1\222\1\143\1\222\6\143"
operator|+
literal|"\1\222\5\143\3\222\20\143\1\222\1\143\1\222\16\143"
operator|+
literal|"\1\0\6\5\2\0\1\57\3\5\1\0\1\5\4\0"
operator|+
literal|"\1\5\1\0\1\174\1\0\11\5\11\0\3\5\1\0"
operator|+
literal|"\13\5\5\0\2\5\10\71\1\0\71\71\4\223\2\71"
operator|+
literal|"\1\152\2\71\1\223\1\153\1\223\6\71\1\223\5\71"
operator|+
literal|"\3\223\20\71\1\223\1\71\1\223\16\71\25\0\1\224"
operator|+
literal|"\131\0\1\166\55\0\1\225\74\0\1\226\72\0\2\227"
operator|+
literal|"\73\0\2\166\131\0\1\230\44\0\2\231\51\0\1\232"
operator|+
literal|"\124\0\2\233\47\0\1\234\72\0\6\5\2\0\1\57"
operator|+
literal|"\3\5\1\0\1\5\4\0\1\5\1\0\1\5\1\0"
operator|+
literal|"\11\5\11\0\2\5\1\235\1\0\13\5\5\0\2\5"
operator|+
literal|"\1\0\6\5\2\0\1\57\3\5\1\0\1\5\4\0"
operator|+
literal|"\1\5\1\0\1\236\1\0\11\5\11\0\3\5\1\0"
operator|+
literal|"\13\5\5\0\2\5\1\0\6\5\2\0\1\57\3\5"
operator|+
literal|"\1\0\1\5\4\0\1\5\1\0\1\5\1\0\10\5"
operator|+
literal|"\1\172\11\0\3\5\1\0\13\5\5\0\2\5\1\0"
operator|+
literal|"\4\5\1\237\1\5\2\0\1\57\3\5\1\0\1\5"
operator|+
literal|"\4\0\1\5\1\0\1\5\1\0\11\5\11\0\1\5"
operator|+
literal|"\1\240\1\5\1\0\13\5\5\0\2\5\1\0\6\5"
operator|+
literal|"\2\0\1\57\3\5\1\0\1\5\4\0\1\5\1\0"
operator|+
literal|"\1\241\1\0\11\5\11\0\3\5\1\0\13\5\5\0"
operator|+
literal|"\2\5\1\0\6\5\2\0\1\57\3\5\1\0\1\5"
operator|+
literal|"\4\0\1\5\1\0\1\5\1\0\11\5\11\0\2\5"
operator|+
literal|"\1\242\1\0\13\5\5\0\2\5\1\0\6\5\2\0"
operator|+
literal|"\1\57\3\5\1\0\1\5\4\0\1\5\1\0\1\5"
operator|+
literal|"\1\0\11\5\11\0\3\5\1\0\6\5\1\243\4\5"
operator|+
literal|"\5\0\2\5\1\0\6\5\2\0\1\57\3\5\1\0"
operator|+
literal|"\1\5\4\0\1\5\1\0\1\244\1\0\11\5\11\0"
operator|+
literal|"\3\5\1\0\13\5\5\0\2\5\10\36\1\0\11\36"
operator|+
literal|"\1\0\11\36\1\0\17\36\1\245\20\36\2\0\10\36"
operator|+
literal|"\1\0\11\36\1\0\2\36\1\201\6\36\1\0\40\36"
operator|+
literal|"\56\0\1\246\47\0\1\203\51\0\10\36\1\0\11\36"
operator|+
literal|"\1\0\11\36\1\0\15\36\1\247\22\36\2\0\10\36"
operator|+
literal|"\1\0\11\36\1\0\1\36\1\250\7\36\1\0\40\36"
operator|+
literal|"\26\0\1\251\124\0\1\252\24\0\10\47\1\0\23\47"
operator|+
literal|"\1\0\17\47\1\253\20\47\2\0\10\47\1\0\14\47"
operator|+
literal|"\1\211\6\47\1\0\40\47\56\0\1\254\47\0\1\213"
operator|+
literal|"\51\0\10\47\1\0\23\47\1\0\15\47\1\255\22\47"
operator|+
literal|"\2\0\10\47\1\0\13\47\1\256\7\47\1\0\40\47"
operator|+
literal|"\26\0\1\257\124\0\1\260\27\0\4\261\5\0\1\261"
operator|+
literal|"\1\0\1\261\6\0\1\261\5\0\3\261\20\0\1\261"
operator|+
literal|"\1\0\1\261\16\0\3\143\4\262\1\65\1\0\3\143"
operator|+
literal|"\1\262\1\143\1\262\6\143\1\262\5\143\3\262\20\143"
operator|+
literal|"\1\262\1\143\1\262\16\143\3\71\4\263\2\71\1\152"
operator|+
literal|"\2\71\1\263\1\153\1\263\6\71\1\263\5\71\3\263"
operator|+
literal|"\20\71\1\263\1\71\1\263\16\71\35\0\1\264\66\0"
operator|+
literal|"\1\265\107\0\1\266\65\0\1\267\123\0\1\166\63\0"
operator|+
literal|"\1\270\75\0\1\271\113\0\1\272\54\0\2\273\45\0"
operator|+
literal|"\6\5\2\0\1\57\3\5\1\0\1\5\4\0\1\5"
operator|+
literal|"\1\0\1\5\1\0\2\274\7\5\11\0\3\5\1\0"
operator|+
literal|"\13\5\5\0\2\5\1\0\6\5\2\0\1\57\3\5"
operator|+
literal|"\1\0\1\5\4\0\1\5\1\0\1\5\1\0\7\5"
operator|+
literal|"\1\275\1\5\11\0\3\5\1\0\13\5\5\0\2\5"
operator|+
literal|"\1\0\6\5\2\0\1\57\3\5\1\0\1\5\4\0"
operator|+
literal|"\1\5\1\0\1\5\1\0\6\5\1\276\2\5\11\0"
operator|+
literal|"\3\5\1\0\13\5\5\0\2\5\1\0\6\5\2\0"
operator|+
literal|"\1\57\3\5\1\0\1\5\4\0\1\5\1\0\1\5"
operator|+
literal|"\1\0\2\5\2\174\5\5\11\0\3\5\1\0\13\5"
operator|+
literal|"\5\0\2\5\1\0\6\5\2\0\1\57\1\5\1\277"
operator|+
literal|"\1\5\1\0\1\5\4\0\1\5\1\0\1\5\1\0"
operator|+
literal|"\11\5\11\0\3\5\1\0\4\5\1\277\6\5\5\0"
operator|+
literal|"\2\5\1\0\6\5\2\0\1\57\3\5\1\0\1\5"
operator|+
literal|"\4\0\1\5\1\0\1\5\1\0\2\5\2\300\5\5"
operator|+
literal|"\11\0\3\5\1\0\13\5\5\0\2\5\1\0\4\5"
operator|+
literal|"\1\301\1\5\2\0\1\57\3\5\1\0\1\5\4\0"
operator|+
literal|"\1\5\1\0\1\5\1\0\11\5\11\0\3\5\1\0"
operator|+
literal|"\13\5\5\0\2\5\10\36\1\0\11\36\1\0\11\36"
operator|+
literal|"\1\0\13\36\1\302\24\36\52\0\1\303\26\0\10\36"
operator|+
literal|"\1\0\11\36\1\0\11\36\1\0\2\36\1\201\14\36"
operator|+
literal|"\1\245\20\36\2\0\1\36\7\250\1\0\1\36\3\250"
operator|+
literal|"\1\36\1\250\1\36\1\250\1\36\1\304\11\250\1\251"
operator|+
literal|"\3\250\1\36\30\250\4\36\2\251\1\0\1\251\1\304"
operator|+
literal|"\4\251\1\304\2\0\3\251\1\0\1\251\1\0\1\304"
operator|+
literal|"\1\0\1\304\1\251\1\304\1\251\1\304\11\251\1\0"
operator|+
literal|"\7\304\4\251\1\304\13\251\1\304\4\0\2\251\37\0"
operator|+
literal|"\1\203\14\0\1\246\22\0\10\47\1\0\23\47\1\0"
operator|+
literal|"\13\47\1\305\24\47\52\0\1\306\26\0\10\47\1\0"
operator|+
literal|"\23\47\1\0\2\47\1\211\14\47\1\253\20\47\2\0"
operator|+
literal|"\1\47\7\256\1\0\1\47\3\256\1\47\1\256\1\47"
operator|+
literal|"\1\256\1\47\12\256\1\257\3\256\1\47\30\256\4\47"
operator|+
literal|"\2\257\1\0\1\257\1\307\4\257\1\307\2\0\3\257"
operator|+
literal|"\1\0\1\257\1\0\1\307\1\0\1\307\1\257\1\307"
operator|+
literal|"\1\257\1\307\11\257\1\0\7\307\4\257\1\307\13\257"
operator|+
literal|"\1\307\4\0\2\257\37\0\1\213\14\0\1\254\25\0"
operator|+
literal|"\4\310\5\0\1\310\1\0\1\310\6\0\1\310\5\0"
operator|+
literal|"\3\310\20\0\1\310\1\0\1\310\16\0\3\143\4\311"
operator|+
literal|"\1\65\1\0\3\143\1\311\1\143\1\311\6\143\1\311"
operator|+
literal|"\5\143\3\311\20\143\1\311\1\143\1\311\16\143\3\71"
operator|+
literal|"\4\312\2\71\1\152\2\71\1\312\1\153\1\312\6\71"
operator|+
literal|"\1\312\5\71\3\312\20\71\1\312\1\71\1\312\16\71"
operator|+
literal|"\57\0\1\166\72\0\1\313\35\0\1\314\121\0\1\315"
operator|+
literal|"\66\0\1\166\63\0\1\316\77\0\1\270\45\0\1\270"
operator|+
literal|"\100\0\1\166\14\0\6\5\2\0\1\57\3\5\1\0"
operator|+
literal|"\1\5\4\0\1\5\1\0\1\5\1\0\11\5\11\0"
operator|+
literal|"\3\5\1\0\11\5\1\317\1\5\5\0\2\5\1\0"
operator|+
literal|"\6\5\2\0\1\57\3\5\1\0\1\5\4\0\1\5"
operator|+
literal|"\1\0\1\5\1\0\6\5\1\320\2\5\11\0\3\5"
operator|+
literal|"\1\0\13\5\5\0\2\5\1\0\4\5\1\321\1\5"
operator|+
literal|"\2\0\1\57\3\5\1\0\1\5\4\0\1\5\1\0"
operator|+
literal|"\1\5\1\0\11\5\11\0\3\5\1\0\13\5\5\0"
operator|+
literal|"\2\5\1\0\6\5\2\0\1\57\3\5\1\0\1\5"
operator|+
literal|"\4\0\1\5\1\0\1\5\1\0\11\5\11\0\3\5"
operator|+
literal|"\1\0\10\5\1\317\2\5\5\0\2\5\1\0\6\5"
operator|+
literal|"\2\0\1\57\3\5\1\0\1\5\4\0\1\5\1\0"
operator|+
literal|"\1\5\1\0\2\317\7\5\11\0\3\5\1\0\13\5"
operator|+
literal|"\5\0\2\5\1\0\6\5\2\0\1\57\3\5\1\0"
operator|+
literal|"\1\5\4\0\1\5\1\0\1\5\1\0\2\322\7\5"
operator|+
literal|"\11\0\3\5\1\0\13\5\5\0\2\5\10\36\1\0"
operator|+
literal|"\11\36\1\0\11\36\1\0\13\36\1\250\24\36\52\0"
operator|+
literal|"\1\251\26\0\10\47\1\0\23\47\1\0\13\47\1\256"
operator|+
literal|"\24\47\52\0\1\257\31\0\4\5\5\0\1\5\1\0"
operator|+
literal|"\1\5\6\0\1\5\5\0\3\5\20\0\1\5\1\0"
operator|+
literal|"\1\5\16\0\3\143\4\64\1\65\1\0\3\143\1\64"
operator|+
literal|"\1\143\1\64\6\143\1\64\5\143\3\64\20\143\1\64"
operator|+
literal|"\1\143\1\64\16\143\3\71\4\13\2\71\1\152\2\71"
operator|+
literal|"\1\13\1\153\1\13\6\71\1\13\5\71\3\13\20\71"
operator|+
literal|"\1\13\1\71\1\13\16\71\33\0\2\166\77\0\1\323"
operator|+
literal|"\46\0\1\324\151\0\1\270\17\0\6\5\2\0\1\57"
operator|+
literal|"\1\325\2\5\1\0\1\5\4\0\1\5\1\0\1\5"
operator|+
literal|"\1\0\11\5\11\0\3\5\1\0\13\5\5\0\2\5"
operator|+
literal|"\1\0\6\5\2\0\1\57\3\5\1\0\1\5\4\0"
operator|+
literal|"\1\5\1\0\1\5\1\0\10\5\1\326\11\0\3\5"
operator|+
literal|"\1\0\13\5\5\0\2\5\1\0\6\5\2\0\1\57"
operator|+
literal|"\3\5\1\0\1\5\4\0\1\5\1\0\1\5\1\0"
operator|+
literal|"\11\5\11\0\3\5\1\0\2\5\1\327\10\5\5\0"
operator|+
literal|"\2\5\27\0\2\270\117\0\1\166\23\0\1\166\2\0"
operator|+
literal|"\6\5\2\0\1\57\3\5\1\0\1\5\4\0\1\5"
operator|+
literal|"\1\0\1\5\1\0\2\330\7\5\11\0\3\5\1\0"
operator|+
literal|"\13\5\5\0\2\5\1\0\6\5\2\0\1\57\3\5"
operator|+
literal|"\1\0\1\5\4\0\1\5\1\0\1\5\1\0\10\5"
operator|+
literal|"\1\331\11\0\3\5\1\0\13\5\5\0\2\5\1\0"
operator|+
literal|"\6\5\2\0\1\57\3\5\1\0\1\5\4\0\1\5"
operator|+
literal|"\1\0\1\5\1\0\6\5\1\332\2\5\11\0\3\5"
operator|+
literal|"\1\0\13\5\5\0\2\5\1\0\6\5\2\0\1\57"
operator|+
literal|"\3\5\1\0\1\5\4\0\1\5\1\0\1\5\1\0"
operator|+
literal|"\11\5\11\0\2\5\1\333\1\0\13\5\5\0\2\5"
operator|+
literal|"\1\0\6\5\2\0\1\57\1\5\1\334\1\5\1\0"
operator|+
literal|"\1\5\4\0\1\5\1\0\1\5\1\0\11\5\11\0"
operator|+
literal|"\3\5\1\0\4\5\1\334\6\5\5\0\2\5\1\0"
operator|+
literal|"\6\5\2\0\1\57\3\5\1\0\1\5\4\0\1\5"
operator|+
literal|"\1\0\1\5\1\0\11\5\11\0\3\5\1\0\10\5"
operator|+
literal|"\1\335\2\5\5\0\2\5\1\0\6\5\2\0\1\57"
operator|+
literal|"\3\5\1\0\1\5\4\0\1\5\1\0\1\5\1\0"
operator|+
literal|"\7\5\1\336\1\5\11\0\3\5\1\0\13\5\5\0"
operator|+
literal|"\2\5\1\0\6\5\2\0\1\57\3\5\1\0\1\5"
operator|+
literal|"\4\0\1\5\1\0\1\5\1\0\6\5\1\337\2\5"
operator|+
literal|"\11\0\3\5\1\0\13\5\5\0\2\5\1\0\6\5"
operator|+
literal|"\2\0\1\57\3\5\1\0\1\5\4\0\1\5\1\0"
operator|+
literal|"\1\331\1\0\11\5\11\0\3\5\1\0\13\5\5\0"
operator|+
literal|"\2\5\1\0\6\5\2\0\1\57\3\5\1\0\1\5"
operator|+
literal|"\4\0\1\5\1\0\1\5\1\0\10\5\1\322\11\0"
operator|+
literal|"\3\5\1\0\13\5\5\0\2\5\1\0\6\5\2\0"
operator|+
literal|"\1\57\3\5\1\0\1\5\4\0\1\5\1\0\1\5"
operator|+
literal|"\1\0\11\5\11\0\3\5\1\0\7\5\1\340\3\5"
operator|+
literal|"\5\0\2\5\1\0\6\5\2\0\1\57\3\5\1\0"
operator|+
literal|"\1\5\4\0\1\5\1\0\1\322\1\0\11\5\11\0"
operator|+
literal|"\3\5\1\0\13\5\5\0\2\5"
decl_stmt|;
specifier|private
specifier|static
name|int
index|[]
name|zzUnpackTrans
parameter_list|()
block|{
name|int
index|[]
name|result
init|=
operator|new
name|int
index|[
literal|12852
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|offset
operator|=
name|zzUnpackTrans
argument_list|(
name|ZZ_TRANS_PACKED_0
argument_list|,
name|offset
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
specifier|static
name|int
name|zzUnpackTrans
parameter_list|(
name|String
name|packed
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
index|[]
name|result
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* index in packed string  */
name|int
name|j
init|=
name|offset
decl_stmt|;
comment|/* index in unpacked array */
name|int
name|l
init|=
name|packed
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|l
condition|)
block|{
name|int
name|count
init|=
name|packed
operator|.
name|charAt
argument_list|(
name|i
operator|++
argument_list|)
decl_stmt|;
name|int
name|value
init|=
name|packed
operator|.
name|charAt
argument_list|(
name|i
operator|++
argument_list|)
decl_stmt|;
name|value
operator|--
expr_stmt|;
do|do
name|result
index|[
name|j
operator|++
index|]
operator|=
name|value
expr_stmt|;
do|while
condition|(
operator|--
name|count
operator|>
literal|0
condition|)
do|;
block|}
return|return
name|j
return|;
block|}
comment|/* error codes */
specifier|private
specifier|static
specifier|final
name|int
name|ZZ_UNKNOWN_ERROR
init|=
literal|0
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|ZZ_NO_MATCH
init|=
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|ZZ_PUSHBACK_2BIG
init|=
literal|2
decl_stmt|;
comment|/* error messages for the codes above */
specifier|private
specifier|static
specifier|final
name|String
name|ZZ_ERROR_MSG
index|[]
init|=
block|{
literal|"Unkown internal scanner error"
block|,
literal|"Error: could not match input"
block|,
literal|"Error: pushback value was too large"
block|}
decl_stmt|;
comment|/**    * ZZ_ATTRIBUTE[aState] contains the attributes of state<code>aState</code>    */
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|ZZ_ATTRIBUTE
init|=
name|zzUnpackAttribute
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|ZZ_ATTRIBUTE_PACKED_0
init|=
literal|"\3\0\1\11\4\1\1\11\13\1\2\11\10\1\1\11"
operator|+
literal|"\10\1\1\11\6\1\1\0\1\1\1\0\3\1\1\11"
operator|+
literal|"\1\0\4\1\1\11\1\0\2\11\7\0\10\1\1\11"
operator|+
literal|"\2\1\2\0\2\1\2\0\2\1\2\0\2\1\3\0"
operator|+
literal|"\1\1\1\0\2\1\1\11\6\1\1\11\1\1\11\0"
operator|+
literal|"\1\11\2\0\12\1\2\0\2\1\2\0\2\1\2\0"
operator|+
literal|"\2\1\3\0\2\1\11\0\11\1\1\0\3\1\1\0"
operator|+
literal|"\1\1\1\0\3\1\2\0\2\1\1\0\1\1\6\0"
operator|+
literal|"\7\1\2\0\1\1\3\0\2\1\4\0\4\1\2\0"
operator|+
literal|"\14\1"
decl_stmt|;
specifier|private
specifier|static
name|int
index|[]
name|zzUnpackAttribute
parameter_list|()
block|{
name|int
index|[]
name|result
init|=
operator|new
name|int
index|[
literal|224
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|offset
operator|=
name|zzUnpackAttribute
argument_list|(
name|ZZ_ATTRIBUTE_PACKED_0
argument_list|,
name|offset
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
specifier|static
name|int
name|zzUnpackAttribute
parameter_list|(
name|String
name|packed
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
index|[]
name|result
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* index in packed string  */
name|int
name|j
init|=
name|offset
decl_stmt|;
comment|/* index in unpacked array */
name|int
name|l
init|=
name|packed
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|l
condition|)
block|{
name|int
name|count
init|=
name|packed
operator|.
name|charAt
argument_list|(
name|i
operator|++
argument_list|)
decl_stmt|;
name|int
name|value
init|=
name|packed
operator|.
name|charAt
argument_list|(
name|i
operator|++
argument_list|)
decl_stmt|;
do|do
name|result
index|[
name|j
operator|++
index|]
operator|=
name|value
expr_stmt|;
do|while
condition|(
operator|--
name|count
operator|>
literal|0
condition|)
do|;
block|}
return|return
name|j
return|;
block|}
comment|/** the input device */
specifier|private
name|Reader
name|zzReader
decl_stmt|;
comment|/** the current state of the DFA */
specifier|private
name|int
name|zzState
decl_stmt|;
comment|/** the current lexical state */
specifier|private
name|int
name|zzLexicalState
init|=
name|YYINITIAL
decl_stmt|;
comment|/** this buffer contains the current text to be matched and is       the source of the yytext() string */
specifier|private
name|char
name|zzBuffer
index|[]
decl_stmt|;
comment|/** the textposition at the last accepting state */
specifier|private
name|int
name|zzMarkedPos
decl_stmt|;
comment|/** the textposition at the last state to be included in yytext */
specifier|private
name|int
name|zzPushbackPos
decl_stmt|;
comment|/** the current text position in the buffer */
specifier|private
name|int
name|zzCurrentPos
decl_stmt|;
comment|/** startRead marks the beginning of the yytext() string in the buffer */
specifier|private
name|int
name|zzStartRead
decl_stmt|;
comment|/** endRead marks the last character in the buffer, that has been read       from input */
specifier|private
name|int
name|zzEndRead
decl_stmt|;
comment|/** number of newlines encountered up to the start of the matched text */
specifier|private
name|int
name|yyline
decl_stmt|;
comment|/** the number of characters up to the start of the matched text */
specifier|private
name|int
name|yychar
decl_stmt|;
comment|/**    * the number of characters from the last newline up to the start of the     * matched text    */
specifier|private
name|int
name|yycolumn
decl_stmt|;
comment|/**     * zzAtBOL == true<=> the scanner is currently at the beginning of a line    */
specifier|private
name|boolean
name|zzAtBOL
init|=
literal|true
decl_stmt|;
comment|/** zzAtEOF == true<=> the scanner is at the EOF */
specifier|private
name|boolean
name|zzAtEOF
decl_stmt|;
comment|/* user code: */
comment|/** 	 * Constructor.  This must be here because JFlex does not generate a 	 * no-parameter constructor. 	 */
specifier|public
name|VelocityTokenMaker
parameter_list|()
block|{
block|}
comment|/** 	 * Adds the token specified to the current linked list of tokens. 	 * 	 * @param tokenType The token's type. 	 * @see #addToken(int, int, int) 	 */
specifier|private
name|void
name|addHyperlinkToken
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|int
name|tokenType
parameter_list|)
block|{
name|int
name|so
init|=
name|start
operator|+
name|offsetShift
decl_stmt|;
name|addToken
argument_list|(
name|zzBuffer
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|tokenType
argument_list|,
name|so
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Adds the token specified to the current linked list of tokens. 	 * 	 * @param tokenType The token's type. 	 */
specifier|private
name|void
name|addToken
parameter_list|(
name|int
name|tokenType
parameter_list|)
block|{
name|addToken
argument_list|(
name|zzStartRead
argument_list|,
name|zzMarkedPos
operator|-
literal|1
argument_list|,
name|tokenType
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Adds the token specified to the current linked list of tokens. 	 * 	 * @param tokenType The token's type. 	 * @see #addHyperlinkToken(int, int, int) 	 */
specifier|private
name|void
name|addToken
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|int
name|tokenType
parameter_list|)
block|{
name|int
name|so
init|=
name|start
operator|+
name|offsetShift
decl_stmt|;
name|addToken
argument_list|(
name|zzBuffer
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|tokenType
argument_list|,
name|so
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Adds the token specified to the current linked list of tokens. 	 * 	 * @param array The character array. 	 * @param start The starting offset in the array. 	 * @param end The ending offset in the array. 	 * @param tokenType The token's type. 	 * @param startOffset The offset in the document at which this token 	 *        occurs. 	 * @param hyperlink Whether this token is a hyperlink. 	 */
specifier|public
name|void
name|addToken
parameter_list|(
name|char
index|[]
name|array
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|int
name|tokenType
parameter_list|,
name|int
name|startOffset
parameter_list|,
name|boolean
name|hyperlink
parameter_list|)
block|{
name|super
operator|.
name|addToken
argument_list|(
name|array
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|tokenType
argument_list|,
name|startOffset
argument_list|,
name|hyperlink
argument_list|)
expr_stmt|;
name|zzStartRead
operator|=
name|zzMarkedPos
expr_stmt|;
block|}
comment|/** 	 * {@inheritDoc} 	 */
specifier|public
name|String
index|[]
name|getLineCommentStartAndEnd
parameter_list|(
name|int
name|languageIndex
parameter_list|)
block|{
return|return
operator|new
name|String
index|[]
block|{
literal|"##"
block|,
literal|null
block|}
return|;
block|}
comment|/** 	 * Returns the first token in the linked list of tokens generated 	 * from<code>text</code>.  This method must be implemented by 	 * subclasses so they can correctly implement syntax highlighting. 	 * 	 * @param text The text from which to get tokens. 	 * @param initialTokenType The token type we should start with. 	 * @param startOffset The offset into the document at which 	 *<code>text</code> starts. 	 * @return The first<code>Token</code> in a linked list representing 	 *         the syntax highlighted text. 	 */
specifier|public
name|Token
name|getTokenList
parameter_list|(
name|Segment
name|text
parameter_list|,
name|int
name|initialTokenType
parameter_list|,
name|int
name|startOffset
parameter_list|)
block|{
name|resetTokenList
argument_list|()
expr_stmt|;
name|this
operator|.
name|offsetShift
operator|=
operator|-
name|text
operator|.
name|offset
operator|+
name|startOffset
expr_stmt|;
comment|// Start off in the proper state.
name|int
name|state
init|=
name|Token
operator|.
name|NULL
decl_stmt|;
switch|switch
condition|(
name|initialTokenType
condition|)
block|{
case|case
name|Token
operator|.
name|COMMENT_MULTILINE
case|:
name|state
operator|=
name|MLC
expr_stmt|;
name|start
operator|=
name|text
operator|.
name|offset
expr_stmt|;
break|break;
comment|/* No documentation comments */
default|default:
name|state
operator|=
name|Token
operator|.
name|NULL
expr_stmt|;
block|}
name|s
operator|=
name|text
expr_stmt|;
try|try
block|{
name|yyreset
argument_list|(
name|zzReader
argument_list|)
expr_stmt|;
name|yybegin
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
name|yylex
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|ioe
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
return|return
operator|new
name|TokenImpl
argument_list|()
return|;
block|}
block|}
comment|/** 	 * Refills the input buffer. 	 * 	 * @return<code>true</code> if EOF was reached, otherwise 	 *<code>false</code>. 	 */
specifier|private
name|boolean
name|zzRefill
parameter_list|()
block|{
return|return
name|zzCurrentPos
operator|>=
name|s
operator|.
name|offset
operator|+
name|s
operator|.
name|count
return|;
block|}
comment|/** 	 * Resets the scanner to read from a new input stream. 	 * Does not close the old reader. 	 * 	 * All internal variables are reset, the old input stream  	 *<b>cannot</b> be reused (internal buffer is discarded and lost). 	 * Lexical state is set to<tt>YY_INITIAL</tt>. 	 * 	 * @param reader   the new input stream  	 */
specifier|public
specifier|final
name|void
name|yyreset
parameter_list|(
name|Reader
name|reader
parameter_list|)
block|{
comment|// 's' has been updated.
name|zzBuffer
operator|=
name|s
operator|.
name|array
expr_stmt|;
comment|/* 		 * We replaced the line below with the two below it because zzRefill 		 * no longer "refills" the buffer (since the way we do it, it's always 		 * "full" the first time through, since it points to the segment's 		 * array).  So, we assign zzEndRead here. 		 */
comment|//zzStartRead = zzEndRead = s.offset;
name|zzStartRead
operator|=
name|s
operator|.
name|offset
expr_stmt|;
name|zzEndRead
operator|=
name|zzStartRead
operator|+
name|s
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|zzCurrentPos
operator|=
name|zzMarkedPos
operator|=
name|zzPushbackPos
operator|=
name|s
operator|.
name|offset
expr_stmt|;
name|zzLexicalState
operator|=
name|YYINITIAL
expr_stmt|;
name|zzReader
operator|=
name|reader
expr_stmt|;
name|zzAtBOL
operator|=
literal|true
expr_stmt|;
name|zzAtEOF
operator|=
literal|false
expr_stmt|;
block|}
comment|/**    * Creates a new scanner    * There is also a java.io.InputStream version of this constructor.    *    * @param   in  the java.io.Reader to read input from.    */
specifier|public
name|VelocityTokenMaker
parameter_list|(
name|Reader
name|in
parameter_list|)
block|{
name|this
operator|.
name|zzReader
operator|=
name|in
expr_stmt|;
block|}
comment|/**    * Creates a new scanner.    * There is also java.io.Reader version of this constructor.    *    * @param   in  the java.io.Inputstream to read input from.    */
specifier|public
name|VelocityTokenMaker
parameter_list|(
name|InputStream
name|in
parameter_list|)
block|{
name|this
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**     * Unpacks the compressed character translation table.    *    * @param packed   the packed character translation table    * @return         the unpacked character translation table    */
specifier|private
specifier|static
name|char
index|[]
name|zzUnpackCMap
parameter_list|(
name|String
name|packed
parameter_list|)
block|{
name|char
index|[]
name|map
init|=
operator|new
name|char
index|[
literal|0x10000
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* index in packed string  */
name|int
name|j
init|=
literal|0
decl_stmt|;
comment|/* index in unpacked array */
while|while
condition|(
name|i
operator|<
literal|192
condition|)
block|{
name|int
name|count
init|=
name|packed
operator|.
name|charAt
argument_list|(
name|i
operator|++
argument_list|)
decl_stmt|;
name|char
name|value
init|=
name|packed
operator|.
name|charAt
argument_list|(
name|i
operator|++
argument_list|)
decl_stmt|;
do|do
name|map
index|[
name|j
operator|++
index|]
operator|=
name|value
expr_stmt|;
do|while
condition|(
operator|--
name|count
operator|>
literal|0
condition|)
do|;
block|}
return|return
name|map
return|;
block|}
comment|/**    * Closes the input stream.    */
specifier|public
specifier|final
name|void
name|yyclose
parameter_list|()
throws|throws
name|IOException
block|{
name|zzAtEOF
operator|=
literal|true
expr_stmt|;
comment|/* indicate end of file */
name|zzEndRead
operator|=
name|zzStartRead
expr_stmt|;
comment|/* invalidate buffer    */
if|if
condition|(
name|zzReader
operator|!=
literal|null
condition|)
name|zzReader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Enters a new lexical state    *    * @param newState the new lexical state    */
specifier|public
specifier|final
name|void
name|yybegin
parameter_list|(
name|int
name|newState
parameter_list|)
block|{
name|zzLexicalState
operator|=
name|newState
expr_stmt|;
block|}
comment|/**    * Returns the text matched by the current regular expression.    */
specifier|public
specifier|final
name|String
name|yytext
parameter_list|()
block|{
return|return
operator|new
name|String
argument_list|(
name|zzBuffer
argument_list|,
name|zzStartRead
argument_list|,
name|zzMarkedPos
operator|-
name|zzStartRead
argument_list|)
return|;
block|}
comment|/**    * Returns the character at position<tt>pos</tt> from the     * matched text.     *     * It is equivalent to yytext().charAt(pos), but faster    *    * @param pos the position of the character to fetch.     *            A value from 0 to yylength()-1.    *    * @return the character at position pos    */
specifier|public
specifier|final
name|char
name|yycharat
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
return|return
name|zzBuffer
index|[
name|zzStartRead
operator|+
name|pos
index|]
return|;
block|}
comment|/**    * Returns the length of the matched text region.    */
specifier|public
specifier|final
name|int
name|yylength
parameter_list|()
block|{
return|return
name|zzMarkedPos
operator|-
name|zzStartRead
return|;
block|}
comment|/**    * Reports an error that occured while scanning.    *    * In a wellformed scanner (no or only correct usage of     * yypushback(int) and a match-all fallback rule) this method     * will only be called with things that "Can't Possibly Happen".    * If this method is called, something is seriously wrong    * (e.g. a JFlex bug producing a faulty scanner etc.).    *    * Usual syntax/scanner level error handling should be done    * in error fallback rules.    *    * @param   errorCode  the code of the errormessage to display    */
specifier|private
name|void
name|zzScanError
parameter_list|(
name|int
name|errorCode
parameter_list|)
block|{
name|String
name|message
decl_stmt|;
try|try
block|{
name|message
operator|=
name|ZZ_ERROR_MSG
index|[
name|errorCode
index|]
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
name|message
operator|=
name|ZZ_ERROR_MSG
index|[
name|ZZ_UNKNOWN_ERROR
index|]
expr_stmt|;
block|}
throw|throw
operator|new
name|Error
argument_list|(
name|message
argument_list|)
throw|;
block|}
comment|/**    * Pushes the specified amount of characters back into the input stream.    *    * They will be read again by then next call of the scanning method    *    * @param number  the number of characters to be read again.    *                This number must not be greater than yylength()!    */
specifier|public
name|void
name|yypushback
parameter_list|(
name|int
name|number
parameter_list|)
block|{
if|if
condition|(
name|number
operator|>
name|yylength
argument_list|()
condition|)
name|zzScanError
argument_list|(
name|ZZ_PUSHBACK_2BIG
argument_list|)
expr_stmt|;
name|zzMarkedPos
operator|-=
name|number
expr_stmt|;
block|}
comment|/**    * Resumes scanning until the next regular expression is matched,    * the end of input is encountered or an I/O-Error occurs.    *    * @return      the next token    * @exception   IOException  if any I/O-Error occurs    */
specifier|public
name|Token
name|yylex
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|zzInput
decl_stmt|;
name|int
name|zzAction
decl_stmt|;
comment|// cached fields:
name|int
name|zzCurrentPosL
decl_stmt|;
name|int
name|zzMarkedPosL
decl_stmt|;
name|int
name|zzEndReadL
init|=
name|zzEndRead
decl_stmt|;
name|char
index|[]
name|zzBufferL
init|=
name|zzBuffer
decl_stmt|;
name|char
index|[]
name|zzCMapL
init|=
name|ZZ_CMAP
decl_stmt|;
name|int
index|[]
name|zzTransL
init|=
name|ZZ_TRANS
decl_stmt|;
name|int
index|[]
name|zzRowMapL
init|=
name|ZZ_ROWMAP
decl_stmt|;
name|int
index|[]
name|zzAttrL
init|=
name|ZZ_ATTRIBUTE
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|zzMarkedPosL
operator|=
name|zzMarkedPos
expr_stmt|;
name|zzAction
operator|=
operator|-
literal|1
expr_stmt|;
name|zzCurrentPosL
operator|=
name|zzCurrentPos
operator|=
name|zzStartRead
operator|=
name|zzMarkedPosL
expr_stmt|;
name|zzState
operator|=
name|zzLexicalState
expr_stmt|;
name|zzForAction
label|:
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|zzCurrentPosL
operator|<
name|zzEndReadL
condition|)
name|zzInput
operator|=
name|zzBufferL
index|[
name|zzCurrentPosL
operator|++
index|]
expr_stmt|;
if|else if
condition|(
name|zzAtEOF
condition|)
block|{
name|zzInput
operator|=
name|YYEOF
expr_stmt|;
break|break
name|zzForAction
break|;
block|}
else|else
block|{
comment|// store back cached positions
name|zzCurrentPos
operator|=
name|zzCurrentPosL
expr_stmt|;
name|zzMarkedPos
operator|=
name|zzMarkedPosL
expr_stmt|;
name|boolean
name|eof
init|=
name|zzRefill
argument_list|()
decl_stmt|;
comment|// get translated positions and possibly new buffer
name|zzCurrentPosL
operator|=
name|zzCurrentPos
expr_stmt|;
name|zzMarkedPosL
operator|=
name|zzMarkedPos
expr_stmt|;
name|zzBufferL
operator|=
name|zzBuffer
expr_stmt|;
name|zzEndReadL
operator|=
name|zzEndRead
expr_stmt|;
if|if
condition|(
name|eof
condition|)
block|{
name|zzInput
operator|=
name|YYEOF
expr_stmt|;
break|break
name|zzForAction
break|;
block|}
else|else
block|{
name|zzInput
operator|=
name|zzBufferL
index|[
name|zzCurrentPosL
operator|++
index|]
expr_stmt|;
block|}
block|}
name|int
name|zzNext
init|=
name|zzTransL
index|[
name|zzRowMapL
index|[
name|zzState
index|]
operator|+
name|zzCMapL
index|[
name|zzInput
index|]
index|]
decl_stmt|;
if|if
condition|(
name|zzNext
operator|==
operator|-
literal|1
condition|)
break|break
name|zzForAction
break|;
name|zzState
operator|=
name|zzNext
expr_stmt|;
name|int
name|zzAttributes
init|=
name|zzAttrL
index|[
name|zzState
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|zzAttributes
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
block|{
name|zzAction
operator|=
name|zzState
expr_stmt|;
name|zzMarkedPosL
operator|=
name|zzCurrentPosL
expr_stmt|;
if|if
condition|(
operator|(
name|zzAttributes
operator|&
literal|8
operator|)
operator|==
literal|8
condition|)
break|break
name|zzForAction
break|;
block|}
block|}
block|}
comment|// store back cached position
name|zzMarkedPos
operator|=
name|zzMarkedPosL
expr_stmt|;
switch|switch
condition|(
name|zzAction
operator|<
literal|0
condition|?
name|zzAction
else|:
name|ZZ_ACTION
index|[
name|zzAction
index|]
condition|)
block|{
case|case
literal|4
case|:
block|{
name|addNullToken
argument_list|()
expr_stmt|;
return|return
name|firstToken
return|;
block|}
case|case
literal|27
case|:
break|break;
case|case
literal|20
case|:
block|{
name|addToken
argument_list|(
name|Token
operator|.
name|LITERAL_CHAR
argument_list|)
expr_stmt|;
block|}
case|case
literal|28
case|:
break|break;
case|case
literal|16
case|:
block|{
name|start
operator|=
name|zzMarkedPos
operator|-
literal|2
expr_stmt|;
name|yybegin
argument_list|(
name|MLC
argument_list|)
expr_stmt|;
block|}
case|case
literal|29
case|:
break|break;
case|case
literal|6
case|:
block|{
name|addToken
argument_list|(
name|Token
operator|.
name|WHITESPACE
argument_list|)
expr_stmt|;
block|}
case|case
literal|30
case|:
break|break;
case|case
literal|19
case|:
block|{
name|addToken
argument_list|(
name|Token
operator|.
name|LITERAL_NUMBER_HEXADECIMAL
argument_list|)
expr_stmt|;
block|}
case|case
literal|31
case|:
break|break;
case|case
literal|21
case|:
block|{
name|addToken
argument_list|(
name|Token
operator|.
name|ERROR_STRING_DOUBLE
argument_list|)
expr_stmt|;
block|}
case|case
literal|32
case|:
break|break;
case|case
literal|17
case|:
block|{
name|addToken
argument_list|(
name|Token
operator|.
name|LITERAL_NUMBER_FLOAT
argument_list|)
expr_stmt|;
block|}
case|case
literal|33
case|:
break|break;
case|case
literal|22
case|:
block|{
name|addToken
argument_list|(
name|Token
operator|.
name|RESERVED_WORD
argument_list|)
expr_stmt|;
block|}
case|case
literal|34
case|:
break|break;
case|case
literal|8
case|:
block|{
name|addToken
argument_list|(
name|Token
operator|.
name|SEPARATOR
argument_list|)
expr_stmt|;
block|}
case|case
literal|35
case|:
break|break;
case|case
literal|1
case|:
block|{
name|addToken
argument_list|(
name|Token
operator|.
name|IDENTIFIER
argument_list|)
expr_stmt|;
block|}
case|case
literal|36
case|:
break|break;
case|case
literal|11
case|:
block|{
name|addToken
argument_list|(
name|start
argument_list|,
name|zzStartRead
operator|-
literal|1
argument_list|,
name|Token
operator|.
name|COMMENT_EOL
argument_list|)
expr_stmt|;
name|addNullToken
argument_list|()
expr_stmt|;
return|return
name|firstToken
return|;
block|}
case|case
literal|37
case|:
break|break;
case|case
literal|15
case|:
block|{
name|start
operator|=
name|zzMarkedPos
operator|-
literal|2
expr_stmt|;
name|yybegin
argument_list|(
name|EOL_COMMENT
argument_list|)
expr_stmt|;
block|}
case|case
literal|38
case|:
break|break;
case|case
literal|26
case|:
block|{
name|addToken
argument_list|(
name|Token
operator|.
name|FUNCTION
argument_list|)
expr_stmt|;
block|}
case|case
literal|39
case|:
break|break;
case|case
literal|3
case|:
block|{
name|addToken
argument_list|(
name|Token
operator|.
name|ERROR_CHAR
argument_list|)
expr_stmt|;
name|addNullToken
argument_list|()
expr_stmt|;
return|return
name|firstToken
return|;
block|}
case|case
literal|40
case|:
break|break;
case|case
literal|5
case|:
block|{
name|addToken
argument_list|(
name|Token
operator|.
name|ERROR_STRING_DOUBLE
argument_list|)
expr_stmt|;
name|addNullToken
argument_list|()
expr_stmt|;
return|return
name|firstToken
return|;
block|}
case|case
literal|41
case|:
break|break;
case|case
literal|18
case|:
block|{
name|yybegin
argument_list|(
name|YYINITIAL
argument_list|)
expr_stmt|;
name|addToken
argument_list|(
name|start
argument_list|,
name|zzStartRead
operator|+
literal|2
operator|-
literal|1
argument_list|,
name|Token
operator|.
name|COMMENT_MULTILINE
argument_list|)
expr_stmt|;
block|}
case|case
literal|42
case|:
break|break;
case|case
literal|13
case|:
block|{
name|addToken
argument_list|(
name|Token
operator|.
name|ERROR_CHAR
argument_list|)
expr_stmt|;
block|}
case|case
literal|43
case|:
break|break;
case|case
literal|23
case|:
block|{
name|addToken
argument_list|(
name|Token
operator|.
name|LITERAL_BOOLEAN
argument_list|)
expr_stmt|;
block|}
case|case
literal|44
case|:
break|break;
case|case
literal|14
case|:
block|{
name|addToken
argument_list|(
name|Token
operator|.
name|LITERAL_STRING_DOUBLE_QUOTE
argument_list|)
expr_stmt|;
block|}
case|case
literal|45
case|:
break|break;
case|case
literal|25
case|:
block|{
name|int
name|temp
init|=
name|zzStartRead
decl_stmt|;
name|addToken
argument_list|(
name|start
argument_list|,
name|zzStartRead
operator|-
literal|1
argument_list|,
name|Token
operator|.
name|COMMENT_EOL
argument_list|)
expr_stmt|;
name|addHyperlinkToken
argument_list|(
name|temp
argument_list|,
name|zzMarkedPos
operator|-
literal|1
argument_list|,
name|Token
operator|.
name|COMMENT_EOL
argument_list|)
expr_stmt|;
name|start
operator|=
name|zzMarkedPos
expr_stmt|;
block|}
case|case
literal|46
case|:
break|break;
case|case
literal|24
case|:
block|{
name|int
name|temp
init|=
name|zzStartRead
decl_stmt|;
name|addToken
argument_list|(
name|start
argument_list|,
name|zzStartRead
operator|-
literal|1
argument_list|,
name|Token
operator|.
name|COMMENT_MULTILINE
argument_list|)
expr_stmt|;
name|addHyperlinkToken
argument_list|(
name|temp
argument_list|,
name|zzMarkedPos
operator|-
literal|1
argument_list|,
name|Token
operator|.
name|COMMENT_MULTILINE
argument_list|)
expr_stmt|;
name|start
operator|=
name|zzMarkedPos
expr_stmt|;
block|}
case|case
literal|47
case|:
break|break;
case|case
literal|12
case|:
block|{
name|addToken
argument_list|(
name|Token
operator|.
name|ERROR_NUMBER_FORMAT
argument_list|)
expr_stmt|;
block|}
case|case
literal|48
case|:
break|break;
case|case
literal|2
case|:
block|{
name|addToken
argument_list|(
name|Token
operator|.
name|LITERAL_NUMBER_DECIMAL_INT
argument_list|)
expr_stmt|;
block|}
case|case
literal|49
case|:
break|break;
case|case
literal|7
case|:
block|{
name|addToken
argument_list|(
name|Token
operator|.
name|OPERATOR
argument_list|)
expr_stmt|;
block|}
case|case
literal|50
case|:
break|break;
case|case
literal|9
case|:
block|{
block|}
case|case
literal|51
case|:
break|break;
case|case
literal|10
case|:
block|{
name|addToken
argument_list|(
name|start
argument_list|,
name|zzStartRead
operator|-
literal|1
argument_list|,
name|Token
operator|.
name|COMMENT_MULTILINE
argument_list|)
expr_stmt|;
return|return
name|firstToken
return|;
block|}
case|case
literal|52
case|:
break|break;
default|default:
if|if
condition|(
name|zzInput
operator|==
name|YYEOF
operator|&&
name|zzStartRead
operator|==
name|zzCurrentPos
condition|)
block|{
name|zzAtEOF
operator|=
literal|true
expr_stmt|;
switch|switch
condition|(
name|zzLexicalState
condition|)
block|{
case|case
name|EOL_COMMENT
case|:
block|{
name|addToken
argument_list|(
name|start
argument_list|,
name|zzStartRead
operator|-
literal|1
argument_list|,
name|Token
operator|.
name|COMMENT_EOL
argument_list|)
expr_stmt|;
name|addNullToken
argument_list|()
expr_stmt|;
return|return
name|firstToken
return|;
block|}
case|case
literal|225
case|:
break|break;
case|case
name|YYINITIAL
case|:
block|{
name|addNullToken
argument_list|()
expr_stmt|;
return|return
name|firstToken
return|;
block|}
case|case
literal|226
case|:
break|break;
case|case
name|MLC
case|:
block|{
name|addToken
argument_list|(
name|start
argument_list|,
name|zzStartRead
operator|-
literal|1
argument_list|,
name|Token
operator|.
name|COMMENT_MULTILINE
argument_list|)
expr_stmt|;
return|return
name|firstToken
return|;
block|}
case|case
literal|227
case|:
break|break;
default|default:
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
name|zzScanError
argument_list|(
name|ZZ_NO_MATCH
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

