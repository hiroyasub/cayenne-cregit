begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************  *   Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing,  *  software distributed under the License is distributed on an  *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *  KIND, either express or implied.  See the License for the  *  specific language governing permissions and limitations  *  under the License.  ****************************************************************/
end_comment

begin_comment
comment|/*  * Copyright 2010 Google Inc. All Rights Reserved.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|util
operator|.
name|concurrentlinkedhashmap
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InvalidObjectException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|WeakReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|AbstractExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CancellationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentLinkedQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RejectedExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicIntegerArray
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_comment
comment|/**  * A hash table supporting full concurrency of retrievals, adjustable expected concurrency  * for updates, and a maximum capacity to bound the map by. This implementation differs  * from {@link ConcurrentHashMap} in that it maintains a page replacement algorithm that  * is used to evict an entry when the map has exceeded its capacity. Unlike the  *<tt>Java Collections Framework</tt>, this map does not have a publicly visible  * constructor and instances are created through a {@link Builder}.  *<p>  * An entry is evicted from the map when the<tt>weighted capacity</tt> exceeds its  *<tt>maximum weighted capacity</tt> threshold. A {@link Weigher} instance determines how  * many units of capacity that a value consumes. The default weigher assigns each value a  * weight of<tt>1</tt> to bound the map by the total number of key-value pairs. A map  * that holds collections may choose to weigh values by the number of elements in the  * collection and bound the map by the total number of elements that it contains. A change  * to a value that modifies its weight requires that an update operation is performed on  * the map.  *<p>  * An {@link EvictionListener} may be supplied for notification when an entry is evicted  * from the map. This listener is invoked on a caller's thread and will not block other  * threads from operating on the map. An implementation should be aware that the caller's  * thread will not expect long execution times or failures as a side effect of the  * listener being notified. Execution safety and a fast turn around time can be achieved  * by performing the operation asynchronously, such as by submitting a task to an  * {@link java.util.concurrent.ExecutorService}.  *<p>  * The<tt>concurrency level</tt> determines the number of threads that can concurrently  * modify the table. Using a significantly higher or lower value than needed can waste  * space or lead to thread contention, but an estimate within an order of magnitude of the  * ideal value does not usually have a noticeable impact. Because placement in hash tables  * is essentially random, the actual concurrency will vary.  *<p>  * This class and its views and iterators implement all of the<em>optional</em> methods  * of the {@link Map} and {@link Iterator} interfaces.  *<p>  * Like {@link java.util.Hashtable} but unlike {@link HashMap}, this class does  *<em>not</em> allow<tt>null</tt> to be used as a key or value. Unlike  * {@link java.util.LinkedHashMap}, this class does<em>not</em> provide predictable  * iteration order. A snapshot of the keys and entries may be obtained in ascending and  * descending order of retention.  *   * @param<K> the type of keys maintained by this map  * @param<V> the type of mapped values  */
end_comment

begin_comment
comment|// based on http://concurrentlinkedhashmap.googlecode.com/svn/trunk r754
end_comment

begin_class
specifier|public
class|class
name|ConcurrentLinkedHashMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|Serializable
block|{
comment|/*      * This class performs a best-effort bounding of a ConcurrentHashMap using a      * page-replacement algorithm to determine which entries to evict when the capacity is      * exceeded. The page replacement algorithm's data structures are kept eventually      * consistent with the map. An update to the map and recording of reads may not be      * immediately reflected on the algorithm's data structures. These structures are      * guarded by a lock and operations are applied in batches to avoid lock contention.      * The penalty of applying the batches is spread across threads so that the amortized      * cost is slightly higher than performing just the ConcurrentHashMap operation. A      * memento of the reads and writes that were performed on the map are recorded in a      * buffer. These buffers are drained at the first opportunity after a write or when a      * buffer exceeds a threshold size. A mostly strict ordering is achieved by observing      * that each buffer is in a weakly sorted order relative to the last drain. This      * allows the buffers to be merged in O(n) time so that the operations are run in the      * expected order. Due to a lack of a strict ordering guarantee, a task can be      * executed out-of-order, such as a removal followed by its addition. The state of the      * entry is encoded within the value's weight. Alive: The entry is in both the      * hash-table and the page replacement policy. This is represented by a positive      * weight. Retired: The entry is not in the hash-table and is pending removal from the      * page replacement policy. This is represented by a negative weight. Dead: The entry      * is not in the hash-table and is not in the page replacement policy. This is      * represented by a weight of zero. The Least Recently Used page replacement algorithm      * was chosen due to its simplicity, high hit rate, and ability to be implemented with      * O(1) time complexity.      */
comment|/** The maximum weighted capacity of the map. */
specifier|static
specifier|final
name|int
name|MAXIMUM_CAPACITY
init|=
literal|1
operator|<<
literal|30
decl_stmt|;
comment|/** The maximum weight of a value. */
specifier|static
specifier|final
name|int
name|MAXIMUM_WEIGHT
init|=
literal|1
operator|<<
literal|29
decl_stmt|;
comment|/** The maximum number of pending operations per buffer. */
specifier|static
specifier|final
name|int
name|MAXIMUM_BUFFER_SIZE
init|=
literal|1
operator|<<
literal|20
decl_stmt|;
comment|/** The number of pending operations per buffer before attempting to drain. */
specifier|static
specifier|final
name|int
name|BUFFER_THRESHOLD
init|=
literal|16
decl_stmt|;
comment|/** The number of buffers to use. */
specifier|static
specifier|final
name|int
name|NUMBER_OF_BUFFERS
decl_stmt|;
comment|/** Mask value for indexing into the buffers. */
specifier|static
specifier|final
name|int
name|BUFFER_MASK
decl_stmt|;
comment|/** The maximum number of operations to perform per amortized drain. */
specifier|static
specifier|final
name|int
name|AMORTIZED_DRAIN_THRESHOLD
decl_stmt|;
comment|/** A queue that discards all entries. */
specifier|static
specifier|final
name|Queue
argument_list|<
name|?
argument_list|>
name|DISCARDING_QUEUE
init|=
operator|new
name|DiscardingQueue
argument_list|()
decl_stmt|;
static|static
block|{
name|int
name|buffers
init|=
name|ceilingNextPowerOfTwo
argument_list|(
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
argument_list|)
decl_stmt|;
name|AMORTIZED_DRAIN_THRESHOLD
operator|=
operator|(
literal|1
operator|+
name|buffers
operator|)
operator|*
name|BUFFER_THRESHOLD
expr_stmt|;
name|NUMBER_OF_BUFFERS
operator|=
name|buffers
expr_stmt|;
name|BUFFER_MASK
operator|=
name|buffers
operator|-
literal|1
expr_stmt|;
block|}
specifier|static
name|int
name|ceilingNextPowerOfTwo
parameter_list|(
name|int
name|x
parameter_list|)
block|{
comment|// From Hacker's Delight, Chapter 3, Harry S. Warren Jr.
return|return
literal|1
operator|<<
operator|(
name|Integer
operator|.
name|SIZE
operator|-
name|Integer
operator|.
name|numberOfLeadingZeros
argument_list|(
name|x
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
comment|/** The draining status of the buffers. */
enum|enum
name|DrainStatus
block|{
comment|/** A drain is not taking place. */
name|IDLE
block|,
comment|/** A drain is required due to a pending write modification. */
name|REQUIRED
block|,
comment|/** A drain is in progress. */
name|PROCESSING
block|}
comment|// The backing data store holding the key-value associations
specifier|final
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|Node
argument_list|>
name|data
decl_stmt|;
specifier|final
name|int
name|concurrencyLevel
decl_stmt|;
comment|// These fields provide support to bound the map by a maximum capacity
specifier|final
name|LinkedDeque
argument_list|<
name|Node
argument_list|>
name|evictionDeque
decl_stmt|;
comment|// must write under lock
specifier|volatile
name|int
name|weightedSize
decl_stmt|;
comment|// must write under lock
specifier|volatile
name|int
name|capacity
decl_stmt|;
specifier|volatile
name|int
name|nextOrder
decl_stmt|;
name|int
name|drainedOrder
decl_stmt|;
specifier|final
name|Lock
name|evictionLock
decl_stmt|;
specifier|final
name|Queue
argument_list|<
name|Task
argument_list|>
index|[]
name|buffers
decl_stmt|;
specifier|final
name|ExecutorService
name|executor
decl_stmt|;
specifier|final
name|Weigher
argument_list|<
name|?
super|super
name|V
argument_list|>
name|weigher
decl_stmt|;
specifier|final
name|AtomicIntegerArray
name|bufferLengths
decl_stmt|;
specifier|final
name|AtomicReference
argument_list|<
name|DrainStatus
argument_list|>
name|drainStatus
decl_stmt|;
comment|// These fields provide support for notifying a listener.
specifier|final
name|Queue
argument_list|<
name|Node
argument_list|>
name|pendingNotifications
decl_stmt|;
specifier|final
name|EvictionListener
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|listener
decl_stmt|;
specifier|transient
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
decl_stmt|;
specifier|transient
name|Collection
argument_list|<
name|V
argument_list|>
name|values
decl_stmt|;
specifier|transient
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
comment|/**      * Creates an instance based on the builder's configuration.      */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|,
literal|"cast"
block|}
argument_list|)
specifier|private
name|ConcurrentLinkedHashMap
parameter_list|(
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|builder
parameter_list|)
block|{
comment|// The data store and its maximum capacity
name|concurrencyLevel
operator|=
name|builder
operator|.
name|concurrencyLevel
expr_stmt|;
name|capacity
operator|=
name|Math
operator|.
name|min
argument_list|(
name|builder
operator|.
name|capacity
argument_list|,
name|MAXIMUM_CAPACITY
argument_list|)
expr_stmt|;
name|data
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|(
name|builder
operator|.
name|initialCapacity
argument_list|,
literal|0.75f
argument_list|,
name|concurrencyLevel
argument_list|)
expr_stmt|;
comment|// The eviction support
name|weigher
operator|=
name|builder
operator|.
name|weigher
expr_stmt|;
name|executor
operator|=
name|builder
operator|.
name|executor
expr_stmt|;
name|nextOrder
operator|=
name|Integer
operator|.
name|MIN_VALUE
expr_stmt|;
name|drainedOrder
operator|=
name|Integer
operator|.
name|MIN_VALUE
expr_stmt|;
name|evictionLock
operator|=
operator|new
name|ReentrantLock
argument_list|()
expr_stmt|;
name|evictionDeque
operator|=
operator|new
name|LinkedDeque
argument_list|<>
argument_list|()
expr_stmt|;
name|drainStatus
operator|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|(
name|DrainStatus
operator|.
name|IDLE
argument_list|)
expr_stmt|;
name|buffers
operator|=
operator|(
name|Queue
argument_list|<
name|Task
argument_list|>
index|[]
operator|)
operator|new
name|Queue
index|[
name|NUMBER_OF_BUFFERS
index|]
expr_stmt|;
name|bufferLengths
operator|=
operator|new
name|AtomicIntegerArray
argument_list|(
name|NUMBER_OF_BUFFERS
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUMBER_OF_BUFFERS
condition|;
name|i
operator|++
control|)
block|{
name|buffers
index|[
name|i
index|]
operator|=
operator|new
name|ConcurrentLinkedQueue
argument_list|<>
argument_list|()
expr_stmt|;
block|}
comment|// The notification queue and listener
name|listener
operator|=
name|builder
operator|.
name|listener
expr_stmt|;
name|pendingNotifications
operator|=
operator|(
name|listener
operator|==
name|DiscardingListener
operator|.
name|INSTANCE
operator|)
condition|?
operator|(
name|Queue
argument_list|<
name|Node
argument_list|>
operator|)
name|DISCARDING_QUEUE
else|:
operator|new
name|ConcurrentLinkedQueue
argument_list|<
name|Node
argument_list|>
argument_list|()
expr_stmt|;
block|}
comment|/** Asserts that the object is not null. */
specifier|static
name|void
name|checkNotNull
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
block|}
comment|/* ---------------- Eviction Support -------------- */
comment|/**      * Retrieves the maximum weighted capacity of the map.      *       * @return the maximum weighted capacity      */
specifier|public
name|int
name|capacity
parameter_list|()
block|{
return|return
name|capacity
return|;
block|}
comment|/**      * Sets the maximum weighted capacity of the map and eagerly evicts entries until it      * shrinks to the appropriate size.      *       * @param capacity the maximum weighted capacity of the map      * @throws IllegalArgumentException if the capacity is negative      */
specifier|public
name|void
name|setCapacity
parameter_list|(
name|int
name|capacity
parameter_list|)
block|{
if|if
condition|(
name|capacity
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
name|evictionLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|capacity
operator|=
name|Math
operator|.
name|min
argument_list|(
name|capacity
argument_list|,
name|MAXIMUM_CAPACITY
argument_list|)
expr_stmt|;
name|drainBuffers
argument_list|(
name|AMORTIZED_DRAIN_THRESHOLD
argument_list|)
expr_stmt|;
name|evict
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|evictionLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|notifyListener
argument_list|()
expr_stmt|;
block|}
comment|/** Determines whether the map has exceeded its capacity. */
name|boolean
name|hasOverflowed
parameter_list|()
block|{
return|return
name|weightedSize
operator|>
name|capacity
return|;
block|}
comment|/**      * Evicts entries from the map while it exceeds the capacity and appends evicted      * entries to the notification queue for processing.      */
name|void
name|evict
parameter_list|()
block|{
comment|// Attempts to evict entries from the map if it exceeds the maximum
comment|// capacity. If the eviction fails due to a concurrent removal of the
comment|// victim, that removal may cancel out the addition that triggered this
comment|// eviction. The victim is eagerly unlinked before the removal task so
comment|// that if an eviction is still required then a new victim will be chosen
comment|// for removal.
while|while
condition|(
name|hasOverflowed
argument_list|()
condition|)
block|{
name|Node
name|node
init|=
name|evictionDeque
operator|.
name|poll
argument_list|()
decl_stmt|;
comment|// If weighted values are used, then the pending operations will adjust
comment|// the size to reflect the correct weight
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// Notify the listener only if the entry was evicted
if|if
condition|(
name|data
operator|.
name|remove
argument_list|(
name|node
operator|.
name|key
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|pendingNotifications
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|makeDead
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Performs the post-processing work required after the map operation.      *       * @param task the pending operation to be applied      */
name|void
name|afterCompletion
parameter_list|(
name|Task
name|task
parameter_list|)
block|{
name|boolean
name|delayable
init|=
name|schedule
argument_list|(
name|task
argument_list|)
decl_stmt|;
if|if
condition|(
name|shouldDrainBuffers
argument_list|(
name|delayable
argument_list|)
condition|)
block|{
name|tryToDrainBuffers
argument_list|(
name|AMORTIZED_DRAIN_THRESHOLD
argument_list|)
expr_stmt|;
block|}
name|notifyListener
argument_list|()
expr_stmt|;
block|}
comment|/**      * Schedules the task to be applied to the page replacement policy.      *       * @param task the pending operation      * @return if the draining of the buffers can be delayed      */
specifier|private
name|boolean
name|schedule
parameter_list|(
name|Task
name|task
parameter_list|)
block|{
name|int
name|index
init|=
name|bufferIndex
argument_list|()
decl_stmt|;
name|int
name|buffered
init|=
name|bufferLengths
operator|.
name|incrementAndGet
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|task
operator|.
name|isWrite
argument_list|()
condition|)
block|{
name|buffers
index|[
name|index
index|]
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|drainStatus
operator|.
name|set
argument_list|(
name|DrainStatus
operator|.
name|REQUIRED
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// A buffer may discard a read task if its length exceeds a tolerance level
if|if
condition|(
name|buffered
operator|<=
name|MAXIMUM_BUFFER_SIZE
condition|)
block|{
name|buffers
index|[
name|index
index|]
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
return|return
operator|(
name|buffered
operator|<=
name|BUFFER_THRESHOLD
operator|)
return|;
block|}
else|else
block|{
comment|// not optimized for fail-safe scenario
name|bufferLengths
operator|.
name|decrementAndGet
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|/** Returns the index to the buffer that the task should be scheduled on. */
specifier|static
name|int
name|bufferIndex
parameter_list|()
block|{
comment|// A buffer is chosen by the thread's id so that tasks are distributed in a
comment|// pseudo evenly manner. This helps avoid hot entries causing contention due
comment|// to other threads trying to append to the same buffer.
return|return
operator|(
name|int
operator|)
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getId
argument_list|()
operator|&
name|BUFFER_MASK
return|;
block|}
comment|/** Returns the ordering value to assign to a task. */
name|int
name|nextOrdering
parameter_list|()
block|{
comment|// The next ordering is acquired in a racy fashion as the increment is not
comment|// atomic with the insertion into a buffer. This means that concurrent tasks
comment|// can have the same ordering and the buffers are in a weakly sorted order.
return|return
name|nextOrder
operator|++
return|;
block|}
comment|/**      * Determines whether the buffers should be drained.      *       * @param delayable if a drain should be delayed until required      * @return if a drain should be attempted      */
name|boolean
name|shouldDrainBuffers
parameter_list|(
name|boolean
name|delayable
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|.
name|isShutdown
argument_list|()
condition|)
block|{
name|DrainStatus
name|status
init|=
name|drainStatus
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
operator|(
name|status
operator|!=
name|DrainStatus
operator|.
name|PROCESSING
operator|)
operator|&
operator|(
operator|!
name|delayable
operator||
operator|(
name|status
operator|==
name|DrainStatus
operator|.
name|REQUIRED
operator|)
operator|)
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Attempts to acquire the eviction lock and apply the pending operations to the page      * replacement policy.      *       * @param maxToDrain the maximum number of operations to drain      */
name|void
name|tryToDrainBuffers
parameter_list|(
name|int
name|maxToDrain
parameter_list|)
block|{
if|if
condition|(
name|evictionLock
operator|.
name|tryLock
argument_list|()
condition|)
block|{
try|try
block|{
name|drainStatus
operator|.
name|set
argument_list|(
name|DrainStatus
operator|.
name|PROCESSING
argument_list|)
expr_stmt|;
name|drainBuffers
argument_list|(
name|maxToDrain
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|drainStatus
operator|.
name|compareAndSet
argument_list|(
name|DrainStatus
operator|.
name|PROCESSING
argument_list|,
name|DrainStatus
operator|.
name|IDLE
argument_list|)
expr_stmt|;
name|evictionLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Drains the buffers and applies the pending operations.      *       * @param maxToDrain the maximum number of operations to drain      */
name|void
name|drainBuffers
parameter_list|(
name|int
name|maxToDrain
parameter_list|)
block|{
comment|// A mostly strict ordering is achieved by observing that each buffer
comment|// contains tasks in a weakly sorted order starting from the last drain.
comment|// The buffers can be merged into a sorted list in O(n) time by using
comment|// counting sort and chaining on a collision.
comment|// The output is capped to the expected number of tasks plus additional
comment|// slack to optimistically handle the concurrent additions to the buffers.
name|Task
index|[]
name|tasks
init|=
operator|new
name|Task
index|[
name|maxToDrain
index|]
decl_stmt|;
comment|// Moves the tasks into the output array, applies them, and updates the
comment|// marker for the starting order of the next drain.
name|int
name|maxTaskIndex
init|=
name|moveTasksFromBuffers
argument_list|(
name|tasks
argument_list|)
decl_stmt|;
name|runTasks
argument_list|(
name|tasks
argument_list|,
name|maxTaskIndex
argument_list|)
expr_stmt|;
name|updateDrainedOrder
argument_list|(
name|tasks
argument_list|,
name|maxTaskIndex
argument_list|)
expr_stmt|;
block|}
comment|/**      * Moves the tasks from the buffers into the output array.      *       * @param tasks the ordered array of the pending operations      * @return the highest index location of a task that was added to the array      */
name|int
name|moveTasksFromBuffers
parameter_list|(
name|Task
index|[]
name|tasks
parameter_list|)
block|{
name|int
name|maxTaskIndex
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|buffers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|maxIndex
init|=
name|moveTasksFromBuffer
argument_list|(
name|tasks
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|maxTaskIndex
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxIndex
argument_list|,
name|maxTaskIndex
argument_list|)
expr_stmt|;
block|}
return|return
name|maxTaskIndex
return|;
block|}
comment|/**      * Moves the tasks from the specified buffer into the output array.      *       * @param tasks the ordered array of the pending operations      * @param bufferIndex the buffer to drain into the tasks array      * @return the highest index location of a task that was added to the array      */
name|int
name|moveTasksFromBuffer
parameter_list|(
name|Task
index|[]
name|tasks
parameter_list|,
name|int
name|bufferIndex
parameter_list|)
block|{
comment|// While a buffer is being drained it may be concurrently appended to. The
comment|// number of tasks removed are tracked so that the length can be decremented
comment|// by the delta rather than set to zero.
name|Queue
argument_list|<
name|Task
argument_list|>
name|buffer
init|=
name|buffers
index|[
name|bufferIndex
index|]
decl_stmt|;
name|int
name|removedFromBuffer
init|=
literal|0
decl_stmt|;
name|Task
name|task
decl_stmt|;
name|int
name|maxIndex
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|(
name|task
operator|=
name|buffer
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|removedFromBuffer
operator|++
expr_stmt|;
comment|// The index into the output array is determined by calculating the offset
comment|// since the last drain
name|int
name|index
init|=
name|task
operator|.
name|getOrder
argument_list|()
operator|-
name|drainedOrder
decl_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
comment|// The task was missed by the last drain and can be run immediately
name|task
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|index
operator|>=
name|tasks
operator|.
name|length
condition|)
block|{
comment|// Due to concurrent additions, the order exceeds the capacity of the
comment|// output array. It is added to the end as overflow and the remaining
comment|// tasks in the buffer will be handled by the next drain.
name|maxIndex
operator|=
name|tasks
operator|.
name|length
operator|-
literal|1
expr_stmt|;
name|addTaskToChain
argument_list|(
name|tasks
argument_list|,
name|task
argument_list|,
name|maxIndex
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|maxIndex
operator|=
name|Math
operator|.
name|max
argument_list|(
name|index
argument_list|,
name|maxIndex
argument_list|)
expr_stmt|;
name|addTaskToChain
argument_list|(
name|tasks
argument_list|,
name|task
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
name|bufferLengths
operator|.
name|addAndGet
argument_list|(
name|bufferIndex
argument_list|,
operator|-
name|removedFromBuffer
argument_list|)
expr_stmt|;
return|return
name|maxIndex
return|;
block|}
comment|/**      * Adds the task as the head of the chain at the index location.      *       * @param tasks the ordered array of the pending operations      * @param task the pending operation to add      * @param index the array location      */
name|void
name|addTaskToChain
parameter_list|(
name|Task
index|[]
name|tasks
parameter_list|,
name|Task
name|task
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|task
operator|.
name|setNext
argument_list|(
name|tasks
index|[
name|index
index|]
argument_list|)
expr_stmt|;
name|tasks
index|[
name|index
index|]
operator|=
name|task
expr_stmt|;
block|}
comment|/**      * Runs the pending page replacement policy operations.      *       * @param tasks the ordered array of the pending operations      * @param maxTaskIndex the maximum index of the array      */
name|void
name|runTasks
parameter_list|(
name|Task
index|[]
name|tasks
parameter_list|,
name|int
name|maxTaskIndex
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|maxTaskIndex
condition|;
name|i
operator|++
control|)
block|{
name|runTasksInChain
argument_list|(
name|tasks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Runs the pending operations on the linked chain.      *       * @param task the first task in the chain of operations      */
name|void
name|runTasksInChain
parameter_list|(
name|Task
name|task
parameter_list|)
block|{
while|while
condition|(
name|task
operator|!=
literal|null
condition|)
block|{
name|Task
name|current
init|=
name|task
decl_stmt|;
name|task
operator|=
name|task
operator|.
name|getNext
argument_list|()
expr_stmt|;
name|current
operator|.
name|setNext
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|current
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Updates the order to start the next drain from.      *       * @param tasks the ordered array of operations      * @param maxTaskIndex the maximum index of the array      */
name|void
name|updateDrainedOrder
parameter_list|(
name|Task
index|[]
name|tasks
parameter_list|,
name|int
name|maxTaskIndex
parameter_list|)
block|{
if|if
condition|(
name|maxTaskIndex
operator|>=
literal|0
condition|)
block|{
name|Task
name|task
init|=
name|tasks
index|[
name|maxTaskIndex
index|]
decl_stmt|;
name|drainedOrder
operator|=
name|task
operator|.
name|getOrder
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/** Notifies the listener of entries that were evicted. */
name|void
name|notifyListener
parameter_list|()
block|{
name|Node
name|node
decl_stmt|;
while|while
condition|(
operator|(
name|node
operator|=
name|pendingNotifications
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|listener
operator|.
name|onEviction
argument_list|(
name|node
operator|.
name|key
argument_list|,
name|node
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Updates the node's location in the page replacement policy. */
class|class
name|ReadTask
extends|extends
name|AbstractTask
block|{
specifier|final
name|Node
name|node
decl_stmt|;
name|ReadTask
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
block|}
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// An entry may scheduled for reordering despite having been previously
comment|// removed. This can occur when the entry was concurrently read while a
comment|// writer was removing it. If the entry is no longer linked then it does
comment|// not need to be processed.
if|if
condition|(
name|evictionDeque
operator|.
name|contains
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|evictionDeque
operator|.
name|moveToBack
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|isWrite
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/** Adds the node to the page replacement policy. */
specifier|final
class|class
name|AddTask
extends|extends
name|AbstractTask
block|{
specifier|final
name|Node
name|node
decl_stmt|;
specifier|final
name|int
name|weight
decl_stmt|;
name|AddTask
parameter_list|(
name|Node
name|node
parameter_list|,
name|int
name|weight
parameter_list|)
block|{
name|this
operator|.
name|weight
operator|=
name|weight
expr_stmt|;
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
block|}
specifier|public
name|void
name|run
parameter_list|()
block|{
name|weightedSize
operator|+=
name|weight
expr_stmt|;
comment|// ignore out-of-order write operations
if|if
condition|(
name|node
operator|.
name|get
argument_list|()
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|evictionDeque
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|evict
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|isWrite
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/** Removes a node from the page replacement policy. */
specifier|final
class|class
name|RemovalTask
extends|extends
name|AbstractTask
block|{
specifier|final
name|Node
name|node
decl_stmt|;
name|RemovalTask
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
block|}
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// add may not have been processed yet
name|evictionDeque
operator|.
name|remove
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|.
name|makeDead
argument_list|()
expr_stmt|;
block|}
specifier|public
name|boolean
name|isWrite
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/** Updates the weighted size and evicts an entry on overflow. */
specifier|final
class|class
name|UpdateTask
extends|extends
name|ReadTask
block|{
specifier|final
name|int
name|weightDifference
decl_stmt|;
specifier|public
name|UpdateTask
parameter_list|(
name|Node
name|node
parameter_list|,
name|int
name|weightDifference
parameter_list|)
block|{
name|super
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|this
operator|.
name|weightDifference
operator|=
name|weightDifference
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|super
operator|.
name|run
argument_list|()
expr_stmt|;
name|weightedSize
operator|+=
name|weightDifference
expr_stmt|;
name|evict
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isWrite
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/* ---------------- Concurrent Map Support -------------- */
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|data
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|data
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Returns the weighted size of this map.      *       * @return the combined weight of the values in this map      */
specifier|public
name|int
name|weightedSize
parameter_list|()
block|{
return|return
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|weightedSize
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
comment|// The alternative is to iterate through the keys and call #remove(), which
comment|// adds unnecessary contention on the eviction lock and buffers.
name|evictionLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|Node
name|node
decl_stmt|;
while|while
condition|(
operator|(
name|node
operator|=
name|evictionDeque
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|data
operator|.
name|remove
argument_list|(
name|node
operator|.
name|key
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|node
operator|.
name|makeDead
argument_list|()
expr_stmt|;
block|}
comment|// Drain the buffers and run only the write tasks
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|buffers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Queue
argument_list|<
name|Task
argument_list|>
name|buffer
init|=
name|buffers
index|[
name|i
index|]
decl_stmt|;
name|int
name|removed
init|=
literal|0
decl_stmt|;
name|Task
name|task
decl_stmt|;
while|while
condition|(
operator|(
name|task
operator|=
name|buffer
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|task
operator|.
name|isWrite
argument_list|()
condition|)
block|{
name|task
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
name|removed
operator|++
expr_stmt|;
block|}
name|bufferLengths
operator|.
name|addAndGet
argument_list|(
name|i
argument_list|,
operator|-
name|removed
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|evictionLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|data
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|containsValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|Node
name|node
range|:
name|data
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|node
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
name|value
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
specifier|final
name|Node
name|node
init|=
name|data
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|afterCompletion
argument_list|(
operator|new
name|ReadTask
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|node
operator|.
name|getValue
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
name|V
name|putIfAbsent
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Adds a node to the list and the data store. If an existing node is found, then its      * value is updated if allowed.      *       * @param key key with which the specified value is to be associated      * @param value value to be associated with the specified key      * @param onlyIfAbsent a write is performed only if the key is not already associated      *            with a value      * @return the prior value in the data store or null if no mapping was found      */
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|,
name|boolean
name|onlyIfAbsent
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|value
argument_list|)
expr_stmt|;
specifier|final
name|int
name|weight
init|=
name|weigher
operator|.
name|weightOf
argument_list|(
name|value
argument_list|)
decl_stmt|;
specifier|final
name|WeightedValue
argument_list|<
name|V
argument_list|>
name|weightedValue
init|=
operator|new
name|WeightedValue
argument_list|<>
argument_list|(
name|value
argument_list|,
name|weight
argument_list|)
decl_stmt|;
specifier|final
name|Node
name|node
init|=
operator|new
name|Node
argument_list|(
name|key
argument_list|,
name|weightedValue
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|final
name|Node
name|prior
init|=
name|data
operator|.
name|putIfAbsent
argument_list|(
name|node
operator|.
name|key
argument_list|,
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|prior
operator|==
literal|null
condition|)
block|{
name|afterCompletion
argument_list|(
operator|new
name|AddTask
argument_list|(
name|node
argument_list|,
name|weight
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|else if
condition|(
name|onlyIfAbsent
condition|)
block|{
name|afterCompletion
argument_list|(
operator|new
name|ReadTask
argument_list|(
name|prior
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|prior
operator|.
name|getValue
argument_list|()
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|final
name|WeightedValue
argument_list|<
name|V
argument_list|>
name|oldWeightedValue
init|=
name|prior
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|oldWeightedValue
operator|.
name|isAlive
argument_list|()
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|prior
operator|.
name|compareAndSet
argument_list|(
name|oldWeightedValue
argument_list|,
name|weightedValue
argument_list|)
condition|)
block|{
specifier|final
name|int
name|weightedDifference
init|=
name|weight
operator|-
name|oldWeightedValue
operator|.
name|weight
decl_stmt|;
specifier|final
name|Task
name|task
init|=
operator|(
name|weightedDifference
operator|==
literal|0
operator|)
condition|?
operator|new
name|ReadTask
argument_list|(
name|prior
argument_list|)
else|:
operator|new
name|UpdateTask
argument_list|(
name|prior
argument_list|,
name|weightedDifference
argument_list|)
decl_stmt|;
name|afterCompletion
argument_list|(
name|task
argument_list|)
expr_stmt|;
return|return
name|oldWeightedValue
operator|.
name|value
return|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|V
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
specifier|final
name|Node
name|node
init|=
name|data
operator|.
name|remove
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|node
operator|.
name|makeRetired
argument_list|()
expr_stmt|;
name|afterCompletion
argument_list|(
operator|new
name|RemovalTask
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|node
operator|.
name|getValue
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|Node
name|node
init|=
name|data
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|node
operator|==
literal|null
operator|)
operator|||
operator|(
name|value
operator|==
literal|null
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|WeightedValue
argument_list|<
name|V
argument_list|>
name|weightedValue
init|=
name|node
operator|.
name|get
argument_list|()
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|weightedValue
operator|.
name|hasValue
argument_list|(
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|tryToRetire
argument_list|(
name|weightedValue
argument_list|)
condition|)
block|{
if|if
condition|(
name|data
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|afterCompletion
argument_list|(
operator|new
name|RemovalTask
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
else|else
block|{
name|weightedValue
operator|=
name|node
operator|.
name|get
argument_list|()
expr_stmt|;
if|if
condition|(
name|weightedValue
operator|.
name|isAlive
argument_list|()
condition|)
block|{
comment|// retry as an intermediate update may have replaced the value
comment|// with
comment|// an equal instance that has a different reference identity
continue|continue;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
specifier|public
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|value
argument_list|)
expr_stmt|;
specifier|final
name|int
name|weight
init|=
name|weigher
operator|.
name|weightOf
argument_list|(
name|value
argument_list|)
decl_stmt|;
specifier|final
name|WeightedValue
argument_list|<
name|V
argument_list|>
name|weightedValue
init|=
operator|new
name|WeightedValue
argument_list|<>
argument_list|(
name|value
argument_list|,
name|weight
argument_list|)
decl_stmt|;
specifier|final
name|Node
name|node
init|=
name|data
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|WeightedValue
argument_list|<
name|V
argument_list|>
name|oldWeightedValue
init|=
name|node
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|oldWeightedValue
operator|.
name|isAlive
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|node
operator|.
name|compareAndSet
argument_list|(
name|oldWeightedValue
argument_list|,
name|weightedValue
argument_list|)
condition|)
block|{
name|int
name|weightedDifference
init|=
name|weight
operator|-
name|oldWeightedValue
operator|.
name|weight
decl_stmt|;
specifier|final
name|Task
name|task
init|=
operator|(
name|weightedDifference
operator|==
literal|0
operator|)
condition|?
operator|new
name|ReadTask
argument_list|(
name|node
argument_list|)
else|:
operator|new
name|UpdateTask
argument_list|(
name|node
argument_list|,
name|weightedDifference
argument_list|)
decl_stmt|;
name|afterCompletion
argument_list|(
name|task
argument_list|)
expr_stmt|;
return|return
name|oldWeightedValue
operator|.
name|value
return|;
block|}
block|}
block|}
specifier|public
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|oldValue
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
specifier|final
name|int
name|weight
init|=
name|weigher
operator|.
name|weightOf
argument_list|(
name|newValue
argument_list|)
decl_stmt|;
specifier|final
name|WeightedValue
argument_list|<
name|V
argument_list|>
name|newWeightedValue
init|=
operator|new
name|WeightedValue
argument_list|<>
argument_list|(
name|newValue
argument_list|,
name|weight
argument_list|)
decl_stmt|;
specifier|final
name|Node
name|node
init|=
name|data
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|final
name|WeightedValue
argument_list|<
name|V
argument_list|>
name|weightedValue
init|=
name|node
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|weightedValue
operator|.
name|isAlive
argument_list|()
operator|||
operator|!
name|weightedValue
operator|.
name|hasValue
argument_list|(
name|oldValue
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|node
operator|.
name|compareAndSet
argument_list|(
name|weightedValue
argument_list|,
name|newWeightedValue
argument_list|)
condition|)
block|{
name|int
name|weightedDifference
init|=
name|weight
operator|-
name|weightedValue
operator|.
name|weight
decl_stmt|;
specifier|final
name|Task
name|task
init|=
operator|(
name|weightedDifference
operator|==
literal|0
operator|)
condition|?
operator|new
name|ReadTask
argument_list|(
name|node
argument_list|)
else|:
operator|new
name|UpdateTask
argument_list|(
name|node
argument_list|,
name|weightedDifference
argument_list|)
decl_stmt|;
name|afterCompletion
argument_list|(
name|task
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
name|Set
argument_list|<
name|K
argument_list|>
name|ks
init|=
name|keySet
decl_stmt|;
return|return
operator|(
name|ks
operator|==
literal|null
operator|)
condition|?
operator|(
name|keySet
operator|=
operator|new
name|KeySet
argument_list|()
operator|)
else|:
name|ks
return|;
block|}
comment|/**      * Returns a unmodifiable snapshot {@link Set} view of the keys contained in this map.      * The set's iterator returns the keys whose order of iteration is the ascending order      * in which its entries are considered eligible for retention, from the least-likely      * to be retained to the most-likely.      *<p>      * Beware that, unlike in {@link #keySet()}, obtaining the set is<em>NOT</em> a      * constant-time operation. Because of the asynchronous nature of the page replacement      * policy, determining the retention ordering requires a traversal of the keys.      *       * @return an ascending snapshot view of the keys in this map      */
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|ascendingKeySet
parameter_list|()
block|{
return|return
name|orderedKeySet
argument_list|(
literal|true
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
return|;
block|}
comment|/**      * Returns an unmodifiable snapshot {@link Set} view of the keys contained in this      * map. The set's iterator returns the keys whose order of iteration is the ascending      * order in which its entries are considered eligible for retention, from the      * least-likely to be retained to the most-likely.      *<p>      * Beware that, unlike in {@link #keySet()}, obtaining the set is<em>NOT</em> a      * constant-time operation. Because of the asynchronous nature of the page replacement      * policy, determining the retention ordering requires a traversal of the keys.      *       * @param limit the maximum size of the returned set      * @return a ascending snapshot view of the keys in this map      * @throws IllegalArgumentException if the limit is negative      */
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|ascendingKeySetWithLimit
parameter_list|(
name|int
name|limit
parameter_list|)
block|{
return|return
name|orderedKeySet
argument_list|(
literal|true
argument_list|,
name|limit
argument_list|)
return|;
block|}
comment|/**      * Returns an unmodifiable snapshot {@link Set} view of the keys contained in this      * map. The set's iterator returns the keys whose order of iteration is the descending      * order in which its entries are considered eligible for retention, from the      * most-likely to be retained to the least-likely.      *<p>      * Beware that, unlike in {@link #keySet()}, obtaining the set is<em>NOT</em> a      * constant-time operation. Because of the asynchronous nature of the page replacement      * policy, determining the retention ordering requires a traversal of the keys.      *       * @return a descending snapshot view of the keys in this map      */
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|descendingKeySet
parameter_list|()
block|{
return|return
name|orderedKeySet
argument_list|(
literal|false
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
return|;
block|}
comment|/**      * Returns an unmodifiable snapshot {@link Set} view of the keys contained in this      * map. The set's iterator returns the keys whose order of iteration is the descending      * order in which its entries are considered eligible for retention, from the      * most-likely to be retained to the least-likely.      *<p>      * Beware that, unlike in {@link #keySet()}, obtaining the set is<em>NOT</em> a      * constant-time operation. Because of the asynchronous nature of the page replacement      * policy, determining the retention ordering requires a traversal of the keys.      *       * @param limit the maximum size of the returned set      * @return a descending snapshot view of the keys in this map      * @throws IllegalArgumentException if the limit is negative      */
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|descendingKeySetWithLimit
parameter_list|(
name|int
name|limit
parameter_list|)
block|{
return|return
name|orderedKeySet
argument_list|(
literal|false
argument_list|,
name|limit
argument_list|)
return|;
block|}
name|Set
argument_list|<
name|K
argument_list|>
name|orderedKeySet
parameter_list|(
name|boolean
name|ascending
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
if|if
condition|(
name|limit
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
name|evictionLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|drainBuffers
argument_list|(
name|AMORTIZED_DRAIN_THRESHOLD
argument_list|)
expr_stmt|;
name|int
name|initialCapacity
init|=
operator|(
name|weigher
operator|==
name|Weighers
operator|.
name|singleton
argument_list|()
operator|)
condition|?
name|Math
operator|.
name|min
argument_list|(
name|limit
argument_list|,
name|weightedSize
argument_list|()
argument_list|)
else|:
literal|16
decl_stmt|;
name|Set
argument_list|<
name|K
argument_list|>
name|keys
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|(
name|initialCapacity
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Node
argument_list|>
name|iterator
init|=
name|ascending
condition|?
name|evictionDeque
operator|.
name|iterator
argument_list|()
else|:
name|evictionDeque
operator|.
name|descendingIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
operator|&&
operator|(
name|limit
operator|>
name|keys
operator|.
name|size
argument_list|()
operator|)
condition|)
block|{
name|keys
operator|.
name|add
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
operator|.
name|key
argument_list|)
expr_stmt|;
block|}
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|keys
argument_list|)
return|;
block|}
finally|finally
block|{
name|evictionLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|vs
init|=
name|values
decl_stmt|;
return|return
operator|(
name|vs
operator|==
literal|null
operator|)
condition|?
operator|(
name|values
operator|=
operator|new
name|Values
argument_list|()
operator|)
else|:
name|vs
return|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|es
init|=
name|entrySet
decl_stmt|;
return|return
operator|(
name|es
operator|==
literal|null
operator|)
condition|?
operator|(
name|entrySet
operator|=
operator|new
name|EntrySet
argument_list|()
operator|)
else|:
name|es
return|;
block|}
comment|/**      * Returns an unmodifiable snapshot {@link Map} view of the mappings contained in this      * map. The map's collections return the mappings whose order of iteration is the      * ascending order in which its entries are considered eligible for retention, from      * the least-likely to be retained to the most-likely.      *<p>      * Beware that obtaining the mappings is<em>NOT</em> a constant-time operation.      * Because of the asynchronous nature of the page replacement policy, determining the      * retention ordering requires a traversal of the entries.      *       * @return a ascending snapshot view of this map      */
specifier|public
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ascendingMap
parameter_list|()
block|{
return|return
name|orderedMap
argument_list|(
literal|true
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
return|;
block|}
comment|/**      * Returns an unmodifiable snapshot {@link Map} view of the mappings contained in this      * map. The map's collections return the mappings whose order of iteration is the      * ascending order in which its entries are considered eligible for retention, from      * the least-likely to be retained to the most-likely.      *<p>      * Beware that obtaining the mappings is<em>NOT</em> a constant-time operation.      * Because of the asynchronous nature of the page replacement policy, determining the      * retention ordering requires a traversal of the entries.      *       * @param limit the maximum size of the returned map      * @return a ascending snapshot view of this map      * @throws IllegalArgumentException if the limit is negative      */
specifier|public
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ascendingMapWithLimit
parameter_list|(
name|int
name|limit
parameter_list|)
block|{
return|return
name|orderedMap
argument_list|(
literal|true
argument_list|,
name|limit
argument_list|)
return|;
block|}
comment|/**      * Returns an unmodifiable snapshot {@link Map} view of the mappings contained in this      * map. The map's collections return the mappings whose order of iteration is the      * descending order in which its entries are considered eligible for retention, from      * the most-likely to be retained to the least-likely.      *<p>      * Beware that obtaining the mappings is<em>NOT</em> a constant-time operation.      * Because of the asynchronous nature of the page replacement policy, determining the      * retention ordering requires a traversal of the entries.      *       * @return a descending snapshot view of this map      */
specifier|public
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|descendingMap
parameter_list|()
block|{
return|return
name|orderedMap
argument_list|(
literal|false
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
return|;
block|}
comment|/**      * Returns an unmodifiable snapshot {@link Map} view of the mappings contained in this      * map. The map's collections return the mappings whose order of iteration is the      * descending order in which its entries are considered eligible for retention, from      * the most-likely to be retained to the least-likely.      *<p>      * Beware that obtaining the mappings is<em>NOT</em> a constant-time operation.      * Because of the asynchronous nature of the page replacement policy, determining the      * retention ordering requires a traversal of the entries.      *       * @param limit the maximum size of the returned map      * @return a descending snapshot view of this map      * @throws IllegalArgumentException if the limit is negative      */
specifier|public
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|descendingMapWithLimit
parameter_list|(
name|int
name|limit
parameter_list|)
block|{
return|return
name|orderedMap
argument_list|(
literal|false
argument_list|,
name|limit
argument_list|)
return|;
block|}
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|orderedMap
parameter_list|(
name|boolean
name|ascending
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
if|if
condition|(
name|limit
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
name|evictionLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|drainBuffers
argument_list|(
name|AMORTIZED_DRAIN_THRESHOLD
argument_list|)
expr_stmt|;
name|int
name|initialCapacity
init|=
operator|(
name|weigher
operator|==
name|Weighers
operator|.
name|singleton
argument_list|()
operator|)
condition|?
name|Math
operator|.
name|min
argument_list|(
name|limit
argument_list|,
name|weightedSize
argument_list|()
argument_list|)
else|:
literal|16
decl_stmt|;
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|(
name|initialCapacity
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Node
argument_list|>
name|iterator
init|=
name|ascending
condition|?
name|evictionDeque
operator|.
name|iterator
argument_list|()
else|:
name|evictionDeque
operator|.
name|descendingIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
operator|&&
operator|(
name|limit
operator|>
name|map
operator|.
name|size
argument_list|()
operator|)
condition|)
block|{
name|Node
name|node
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|node
operator|.
name|key
argument_list|,
name|node
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|map
argument_list|)
return|;
block|}
finally|finally
block|{
name|evictionLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** A value, its weight, and the entry's status. */
specifier|static
specifier|final
class|class
name|WeightedValue
parameter_list|<
name|V
parameter_list|>
block|{
specifier|final
name|int
name|weight
decl_stmt|;
specifier|final
name|V
name|value
decl_stmt|;
name|WeightedValue
parameter_list|(
name|V
name|value
parameter_list|,
name|int
name|weight
parameter_list|)
block|{
name|this
operator|.
name|weight
operator|=
name|weight
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
name|boolean
name|hasValue
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
operator|(
name|o
operator|==
name|value
operator|)
operator|||
name|value
operator|.
name|equals
argument_list|(
name|o
argument_list|)
return|;
block|}
comment|/**          * If the entry is available in the hash-table and page replacement policy.          */
name|boolean
name|isAlive
parameter_list|()
block|{
return|return
name|weight
operator|>
literal|0
return|;
block|}
comment|/**          * If the entry was removed from the hash-table and is awaiting removal from the          * page replacement policy.          */
name|boolean
name|isRetired
parameter_list|()
block|{
return|return
name|weight
operator|<
literal|0
return|;
block|}
comment|/**          * If the entry was removed from the hash-table and the page replacement policy.          */
name|boolean
name|isDead
parameter_list|()
block|{
return|return
name|weight
operator|==
literal|0
return|;
block|}
block|}
comment|/**      * A node contains the key, the weighted value, and the linkage pointers on the      * page-replacement algorithm's data structures.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|final
class|class
name|Node
extends|extends
name|AtomicReference
argument_list|<
name|WeightedValue
argument_list|<
name|V
argument_list|>
argument_list|>
implements|implements
name|Linked
argument_list|<
name|Node
argument_list|>
block|{
specifier|final
name|K
name|key
decl_stmt|;
name|Node
name|prev
decl_stmt|;
name|Node
name|next
decl_stmt|;
comment|/** Creates a new, unlinked node. */
name|Node
parameter_list|(
name|K
name|key
parameter_list|,
name|WeightedValue
argument_list|<
name|V
argument_list|>
name|weightedValue
parameter_list|)
block|{
name|super
argument_list|(
name|weightedValue
argument_list|)
expr_stmt|;
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
block|}
specifier|public
name|Node
name|getPrevious
parameter_list|()
block|{
return|return
name|prev
return|;
block|}
specifier|public
name|void
name|setPrevious
parameter_list|(
name|Node
name|prev
parameter_list|)
block|{
name|this
operator|.
name|prev
operator|=
name|prev
expr_stmt|;
block|}
specifier|public
name|Node
name|getNext
parameter_list|()
block|{
return|return
name|next
return|;
block|}
specifier|public
name|void
name|setNext
parameter_list|(
name|Node
name|next
parameter_list|)
block|{
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
comment|/** Retrieves the value held by the current<tt>WeightedValue</tt>. */
name|V
name|getValue
parameter_list|()
block|{
return|return
name|get
argument_list|()
operator|.
name|value
return|;
block|}
comment|/**          * Attempts to transition the node from the<tt>alive</tt> state to the          *<tt>retired</tt> state.          *           * @param expect the expected weighted value          * @return if successful          */
name|boolean
name|tryToRetire
parameter_list|(
name|WeightedValue
argument_list|<
name|V
argument_list|>
name|expect
parameter_list|)
block|{
if|if
condition|(
name|expect
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|WeightedValue
argument_list|<
name|V
argument_list|>
name|retired
init|=
operator|new
name|WeightedValue
argument_list|<>
argument_list|(
name|expect
operator|.
name|value
argument_list|,
operator|-
name|expect
operator|.
name|weight
argument_list|)
decl_stmt|;
return|return
name|compareAndSet
argument_list|(
name|expect
argument_list|,
name|retired
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**          * Atomically transitions the node from the<tt>alive</tt> state to the          *<tt>retired</tt> state, if a valid transition.          */
name|void
name|makeRetired
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|WeightedValue
argument_list|<
name|V
argument_list|>
name|current
init|=
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|current
operator|.
name|isAlive
argument_list|()
condition|)
block|{
return|return;
block|}
name|WeightedValue
argument_list|<
name|V
argument_list|>
name|retired
init|=
operator|new
name|WeightedValue
argument_list|<>
argument_list|(
name|current
operator|.
name|value
argument_list|,
operator|-
name|current
operator|.
name|weight
argument_list|)
decl_stmt|;
if|if
condition|(
name|compareAndSet
argument_list|(
name|current
argument_list|,
name|retired
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
comment|/**          * Atomically transitions the node to the<tt>dead</tt> state and decrements the          *<tt>weightedSize</tt>.          */
name|void
name|makeDead
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|WeightedValue
argument_list|<
name|V
argument_list|>
name|current
init|=
name|get
argument_list|()
decl_stmt|;
name|WeightedValue
argument_list|<
name|V
argument_list|>
name|dead
init|=
operator|new
name|WeightedValue
argument_list|<>
argument_list|(
name|current
operator|.
name|value
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|compareAndSet
argument_list|(
name|current
argument_list|,
name|dead
argument_list|)
condition|)
block|{
name|weightedSize
operator|-=
name|Math
operator|.
name|abs
argument_list|(
name|current
operator|.
name|weight
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
comment|/** An adapter to safely externalize the keys. */
specifier|final
class|class
name|KeySet
extends|extends
name|AbstractSet
argument_list|<
name|K
argument_list|>
block|{
specifier|final
name|ConcurrentLinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
name|ConcurrentLinkedHashMap
operator|.
name|this
decl_stmt|;
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|map
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|K
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|KeyIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|containsKey
argument_list|(
name|obj
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
operator|(
name|map
operator|.
name|remove
argument_list|(
name|obj
argument_list|)
operator|!=
literal|null
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
return|return
name|map
operator|.
name|data
operator|.
name|keySet
argument_list|()
operator|.
name|toArray
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|array
parameter_list|)
block|{
return|return
name|map
operator|.
name|data
operator|.
name|keySet
argument_list|()
operator|.
name|toArray
argument_list|(
name|array
argument_list|)
return|;
block|}
block|}
comment|/** An adapter to safely externalize the key iterator. */
specifier|final
class|class
name|KeyIterator
implements|implements
name|Iterator
argument_list|<
name|K
argument_list|>
block|{
specifier|final
name|Iterator
argument_list|<
name|K
argument_list|>
name|iterator
init|=
name|data
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|K
name|current
decl_stmt|;
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|public
name|K
name|next
parameter_list|()
block|{
name|current
operator|=
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
return|return
name|current
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
name|ConcurrentLinkedHashMap
operator|.
name|this
operator|.
name|remove
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|current
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/** An adapter to safely externalize the values. */
specifier|final
class|class
name|Values
extends|extends
name|AbstractCollection
argument_list|<
name|V
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|ConcurrentLinkedHashMap
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|ConcurrentLinkedHashMap
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|ValueIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|containsValue
argument_list|(
name|o
argument_list|)
return|;
block|}
block|}
comment|/** An adapter to safely externalize the value iterator. */
specifier|final
class|class
name|ValueIterator
implements|implements
name|Iterator
argument_list|<
name|V
argument_list|>
block|{
specifier|final
name|Iterator
argument_list|<
name|Node
argument_list|>
name|iterator
init|=
name|data
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Node
name|current
decl_stmt|;
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|public
name|V
name|next
parameter_list|()
block|{
name|current
operator|=
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
return|return
name|current
operator|.
name|getValue
argument_list|()
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
name|ConcurrentLinkedHashMap
operator|.
name|this
operator|.
name|remove
argument_list|(
name|current
operator|.
name|key
argument_list|)
expr_stmt|;
name|current
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/** An adapter to safely externalize the entries. */
specifier|final
class|class
name|EntrySet
extends|extends
name|AbstractSet
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
specifier|final
name|ConcurrentLinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
name|ConcurrentLinkedHashMap
operator|.
name|this
decl_stmt|;
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|map
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|EntryIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|obj
decl_stmt|;
name|Node
name|node
init|=
name|map
operator|.
name|data
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|(
name|node
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|node
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|add
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
return|return
operator|(
name|map
operator|.
name|putIfAbsent
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
operator|==
literal|null
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
operator|(
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|obj
decl_stmt|;
return|return
name|map
operator|.
name|remove
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/** An adapter to safely externalize the entry iterator. */
specifier|final
class|class
name|EntryIterator
implements|implements
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
specifier|final
name|Iterator
argument_list|<
name|Node
argument_list|>
name|iterator
init|=
name|data
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Node
name|current
decl_stmt|;
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|()
block|{
name|current
operator|=
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
return|return
operator|new
name|WriteThroughEntry
argument_list|(
name|current
argument_list|)
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
name|ConcurrentLinkedHashMap
operator|.
name|this
operator|.
name|remove
argument_list|(
name|current
operator|.
name|key
argument_list|)
expr_stmt|;
name|current
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/** An entry that allows updates to write through to the map. */
specifier|final
class|class
name|WriteThroughEntry
extends|extends
name|AbstractMap
operator|.
name|SimpleEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1
decl_stmt|;
name|WriteThroughEntry
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
name|super
argument_list|(
name|node
operator|.
name|key
argument_list|,
name|node
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|setValue
parameter_list|(
name|V
name|value
parameter_list|)
block|{
name|put
argument_list|(
name|getKey
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|super
operator|.
name|setValue
argument_list|(
name|value
argument_list|)
return|;
block|}
name|Object
name|writeReplace
parameter_list|()
block|{
return|return
operator|new
name|AbstractMap
operator|.
name|SimpleEntry
argument_list|<>
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/** A weigher that enforces that the weight falls within a valid range. */
specifier|static
specifier|final
class|class
name|BoundedWeigher
parameter_list|<
name|V
parameter_list|>
implements|implements
name|Weigher
argument_list|<
name|V
argument_list|>
implements|,
name|Serializable
block|{
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1
decl_stmt|;
specifier|final
name|Weigher
argument_list|<
name|?
super|super
name|V
argument_list|>
name|weigher
decl_stmt|;
name|BoundedWeigher
parameter_list|(
name|Weigher
argument_list|<
name|?
super|super
name|V
argument_list|>
name|weigher
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|weigher
argument_list|)
expr_stmt|;
name|this
operator|.
name|weigher
operator|=
name|weigher
expr_stmt|;
block|}
specifier|public
name|int
name|weightOf
parameter_list|(
name|V
name|value
parameter_list|)
block|{
name|int
name|weight
init|=
name|weigher
operator|.
name|weightOf
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|weight
operator|<
literal|1
operator|)
operator|||
operator|(
name|weight
operator|>
name|MAXIMUM_WEIGHT
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"invalid weight"
argument_list|)
throw|;
block|}
return|return
name|weight
return|;
block|}
name|Object
name|writeReplace
parameter_list|()
block|{
return|return
name|weigher
return|;
block|}
block|}
comment|/** A task that catches up the page replacement policy. */
specifier|static
specifier|final
class|class
name|CatchUpTask
implements|implements
name|Runnable
block|{
specifier|final
name|WeakReference
argument_list|<
name|ConcurrentLinkedHashMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|mapRef
decl_stmt|;
name|CatchUpTask
parameter_list|(
name|ConcurrentLinkedHashMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
parameter_list|)
block|{
name|this
operator|.
name|mapRef
operator|=
operator|new
name|WeakReference
argument_list|<
name|ConcurrentLinkedHashMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|run
parameter_list|()
block|{
name|ConcurrentLinkedHashMap
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|map
init|=
name|mapRef
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|map
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CancellationException
argument_list|()
throw|;
block|}
name|int
name|pendingTasks
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|map
operator|.
name|buffers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|pendingTasks
operator|+=
name|map
operator|.
name|bufferLengths
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pendingTasks
operator|!=
literal|0
condition|)
block|{
name|map
operator|.
name|tryToDrainBuffers
argument_list|(
name|pendingTasks
operator|+
name|BUFFER_THRESHOLD
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** An executor that is always terminated. */
specifier|static
specifier|final
class|class
name|DisabledExecutorService
extends|extends
name|AbstractExecutorService
block|{
specifier|public
name|boolean
name|isShutdown
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|isTerminated
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
block|}
specifier|public
name|List
argument_list|<
name|Runnable
argument_list|>
name|shutdownNow
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|awaitTermination
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
specifier|public
name|void
name|execute
parameter_list|(
name|Runnable
name|command
parameter_list|)
block|{
throw|throw
operator|new
name|RejectedExecutionException
argument_list|()
throw|;
block|}
block|}
comment|/** A queue that discards all additions and is always empty. */
specifier|static
specifier|final
class|class
name|DiscardingQueue
extends|extends
name|AbstractQueue
argument_list|<
name|Object
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|add
parameter_list|(
name|Object
name|e
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|offer
parameter_list|(
name|Object
name|e
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
specifier|public
name|Object
name|poll
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|Object
name|peek
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Object
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
block|}
comment|/** A listener that ignores all notifications. */
enum|enum
name|DiscardingListener
implements|implements
name|EvictionListener
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
block|{
name|INSTANCE
block|;
specifier|public
name|void
name|onEviction
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
block|}
block|}
comment|/** An operation that can be lazily applied to the page replacement policy. */
interface|interface
name|Task
extends|extends
name|Runnable
block|{
comment|/** The priority order. */
name|int
name|getOrder
parameter_list|()
function_decl|;
comment|/** If the task represents an add, modify, or remove operation. */
name|boolean
name|isWrite
parameter_list|()
function_decl|;
comment|/** Returns the next task on the link chain. */
name|Task
name|getNext
parameter_list|()
function_decl|;
comment|/** Sets the next task on the link chain. */
name|void
name|setNext
parameter_list|(
name|Task
name|task
parameter_list|)
function_decl|;
block|}
comment|/** A skeletal implementation of the<tt>Task</tt> interface. */
specifier|abstract
class|class
name|AbstractTask
implements|implements
name|Task
block|{
specifier|final
name|int
name|order
decl_stmt|;
name|Task
name|task
decl_stmt|;
name|AbstractTask
parameter_list|()
block|{
name|order
operator|=
name|nextOrdering
argument_list|()
expr_stmt|;
block|}
specifier|public
name|int
name|getOrder
parameter_list|()
block|{
return|return
name|order
return|;
block|}
specifier|public
name|Task
name|getNext
parameter_list|()
block|{
return|return
name|task
return|;
block|}
specifier|public
name|void
name|setNext
parameter_list|(
name|Task
name|task
parameter_list|)
block|{
name|this
operator|.
name|task
operator|=
name|task
expr_stmt|;
block|}
block|}
comment|/* ---------------- Serialization Support -------------- */
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1
decl_stmt|;
name|Object
name|writeReplace
parameter_list|()
block|{
return|return
operator|new
name|SerializationProxy
argument_list|<>
argument_list|(
name|this
argument_list|)
return|;
block|}
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|stream
parameter_list|)
throws|throws
name|InvalidObjectException
block|{
throw|throw
operator|new
name|InvalidObjectException
argument_list|(
literal|"Proxy required"
argument_list|)
throw|;
block|}
comment|/**      * A proxy that is serialized instead of the map. The page-replacement algorithm's      * data structures are not serialized so the deserialized instance contains only the      * entries. This is acceptable as caches hold transient data that is recomputable and      * serialization would tend to be used as a fast warm-up process.      */
specifier|static
specifier|final
class|class
name|SerializationProxy
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|Serializable
block|{
specifier|final
name|EvictionListener
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|listener
decl_stmt|;
specifier|final
name|Weigher
argument_list|<
name|?
super|super
name|V
argument_list|>
name|weigher
decl_stmt|;
specifier|final
name|int
name|concurrencyLevel
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|data
decl_stmt|;
specifier|final
name|int
name|capacity
decl_stmt|;
name|SerializationProxy
parameter_list|(
name|ConcurrentLinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|concurrencyLevel
operator|=
name|map
operator|.
name|concurrencyLevel
expr_stmt|;
name|data
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|capacity
operator|=
name|map
operator|.
name|capacity
expr_stmt|;
name|listener
operator|=
name|map
operator|.
name|listener
expr_stmt|;
name|weigher
operator|=
name|map
operator|.
name|weigher
expr_stmt|;
block|}
name|Object
name|readResolve
parameter_list|()
block|{
name|ConcurrentLinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
operator|new
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
operator|.
name|concurrencyLevel
argument_list|(
name|concurrencyLevel
argument_list|)
operator|.
name|maximumWeightedCapacity
argument_list|(
name|capacity
argument_list|)
operator|.
name|listener
argument_list|(
name|listener
argument_list|)
operator|.
name|weigher
argument_list|(
name|weigher
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|map
operator|.
name|putAll
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|map
return|;
block|}
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1
decl_stmt|;
block|}
comment|/* ---------------- Builder -------------- */
comment|/**      * A builder that creates {@link ConcurrentLinkedHashMap} instances. It provides a      * flexible approach for constructing customized instances with a named parameter      * syntax. It can be used in the following manner:      *       *<pre>      *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       *       * {      *&#064;code      *     ConcurrentMap&lt;Vertex, Set&lt;Edge&gt;&gt; graph = new Builder&lt;Vertex, Set&lt;Edge&gt;&gt;()      *             .maximumWeightedCapacity(5000)      *             .weigher(Weighers.&lt;Edge&gt; set())      *             .build();      * }      *</pre>      */
specifier|public
specifier|static
specifier|final
class|class
name|Builder
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
specifier|static
specifier|final
name|ExecutorService
name|DEFAULT_EXECUTOR
init|=
operator|new
name|DisabledExecutorService
argument_list|()
decl_stmt|;
specifier|static
specifier|final
name|int
name|DEFAULT_CONCURRENCY_LEVEL
init|=
literal|16
decl_stmt|;
specifier|static
specifier|final
name|int
name|DEFAULT_INITIAL_CAPACITY
init|=
literal|16
decl_stmt|;
name|EvictionListener
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|listener
decl_stmt|;
name|Weigher
argument_list|<
name|?
super|super
name|V
argument_list|>
name|weigher
decl_stmt|;
name|ExecutorService
name|executor
decl_stmt|;
name|TimeUnit
name|unit
decl_stmt|;
name|long
name|delay
decl_stmt|;
name|int
name|concurrencyLevel
decl_stmt|;
name|int
name|initialCapacity
decl_stmt|;
name|int
name|capacity
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|Builder
parameter_list|()
block|{
name|capacity
operator|=
operator|-
literal|1
expr_stmt|;
name|executor
operator|=
name|DEFAULT_EXECUTOR
expr_stmt|;
name|weigher
operator|=
name|Weighers
operator|.
name|singleton
argument_list|()
expr_stmt|;
name|initialCapacity
operator|=
name|DEFAULT_INITIAL_CAPACITY
expr_stmt|;
name|concurrencyLevel
operator|=
name|DEFAULT_CONCURRENCY_LEVEL
expr_stmt|;
name|listener
operator|=
operator|(
name|EvictionListener
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|DiscardingListener
operator|.
name|INSTANCE
expr_stmt|;
block|}
comment|/**          * Specifies the initial capacity of the hash table (default<tt>16</tt>). This is          * the number of key-value pairs that the hash table can hold before a resize          * operation is required.          *           * @param initialCapacity the initial capacity used to size the hash table to          *            accommodate this many entries.          * @throws IllegalArgumentException if the initialCapacity is negative          */
specifier|public
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|initialCapacity
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
if|if
condition|(
name|initialCapacity
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
name|this
operator|.
name|initialCapacity
operator|=
name|initialCapacity
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the maximum weighted capacity to coerce the map to and may exceed it          * temporarily.          *           * @param capacity the weighted threshold to bound the map by          * @throws IllegalArgumentException if the maximumWeightedCapacity is negative          */
specifier|public
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|maximumWeightedCapacity
parameter_list|(
name|int
name|capacity
parameter_list|)
block|{
if|if
condition|(
name|capacity
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
name|this
operator|.
name|capacity
operator|=
name|capacity
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies the estimated number of concurrently updating threads. The          * implementation performs internal sizing to try to accommodate this many threads          * (default<tt>16</tt>).          *           * @param concurrencyLevel the estimated number of concurrently updating threads          * @throws IllegalArgumentException if the concurrencyLevel is less than or equal          *             to zero          */
specifier|public
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|concurrencyLevel
parameter_list|(
name|int
name|concurrencyLevel
parameter_list|)
block|{
if|if
condition|(
name|concurrencyLevel
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
name|this
operator|.
name|concurrencyLevel
operator|=
name|concurrencyLevel
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies an optional listener that is registered for notification when an          * entry is evicted.          *           * @param listener the object to forward evicted entries to          * @throws NullPointerException if the listener is null          */
specifier|public
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|listener
parameter_list|(
name|EvictionListener
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|listener
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|listener
argument_list|)
expr_stmt|;
name|this
operator|.
name|listener
operator|=
name|listener
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies an algorithm to determine how many the units of capacity a value          * consumes. The default algorithm bounds the map by the number of key-value pairs          * by giving each entry a weight of<tt>1</tt>.          *           * @param weigher the algorithm to determine a value's weight          * @throws NullPointerException if the weigher is null          */
specifier|public
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|weigher
parameter_list|(
name|Weigher
argument_list|<
name|?
super|super
name|V
argument_list|>
name|weigher
parameter_list|)
block|{
name|this
operator|.
name|weigher
operator|=
operator|(
name|weigher
operator|==
name|Weighers
operator|.
name|singleton
argument_list|()
operator|)
condition|?
name|Weighers
operator|.
expr|<
name|V
operator|>
name|singleton
argument_list|()
else|:
operator|new
name|BoundedWeigher
argument_list|<>
argument_list|(
name|weigher
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Specifies an executor for use in catching up the page replacement policy. The          * catch-up phase processes both updates to the retention ordering and writes that          * may trigger an eviction. The delay should be chosen carefully as the map will          * not automatically evict between executions.          *<p>          * If unspecified or the executor is shutdown, the catching up will be amortized          * on user threads during write operations (or during read operations, in the          * absence of writes).          *<p>          * A single-threaded {@link ScheduledExecutorService} should be sufficient for          * catching up the page replacement policy in many maps.          *           * @param executor the executor to schedule on          * @param delay the delay between executions          * @param unit the time unit of the delay parameter          * @throws NullPointerException if the executor or time unit is null          * @throws IllegalArgumentException if the delay is less than or equal to zero          */
specifier|public
name|Builder
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|catchup
parameter_list|(
name|ScheduledExecutorService
name|executor
parameter_list|,
name|long
name|delay
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
if|if
condition|(
name|delay
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
name|checkNotNull
argument_list|(
name|executor
argument_list|)
expr_stmt|;
name|checkNotNull
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
name|this
operator|.
name|delay
operator|=
name|delay
expr_stmt|;
name|this
operator|.
name|unit
operator|=
name|unit
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Creates a new {@link ConcurrentLinkedHashMap} instance.          *           * @throws IllegalStateException if the maximum weighted capacity was not set          * @throws RejectedExecutionException if an executor was specified and the          *             catch-up task cannot be scheduled for execution          */
specifier|public
name|ConcurrentLinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|build
parameter_list|()
block|{
if|if
condition|(
name|capacity
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
name|ConcurrentLinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
init|=
operator|new
name|ConcurrentLinkedHashMap
argument_list|<>
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|executor
operator|!=
name|DEFAULT_EXECUTOR
condition|)
block|{
name|ScheduledExecutorService
name|es
init|=
operator|(
name|ScheduledExecutorService
operator|)
name|executor
decl_stmt|;
name|es
operator|.
name|scheduleWithFixedDelay
argument_list|(
operator|new
name|CatchUpTask
argument_list|(
name|map
argument_list|)
argument_list|,
name|delay
argument_list|,
name|delay
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
block|}
block|}
end_class

end_unit

