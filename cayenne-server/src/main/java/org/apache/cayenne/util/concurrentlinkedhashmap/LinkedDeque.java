begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************  *   Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *    https://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing,  *  software distributed under the License is distributed on an  *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *  KIND, either express or implied.  See the License for the  *  specific language governing permissions and limitations  *  under the License.  ****************************************************************/
end_comment

begin_comment
comment|/*  * Copyright 2011 Google Inc. All Rights Reserved.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     https://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|util
operator|.
name|concurrentlinkedhashmap
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_comment
comment|/**  * Linked list implementation of the Deque interface (not available in Java 5, so not  * formally declared) where the link pointers are tightly integrated with the element.  * Linked deques have no capacity restrictions; they grow as necessary to support usage.  * They are not thread-safe; in the absence of external synchronization, they do not  * support concurrent access by multiple threads. Null elements are prohibited.  *<p>  * Most<tt>LinkedDeque</tt> operations run in constant time by assuming that the  * {@link Linked} parameter is associated with the deque instance. Any usage that violates  * this assumption will result in non-deterministic behavior.  *<p>  * The iterators returned by this class are<em>not</em><i>fail-fast</i>: If the deque is  * modified at any time after the iterator is created, the iterator will be in an unknown  * state. Thus, in the face of concurrent modification, the iterator risks arbitrary,  * non-deterministic behavior at an undetermined time in the future.  *   * @param<E> the type of elements held in this collection  */
end_comment

begin_class
class|class
name|LinkedDeque
parameter_list|<
name|E
extends|extends
name|Linked
parameter_list|<
name|E
parameter_list|>
parameter_list|>
extends|extends
name|AbstractCollection
argument_list|<
name|E
argument_list|>
block|{
comment|// This class provides a doubly-linked list that is optimized for the virtual
comment|// machine. The first and last elements are manipulated instead of a slightly
comment|// more convenient sentinel element to avoid the insertion of null checks with
comment|// NullPointerException throws in the byte code. The links to a removed
comment|// element are cleared to help a generational garbage collector if the
comment|// discarded elements inhabit more than one generation.
comment|/**      * Pointer to first node. Invariant: (first == null&& last == null) || (first.prev ==      * null)      */
name|E
name|first
decl_stmt|;
comment|/**      * Pointer to last node. Invariant: (first == null&& last == null) || (last.next ==      * null)      */
name|E
name|last
decl_stmt|;
comment|/**      * Links the element to the front of the deque so that it becomes the first element.      *       * @param e the unlinked element      */
name|void
name|linkFirst
parameter_list|(
specifier|final
name|E
name|e
parameter_list|)
block|{
specifier|final
name|E
name|f
init|=
name|first
decl_stmt|;
name|first
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
name|last
operator|=
name|e
expr_stmt|;
block|}
else|else
block|{
name|f
operator|.
name|setPrevious
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|setNext
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Links the element to the back of the deque so that it becomes the last element.      *       * @param e the unlinked element      */
name|void
name|linkLast
parameter_list|(
specifier|final
name|E
name|e
parameter_list|)
block|{
specifier|final
name|E
name|l
init|=
name|last
decl_stmt|;
name|last
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|null
condition|)
block|{
name|first
operator|=
name|e
expr_stmt|;
block|}
else|else
block|{
name|l
operator|.
name|setNext
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|setPrevious
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Unlinks the non-null first element. */
name|E
name|unlinkFirst
parameter_list|()
block|{
specifier|final
name|E
name|f
init|=
name|first
decl_stmt|;
specifier|final
name|E
name|next
init|=
name|f
operator|.
name|getNext
argument_list|()
decl_stmt|;
name|f
operator|.
name|setNext
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|first
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
operator|==
literal|null
condition|)
block|{
name|last
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|next
operator|.
name|setPrevious
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
comment|/** Unlinks the non-null last element. */
name|E
name|unlinkLast
parameter_list|()
block|{
specifier|final
name|E
name|l
init|=
name|last
decl_stmt|;
specifier|final
name|E
name|prev
init|=
name|l
operator|.
name|getPrevious
argument_list|()
decl_stmt|;
name|l
operator|.
name|setPrevious
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|last
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|prev
operator|==
literal|null
condition|)
block|{
name|first
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|.
name|setNext
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|l
return|;
block|}
comment|/** Unlinks the non-null element. */
name|void
name|unlink
parameter_list|(
name|E
name|e
parameter_list|)
block|{
specifier|final
name|E
name|prev
init|=
name|e
operator|.
name|getPrevious
argument_list|()
decl_stmt|;
specifier|final
name|E
name|next
init|=
name|e
operator|.
name|getNext
argument_list|()
decl_stmt|;
if|if
condition|(
name|prev
operator|==
literal|null
condition|)
block|{
name|first
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|.
name|setNext
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|e
operator|.
name|setPrevious
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|==
literal|null
condition|)
block|{
name|last
operator|=
name|prev
expr_stmt|;
block|}
else|else
block|{
name|next
operator|.
name|setPrevious
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|e
operator|.
name|setNext
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
operator|(
name|first
operator|==
literal|null
operator|)
return|;
block|}
name|void
name|checkNotEmpty
parameter_list|()
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
block|}
comment|/**      * {@inheritDoc}      *<p>      * Beware that, unlike in most collections, this method is<em>NOT</em> a      * constant-time operation.      */
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|E
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|getNext
argument_list|()
control|)
block|{
name|size
operator|++
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
for|for
control|(
name|E
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
control|)
block|{
name|E
name|next
init|=
name|e
operator|.
name|getNext
argument_list|()
decl_stmt|;
name|e
operator|.
name|setPrevious
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|e
operator|.
name|setNext
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|e
operator|=
name|next
expr_stmt|;
block|}
name|first
operator|=
name|last
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
operator|(
name|o
operator|instanceof
name|Linked
argument_list|<
name|?
argument_list|>
operator|)
operator|&&
name|contains
argument_list|(
operator|(
name|Linked
argument_list|<
name|?
argument_list|>
operator|)
name|o
argument_list|)
return|;
block|}
comment|// A fast-path containment check
name|boolean
name|contains
parameter_list|(
name|Linked
argument_list|<
name|?
argument_list|>
name|e
parameter_list|)
block|{
return|return
operator|(
name|e
operator|.
name|getPrevious
argument_list|()
operator|!=
literal|null
operator|)
operator|||
operator|(
name|e
operator|.
name|getNext
argument_list|()
operator|!=
literal|null
operator|)
operator|||
operator|(
name|e
operator|==
name|first
operator|)
return|;
block|}
comment|/**      * Moves the element to the front of the deque so that it becomes the first element.      *       * @param e the linked element      */
specifier|public
name|void
name|moveToFront
parameter_list|(
name|E
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|!=
name|first
condition|)
block|{
name|unlink
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|linkFirst
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Moves the element to the back of the deque so that it becomes the last element.      *       * @param e the linked element      */
specifier|public
name|void
name|moveToBack
parameter_list|(
name|E
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|!=
name|last
condition|)
block|{
name|unlink
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|linkLast
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|E
name|peek
parameter_list|()
block|{
return|return
name|peekFirst
argument_list|()
return|;
block|}
specifier|public
name|E
name|peekFirst
parameter_list|()
block|{
return|return
name|first
return|;
block|}
specifier|public
name|E
name|peekLast
parameter_list|()
block|{
return|return
name|last
return|;
block|}
specifier|public
name|E
name|getFirst
parameter_list|()
block|{
name|checkNotEmpty
argument_list|()
expr_stmt|;
return|return
name|peekFirst
argument_list|()
return|;
block|}
specifier|public
name|E
name|getLast
parameter_list|()
block|{
name|checkNotEmpty
argument_list|()
expr_stmt|;
return|return
name|peekLast
argument_list|()
return|;
block|}
specifier|public
name|E
name|element
parameter_list|()
block|{
return|return
name|getFirst
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|offer
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|offerLast
argument_list|(
name|e
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|offerFirst
parameter_list|(
name|E
name|e
parameter_list|)
block|{
if|if
condition|(
name|contains
argument_list|(
name|e
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|linkFirst
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|offerLast
parameter_list|(
name|E
name|e
parameter_list|)
block|{
if|if
condition|(
name|contains
argument_list|(
name|e
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|linkLast
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|add
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|offerLast
argument_list|(
name|e
argument_list|)
return|;
block|}
specifier|public
name|void
name|addFirst
parameter_list|(
name|E
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|offerFirst
argument_list|(
name|e
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
block|}
specifier|public
name|void
name|addLast
parameter_list|(
name|E
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|offerLast
argument_list|(
name|e
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
block|}
specifier|public
name|E
name|poll
parameter_list|()
block|{
return|return
name|pollFirst
argument_list|()
return|;
block|}
specifier|public
name|E
name|pollFirst
parameter_list|()
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|unlinkFirst
argument_list|()
return|;
block|}
specifier|public
name|E
name|pollLast
parameter_list|()
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|unlinkLast
argument_list|()
return|;
block|}
specifier|public
name|E
name|remove
parameter_list|()
block|{
return|return
name|removeFirst
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|contains
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|unlink
argument_list|(
operator|(
name|E
operator|)
name|o
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|E
name|removeFirst
parameter_list|()
block|{
name|checkNotEmpty
argument_list|()
expr_stmt|;
return|return
name|pollFirst
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|removeFirstOccurrence
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|remove
argument_list|(
name|o
argument_list|)
return|;
block|}
specifier|public
name|E
name|removeLast
parameter_list|()
block|{
name|checkNotEmpty
argument_list|()
expr_stmt|;
return|return
name|pollLast
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|removeLastOccurrence
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|remove
argument_list|(
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
name|boolean
name|modified
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|c
control|)
block|{
name|modified
operator||=
name|remove
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
return|return
name|modified
return|;
block|}
specifier|public
name|void
name|push
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|addFirst
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
specifier|public
name|E
name|pop
parameter_list|()
block|{
return|return
name|removeFirst
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|AbstractLinkedIterator
argument_list|(
name|first
argument_list|)
block|{
annotation|@
name|Override
name|E
name|computeNext
parameter_list|()
block|{
return|return
name|cursor
operator|.
name|getNext
argument_list|()
return|;
block|}
block|}
return|;
block|}
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|descendingIterator
parameter_list|()
block|{
return|return
operator|new
name|AbstractLinkedIterator
argument_list|(
name|last
argument_list|)
block|{
annotation|@
name|Override
name|E
name|computeNext
parameter_list|()
block|{
return|return
name|cursor
operator|.
name|getPrevious
argument_list|()
return|;
block|}
block|}
return|;
block|}
specifier|abstract
class|class
name|AbstractLinkedIterator
implements|implements
name|Iterator
argument_list|<
name|E
argument_list|>
block|{
name|E
name|cursor
decl_stmt|;
comment|/**          * Creates an iterator that can can traverse the deque.          *           * @param start the initial element to begin traversal from          */
name|AbstractLinkedIterator
parameter_list|(
name|E
name|start
parameter_list|)
block|{
name|cursor
operator|=
name|start
expr_stmt|;
block|}
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
operator|(
name|cursor
operator|!=
literal|null
operator|)
return|;
block|}
specifier|public
name|E
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|E
name|e
init|=
name|cursor
decl_stmt|;
name|cursor
operator|=
name|computeNext
argument_list|()
expr_stmt|;
return|return
name|e
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**          * Retrieves the next element to traverse to or<tt>null</tt> if there are no more          * elements.          */
specifier|abstract
name|E
name|computeNext
parameter_list|()
function_decl|;
block|}
block|}
end_class

begin_comment
comment|/**  * An element that is linked on the Deque.  */
end_comment

begin_interface
interface|interface
name|Linked
parameter_list|<
name|T
extends|extends
name|Linked
parameter_list|<
name|T
parameter_list|>
parameter_list|>
block|{
comment|/**      * Retrieves the previous element or<tt>null</tt> if either the element is unlinked      * or the first element on the deque.      */
name|T
name|getPrevious
parameter_list|()
function_decl|;
comment|/** Sets the previous element or<tt>null</tt> if there is no link. */
name|void
name|setPrevious
parameter_list|(
name|T
name|prev
parameter_list|)
function_decl|;
comment|/**      * Retrieves the next element or<tt>null</tt> if either the element is unlinked or      * the last element on the deque.      */
name|T
name|getNext
parameter_list|()
function_decl|;
comment|/** Sets the next element or<tt>null</tt> if there is no link. */
name|void
name|setNext
parameter_list|(
name|T
name|next
parameter_list|)
function_decl|;
block|}
end_interface

end_unit

