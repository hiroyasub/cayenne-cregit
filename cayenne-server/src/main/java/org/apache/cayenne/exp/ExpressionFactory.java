begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************  *   Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing,  *  software distributed under the License is distributed on an  *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *  KIND, either express or implied.  See the License for the  *  specific language governing permissions and limitations  *  under the License.  ****************************************************************/
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|Persistent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTAdd
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTAnd
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTBetween
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTBitwiseAnd
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTBitwiseLeftShift
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTBitwiseNot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTBitwiseOr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTBitwiseRightShift
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTBitwiseXor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTDbPath
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTDivide
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTEqual
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTFalse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTGreater
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTGreaterOrEqual
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTIn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTLess
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTLessOrEqual
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTLike
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTLikeIgnoreCase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTMultiply
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTNegate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTNot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTNotBetween
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTNotEqual
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTNotIn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTNotLike
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTNotLikeIgnoreCase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTObjPath
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTOr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTPath
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTSubtract
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ASTTrue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ExpressionParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ExpressionParserTokenManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|JavaCharStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|exp
operator|.
name|parser
operator|.
name|SimpleNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|Entity
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * Helper class to build expressions.  */
end_comment

begin_class
specifier|public
class|class
name|ExpressionFactory
block|{
comment|/** 	 * A "split" character, "|", that is understood by some of the 	 * ExpressionFactory methods that require splitting joins in the middle of 	 * the path. 	 *  	 * @since 3.0 	 */
specifier|public
specifier|static
specifier|final
name|char
name|SPLIT_SEPARATOR
init|=
literal|'|'
decl_stmt|;
specifier|private
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|typeLookup
decl_stmt|;
specifier|private
specifier|static
specifier|volatile
name|int
name|autoAliasId
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|PARSE_BUFFER_MAX_SIZE
init|=
literal|4096
decl_stmt|;
static|static
block|{
comment|// make sure all types are small integers, then we can use
comment|// them as indexes in lookup array
name|int
index|[]
name|allTypes
init|=
operator|new
name|int
index|[]
block|{
name|Expression
operator|.
name|AND
block|,
name|Expression
operator|.
name|OR
block|,
name|Expression
operator|.
name|NOT
block|,
name|Expression
operator|.
name|EQUAL_TO
block|,
name|Expression
operator|.
name|NOT_EQUAL_TO
block|,
name|Expression
operator|.
name|LESS_THAN
block|,
name|Expression
operator|.
name|GREATER_THAN
block|,
name|Expression
operator|.
name|LESS_THAN_EQUAL_TO
block|,
name|Expression
operator|.
name|GREATER_THAN_EQUAL_TO
block|,
name|Expression
operator|.
name|BETWEEN
block|,
name|Expression
operator|.
name|IN
block|,
name|Expression
operator|.
name|LIKE
block|,
name|Expression
operator|.
name|LIKE_IGNORE_CASE
block|,
name|Expression
operator|.
name|ADD
block|,
name|Expression
operator|.
name|SUBTRACT
block|,
name|Expression
operator|.
name|MULTIPLY
block|,
name|Expression
operator|.
name|DIVIDE
block|,
name|Expression
operator|.
name|NEGATIVE
block|,
name|Expression
operator|.
name|OBJ_PATH
block|,
name|Expression
operator|.
name|DB_PATH
block|,
name|Expression
operator|.
name|LIST
block|,
name|Expression
operator|.
name|NOT_BETWEEN
block|,
name|Expression
operator|.
name|NOT_IN
block|,
name|Expression
operator|.
name|NOT_LIKE
block|,
name|Expression
operator|.
name|NOT_LIKE_IGNORE_CASE
block|,
name|Expression
operator|.
name|TRUE
block|,
name|Expression
operator|.
name|FALSE
block|,
name|Expression
operator|.
name|BITWISE_NOT
block|,
name|Expression
operator|.
name|BITWISE_AND
block|,
name|Expression
operator|.
name|BITWISE_OR
block|,
name|Expression
operator|.
name|BITWISE_XOR
block|,
name|Expression
operator|.
name|BITWISE_LEFT_SHIFT
block|,
name|Expression
operator|.
name|BITWISE_RIGHT_SHIFT
block|}
decl_stmt|;
name|int
name|max
init|=
literal|0
decl_stmt|;
name|int
name|min
init|=
literal|0
decl_stmt|;
name|int
name|allLen
init|=
name|allTypes
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|allLen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|allTypes
index|[
name|i
index|]
operator|>
name|max
condition|)
name|max
operator|=
name|allTypes
index|[
name|i
index|]
expr_stmt|;
if|else if
condition|(
name|allTypes
index|[
name|i
index|]
operator|<
name|min
condition|)
name|min
operator|=
name|allTypes
index|[
name|i
index|]
expr_stmt|;
block|}
comment|// sanity check....
if|if
condition|(
name|max
operator|>
literal|500
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Types values are too big: "
operator|+
name|max
argument_list|)
throw|;
if|if
condition|(
name|min
operator|<
literal|0
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Types values are too small: "
operator|+
name|min
argument_list|)
throw|;
comment|// now we know that if types are used as indexes,
comment|// they will fit in array "max + 1" long (though gaps are possible)
name|typeLookup
operator|=
operator|new
name|Class
index|[
name|max
operator|+
literal|1
index|]
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|AND
index|]
operator|=
name|ASTAnd
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|OR
index|]
operator|=
name|ASTOr
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|BETWEEN
index|]
operator|=
name|ASTBetween
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|NOT_BETWEEN
index|]
operator|=
name|ASTNotBetween
operator|.
name|class
expr_stmt|;
comment|// binary types
name|typeLookup
index|[
name|Expression
operator|.
name|EQUAL_TO
index|]
operator|=
name|ASTEqual
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|NOT_EQUAL_TO
index|]
operator|=
name|ASTNotEqual
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|LESS_THAN
index|]
operator|=
name|ASTLess
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|GREATER_THAN
index|]
operator|=
name|ASTGreater
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|LESS_THAN_EQUAL_TO
index|]
operator|=
name|ASTLessOrEqual
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|GREATER_THAN_EQUAL_TO
index|]
operator|=
name|ASTGreaterOrEqual
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|IN
index|]
operator|=
name|ASTIn
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|NOT_IN
index|]
operator|=
name|ASTNotIn
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|LIKE
index|]
operator|=
name|ASTLike
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|LIKE_IGNORE_CASE
index|]
operator|=
name|ASTLikeIgnoreCase
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|NOT_LIKE
index|]
operator|=
name|ASTNotLike
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|NOT_LIKE_IGNORE_CASE
index|]
operator|=
name|ASTNotLikeIgnoreCase
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|ADD
index|]
operator|=
name|ASTAdd
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|SUBTRACT
index|]
operator|=
name|ASTSubtract
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|MULTIPLY
index|]
operator|=
name|ASTMultiply
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|DIVIDE
index|]
operator|=
name|ASTDivide
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|NOT
index|]
operator|=
name|ASTNot
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|NEGATIVE
index|]
operator|=
name|ASTNegate
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|OBJ_PATH
index|]
operator|=
name|ASTObjPath
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|DB_PATH
index|]
operator|=
name|ASTDbPath
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|LIST
index|]
operator|=
name|ASTList
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|TRUE
index|]
operator|=
name|ASTTrue
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|FALSE
index|]
operator|=
name|ASTFalse
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|BITWISE_NOT
index|]
operator|=
name|ASTBitwiseNot
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|BITWISE_OR
index|]
operator|=
name|ASTBitwiseOr
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|BITWISE_AND
index|]
operator|=
name|ASTBitwiseAnd
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|BITWISE_XOR
index|]
operator|=
name|ASTBitwiseXor
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|BITWISE_LEFT_SHIFT
index|]
operator|=
name|ASTBitwiseLeftShift
operator|.
name|class
expr_stmt|;
name|typeLookup
index|[
name|Expression
operator|.
name|BITWISE_RIGHT_SHIFT
index|]
operator|=
name|ASTBitwiseRightShift
operator|.
name|class
expr_stmt|;
block|}
comment|/** 	 * Creates a new expression for the type requested. If type is unknown, 	 * ExpressionException is thrown. 	 */
specifier|public
specifier|static
name|Expression
name|expressionOfType
parameter_list|(
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|<
literal|0
operator|||
name|type
operator|>=
name|typeLookup
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|ExpressionException
argument_list|(
literal|"Bad expression type: "
operator|+
name|type
argument_list|)
throw|;
block|}
if|if
condition|(
name|typeLookup
index|[
name|type
index|]
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ExpressionException
argument_list|(
literal|"Bad expression type: "
operator|+
name|type
argument_list|)
throw|;
block|}
comment|// expected this
if|if
condition|(
name|SimpleNode
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|typeLookup
index|[
name|type
index|]
argument_list|)
condition|)
block|{
try|try
block|{
return|return
operator|(
name|Expression
operator|)
name|typeLookup
index|[
name|type
index|]
operator|.
name|newInstance
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|ExpressionException
argument_list|(
literal|"Error creating expression"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
throw|throw
operator|new
name|ExpressionException
argument_list|(
literal|"Bad expression type: "
operator|+
name|type
argument_list|)
throw|;
block|}
comment|/** 	 * Applies a few default rules for adding operands to expressions. In 	 * particular wraps all lists into LIST expressions. Applied only in path 	 * expressions. 	 */
specifier|protected
specifier|static
name|Object
name|wrapPathOperand
parameter_list|(
name|Object
name|op
parameter_list|)
block|{
if|if
condition|(
name|op
operator|instanceof
name|Collection
argument_list|<
name|?
argument_list|>
condition|)
block|{
return|return
operator|new
name|ASTList
argument_list|(
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|op
argument_list|)
return|;
block|}
if|else if
condition|(
name|op
operator|instanceof
name|Object
index|[]
condition|)
block|{
return|return
operator|new
name|ASTList
argument_list|(
operator|(
name|Object
index|[]
operator|)
name|op
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|op
return|;
block|}
block|}
comment|/** 	 * Creates an expression that matches any of the key-values pairs in 	 *<code>map</code>. 	 *<p> 	 * For each pair<code>pairType</code> operator is used to build a binary 	 * expression. Key is considered to be a DB_PATH expression. OR is used to 	 * join pair binary expressions. 	 */
specifier|public
specifier|static
name|Expression
name|matchAnyDbExp
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|map
parameter_list|,
name|int
name|pairType
parameter_list|)
block|{
name|List
argument_list|<
name|Expression
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|Expression
argument_list|>
argument_list|(
name|map
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Expression
name|exp
init|=
name|expressionOfType
argument_list|(
name|pairType
argument_list|)
decl_stmt|;
name|exp
operator|.
name|setOperand
argument_list|(
literal|0
argument_list|,
operator|new
name|ASTDbPath
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|.
name|setOperand
argument_list|(
literal|1
argument_list|,
name|wrapPathOperand
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pairs
operator|.
name|add
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
return|return
name|joinExp
argument_list|(
name|Expression
operator|.
name|OR
argument_list|,
name|pairs
argument_list|)
return|;
block|}
comment|/** 	 * Creates an expression that matches all key-values pairs in 	 *<code>map</code>. 	 *<p> 	 * For each pair<code>pairType</code> operator is used to build a binary 	 * expression. Key is considered to be a DB_PATH expression. AND is used to 	 * join pair binary expressions. 	 */
specifier|public
specifier|static
name|Expression
name|matchAllDbExp
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|map
parameter_list|,
name|int
name|pairType
parameter_list|)
block|{
name|List
argument_list|<
name|Expression
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|Expression
argument_list|>
argument_list|(
name|map
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Expression
name|exp
init|=
name|expressionOfType
argument_list|(
name|pairType
argument_list|)
decl_stmt|;
name|exp
operator|.
name|setOperand
argument_list|(
literal|0
argument_list|,
operator|new
name|ASTDbPath
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|.
name|setOperand
argument_list|(
literal|1
argument_list|,
name|wrapPathOperand
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pairs
operator|.
name|add
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
return|return
name|joinExp
argument_list|(
name|Expression
operator|.
name|AND
argument_list|,
name|pairs
argument_list|)
return|;
block|}
comment|/** 	 * Creates an expression that matches any of the key-values pairs in the 	 *<code>map</code>. 	 *<p> 	 * For each pair<code>pairType</code> operator is used to build a binary 	 * expression. Key is considered to be a OBJ_PATH expression. OR is used to 	 * join pair binary expressions. 	 */
specifier|public
specifier|static
name|Expression
name|matchAnyExp
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|map
parameter_list|,
name|int
name|pairType
parameter_list|)
block|{
name|List
argument_list|<
name|Expression
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|Expression
argument_list|>
argument_list|(
name|map
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Expression
name|exp
init|=
name|expressionOfType
argument_list|(
name|pairType
argument_list|)
decl_stmt|;
name|exp
operator|.
name|setOperand
argument_list|(
literal|0
argument_list|,
operator|new
name|ASTObjPath
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|.
name|setOperand
argument_list|(
literal|1
argument_list|,
name|wrapPathOperand
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pairs
operator|.
name|add
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
return|return
name|joinExp
argument_list|(
name|Expression
operator|.
name|OR
argument_list|,
name|pairs
argument_list|)
return|;
block|}
comment|/** 	 * Creates an expression to match a collection of values against a single 	 * path expression.<h3>Splits</h3> 	 *<p> 	 * Note that "path" argument here can use a split character (a pipe symbol - 	 * '|') instead of dot to indicate that relationship following a path should 	 * be split into a separate set of joins. There can only be one split at 	 * most. Split must always precede a relationship. E.g. 	 * "|exhibits.paintings", "exhibits|paintings", etc. 	 *  	 * @param path 	 * @param values 	 * @since 3.0 	 */
specifier|public
specifier|static
name|Expression
name|matchAllExp
parameter_list|(
name|String
name|path
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|values
parameter_list|)
block|{
if|if
condition|(
name|values
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Null values collection"
argument_list|)
throw|;
block|}
if|if
condition|(
name|values
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|ASTTrue
argument_list|()
return|;
block|}
return|return
name|matchAllExp
argument_list|(
name|path
argument_list|,
name|values
operator|.
name|toArray
argument_list|()
argument_list|)
return|;
block|}
comment|/** 	 * @since 3.0 	 */
specifier|public
specifier|static
name|Expression
name|matchAllExp
parameter_list|(
name|String
name|path
parameter_list|,
name|Object
modifier|...
name|values
parameter_list|)
block|{
if|if
condition|(
name|values
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Null values collection"
argument_list|)
throw|;
block|}
if|if
condition|(
name|values
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|ASTTrue
argument_list|()
return|;
block|}
name|int
name|split
init|=
name|path
operator|.
name|indexOf
argument_list|(
name|SPLIT_SEPARATOR
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Expression
argument_list|>
name|matches
init|=
operator|new
name|ArrayList
argument_list|<
name|Expression
argument_list|>
argument_list|(
name|values
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|split
operator|>=
literal|0
operator|&&
name|split
operator|<
name|path
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
name|int
name|splitEnd
init|=
name|path
operator|.
name|indexOf
argument_list|(
name|Entity
operator|.
name|PATH_SEPARATOR
argument_list|,
name|split
operator|+
literal|1
argument_list|)
decl_stmt|;
name|String
name|beforeSplit
init|=
name|split
operator|>
literal|0
condition|?
name|path
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|split
argument_list|)
operator|+
literal|"."
else|:
literal|""
decl_stmt|;
name|String
name|afterSplit
init|=
name|splitEnd
operator|>
literal|0
condition|?
literal|"."
operator|+
name|path
operator|.
name|substring
argument_list|(
name|splitEnd
operator|+
literal|1
argument_list|)
else|:
literal|""
decl_stmt|;
name|String
name|aliasBase
init|=
literal|"split"
operator|+
name|autoAliasId
operator|++
operator|+
literal|"_"
decl_stmt|;
name|String
name|splitChunk
init|=
name|splitEnd
operator|>
literal|0
condition|?
name|path
operator|.
name|substring
argument_list|(
name|split
operator|+
literal|1
argument_list|,
name|splitEnd
argument_list|)
else|:
name|path
operator|.
name|substring
argument_list|(
name|split
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|// fix the path - replace split with dot if it's in the middle, or
comment|// strip it if
comment|// it's in the beginning
name|path
operator|=
name|split
operator|==
literal|0
condition|?
name|path
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
else|:
name|path
operator|.
name|replace
argument_list|(
name|SPLIT_SEPARATOR
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Object
name|value
range|:
name|values
control|)
block|{
name|String
name|alias
init|=
name|aliasBase
operator|+
name|i
decl_stmt|;
name|String
name|aliasedPath
init|=
name|beforeSplit
operator|+
name|alias
operator|+
name|afterSplit
decl_stmt|;
name|i
operator|++
expr_stmt|;
name|ASTPath
name|pathExp
init|=
operator|new
name|ASTObjPath
argument_list|(
name|aliasedPath
argument_list|)
decl_stmt|;
name|pathExp
operator|.
name|setPathAliases
argument_list|(
name|Collections
operator|.
name|singletonMap
argument_list|(
name|alias
argument_list|,
name|splitChunk
argument_list|)
argument_list|)
expr_stmt|;
name|matches
operator|.
name|add
argument_list|(
operator|new
name|ASTEqual
argument_list|(
name|pathExp
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|Object
name|value
range|:
name|values
control|)
block|{
name|matches
operator|.
name|add
argument_list|(
operator|new
name|ASTEqual
argument_list|(
operator|new
name|ASTObjPath
argument_list|(
name|path
argument_list|)
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|joinExp
argument_list|(
name|Expression
operator|.
name|AND
argument_list|,
name|matches
argument_list|)
return|;
block|}
comment|/** 	 * Creates an expression that matches all key-values pairs in 	 *<code>map</code>. 	 *<p> 	 * For each pair<code>pairType</code> operator is used to build a binary 	 * expression. Key is considered to be a OBJ_PATH expression. AND is used to 	 * join pair binary expressions. 	 */
specifier|public
specifier|static
name|Expression
name|matchAllExp
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|map
parameter_list|,
name|int
name|pairType
parameter_list|)
block|{
name|List
argument_list|<
name|Expression
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|Expression
argument_list|>
argument_list|(
name|map
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Expression
name|exp
init|=
name|expressionOfType
argument_list|(
name|pairType
argument_list|)
decl_stmt|;
name|exp
operator|.
name|setOperand
argument_list|(
literal|0
argument_list|,
operator|new
name|ASTObjPath
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|.
name|setOperand
argument_list|(
literal|1
argument_list|,
name|wrapPathOperand
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pairs
operator|.
name|add
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
return|return
name|joinExp
argument_list|(
name|Expression
operator|.
name|AND
argument_list|,
name|pairs
argument_list|)
return|;
block|}
comment|/** 	 * A convenience method to create an DB_PATH "equal to" expression. 	 */
specifier|public
specifier|static
name|Expression
name|matchDbExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
operator|new
name|ASTEqual
argument_list|(
operator|new
name|ASTDbPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** 	 * A convenience method to create an DB_PATH "not equal to" expression. 	 */
specifier|public
specifier|static
name|Expression
name|noMatchDbExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
operator|new
name|ASTNotEqual
argument_list|(
operator|new
name|ASTDbPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** 	 * A convenience method to create an OBJ_PATH "equal to" expression. 	 */
specifier|public
specifier|static
name|Expression
name|matchExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
operator|new
name|ASTEqual
argument_list|(
operator|new
name|ASTObjPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** 	 * A convenience method to create an OBJ_PATH "not equal to" expression. 	 */
specifier|public
specifier|static
name|Expression
name|noMatchExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
operator|new
name|ASTNotEqual
argument_list|(
operator|new
name|ASTObjPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** 	 * A convenience method to create an OBJ_PATH "less than" expression. 	 */
specifier|public
specifier|static
name|Expression
name|lessExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
operator|new
name|ASTLess
argument_list|(
operator|new
name|ASTObjPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** 	 * A convenience method to create an DB_PATH "less than" expression. 	 *  	 * @since 3.0 	 */
specifier|public
specifier|static
name|Expression
name|lessDbExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
operator|new
name|ASTLess
argument_list|(
operator|new
name|ASTDbPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** 	 * A convenience method to create an OBJ_PATH "less than or equal to" 	 * expression. 	 */
specifier|public
specifier|static
name|Expression
name|lessOrEqualExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
operator|new
name|ASTLessOrEqual
argument_list|(
operator|new
name|ASTObjPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** 	 * A convenience method to create an DB_PATH "less than or equal to" 	 * expression. 	 *  	 * @since 3.0 	 */
specifier|public
specifier|static
name|Expression
name|lessOrEqualDbExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
operator|new
name|ASTLessOrEqual
argument_list|(
operator|new
name|ASTDbPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** 	 * A convenience method to create an OBJ_PATH "greater than" expression. 	 */
specifier|public
specifier|static
name|Expression
name|greaterExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
operator|new
name|ASTGreater
argument_list|(
operator|new
name|ASTObjPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** 	 * A convenience method to create an DB_PATH "greater than" expression. 	 *  	 * @since 3.0 	 */
specifier|public
specifier|static
name|Expression
name|greaterDbExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
operator|new
name|ASTGreater
argument_list|(
operator|new
name|ASTDbPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** 	 * A convenience method to create an OBJ_PATH "greater than or equal to" 	 * expression. 	 */
specifier|public
specifier|static
name|Expression
name|greaterOrEqualExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
operator|new
name|ASTGreaterOrEqual
argument_list|(
operator|new
name|ASTObjPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** 	 * A convenience method to create an DB_PATH "greater than or equal to" 	 * expression. 	 *  	 * @since 3.0 	 */
specifier|public
specifier|static
name|Expression
name|greaterOrEqualDbExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
operator|new
name|ASTGreaterOrEqual
argument_list|(
operator|new
name|ASTDbPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** 	 * A convenience shortcut for building IN expression. Return ASTFalse for 	 * empty collection. 	 */
specifier|public
specifier|static
name|Expression
name|inExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
modifier|...
name|values
parameter_list|)
block|{
if|if
condition|(
name|values
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|ASTFalse
argument_list|()
return|;
block|}
return|return
operator|new
name|ASTIn
argument_list|(
operator|new
name|ASTObjPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
operator|new
name|ASTList
argument_list|(
name|values
argument_list|)
argument_list|)
return|;
block|}
comment|/** 	 * A convenience shortcut for building IN DB expression. Return ASTFalse for 	 * empty collection. 	 */
specifier|public
specifier|static
name|Expression
name|inDbExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
modifier|...
name|values
parameter_list|)
block|{
if|if
condition|(
name|values
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|ASTFalse
argument_list|()
return|;
block|}
return|return
operator|new
name|ASTIn
argument_list|(
operator|new
name|ASTDbPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
operator|new
name|ASTList
argument_list|(
name|values
argument_list|)
argument_list|)
return|;
block|}
comment|/** 	 * A convenience shortcut for building IN expression. Return ASTFalse for 	 * empty collection. 	 */
specifier|public
specifier|static
name|Expression
name|inExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|values
parameter_list|)
block|{
if|if
condition|(
name|values
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
operator|new
name|ASTFalse
argument_list|()
return|;
block|}
return|return
operator|new
name|ASTIn
argument_list|(
operator|new
name|ASTObjPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
operator|new
name|ASTList
argument_list|(
name|values
argument_list|)
argument_list|)
return|;
block|}
comment|/** 	 * A convenience shortcut for building IN DB expression. Return ASTFalse for 	 * empty collection. 	 */
specifier|public
specifier|static
name|Expression
name|inDbExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|values
parameter_list|)
block|{
if|if
condition|(
name|values
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
operator|new
name|ASTFalse
argument_list|()
return|;
block|}
return|return
operator|new
name|ASTIn
argument_list|(
operator|new
name|ASTDbPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
operator|new
name|ASTList
argument_list|(
name|values
argument_list|)
argument_list|)
return|;
block|}
comment|/** 	 * A convenience shortcut for building NOT_IN expression. Return ASTTrue for 	 * empty collection. 	 */
specifier|public
specifier|static
name|Expression
name|notInExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|values
parameter_list|)
block|{
if|if
condition|(
name|values
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
operator|new
name|ASTTrue
argument_list|()
return|;
block|}
return|return
operator|new
name|ASTNotIn
argument_list|(
operator|new
name|ASTObjPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
operator|new
name|ASTList
argument_list|(
name|values
argument_list|)
argument_list|)
return|;
block|}
comment|/** 	 * A convenience shortcut for building NOT_IN expression. Return ASTTrue for 	 * empty collection. 	 *  	 * @since 3.0 	 */
specifier|public
specifier|static
name|Expression
name|notInDbExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|values
parameter_list|)
block|{
if|if
condition|(
name|values
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
operator|new
name|ASTTrue
argument_list|()
return|;
block|}
return|return
operator|new
name|ASTNotIn
argument_list|(
operator|new
name|ASTDbPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
operator|new
name|ASTList
argument_list|(
name|values
argument_list|)
argument_list|)
return|;
block|}
comment|/** 	 * A convenience shortcut for building NOT_IN expression. Return ASTTrue for 	 * empty collection. 	 *  	 * @since 1.0.6 	 */
specifier|public
specifier|static
name|Expression
name|notInExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
modifier|...
name|values
parameter_list|)
block|{
if|if
condition|(
name|values
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|ASTTrue
argument_list|()
return|;
block|}
return|return
operator|new
name|ASTNotIn
argument_list|(
operator|new
name|ASTObjPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
operator|new
name|ASTList
argument_list|(
name|values
argument_list|)
argument_list|)
return|;
block|}
comment|/** 	 * A convenience shortcut for building NOT_IN expression. Return ASTTrue for 	 * empty collection. 	 *  	 * @since 3.0 	 */
specifier|public
specifier|static
name|Expression
name|notInDbExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
modifier|...
name|values
parameter_list|)
block|{
if|if
condition|(
name|values
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|ASTTrue
argument_list|()
return|;
block|}
return|return
operator|new
name|ASTNotIn
argument_list|(
operator|new
name|ASTDbPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
operator|new
name|ASTList
argument_list|(
name|values
argument_list|)
argument_list|)
return|;
block|}
comment|/** 	 * A convenience shortcut for building BETWEEN expressions. 	 */
specifier|public
specifier|static
name|Expression
name|betweenExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value1
parameter_list|,
name|Object
name|value2
parameter_list|)
block|{
return|return
operator|new
name|ASTBetween
argument_list|(
operator|new
name|ASTObjPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value1
argument_list|,
name|value2
argument_list|)
return|;
block|}
comment|/** 	 * A convenience shortcut for building BETWEEN expressions. 	 *  	 * @since 3.0 	 */
specifier|public
specifier|static
name|Expression
name|betweenDbExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value1
parameter_list|,
name|Object
name|value2
parameter_list|)
block|{
return|return
operator|new
name|ASTBetween
argument_list|(
operator|new
name|ASTDbPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value1
argument_list|,
name|value2
argument_list|)
return|;
block|}
comment|/** 	 * A convenience shortcut for building NOT_BETWEEN expressions. 	 */
specifier|public
specifier|static
name|Expression
name|notBetweenExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value1
parameter_list|,
name|Object
name|value2
parameter_list|)
block|{
return|return
operator|new
name|ASTNotBetween
argument_list|(
operator|new
name|ASTObjPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value1
argument_list|,
name|value2
argument_list|)
return|;
block|}
comment|/** 	 * A convenience shortcut for building NOT_BETWEEN expressions. 	 *  	 * @since 3.0 	 */
specifier|public
specifier|static
name|Expression
name|notBetweenDbExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value1
parameter_list|,
name|Object
name|value2
parameter_list|)
block|{
return|return
operator|new
name|ASTNotBetween
argument_list|(
operator|new
name|ASTDbPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value1
argument_list|,
name|value2
argument_list|)
return|;
block|}
comment|/** 	 * A convenience shortcut for building LIKE expression. 	 */
specifier|public
specifier|static
name|Expression
name|likeExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
name|likeExpInternal
argument_list|(
name|pathSpec
argument_list|,
name|value
argument_list|,
operator|(
name|char
operator|)
literal|0
argument_list|)
return|;
block|}
comment|/** 	 *<p> 	 * A convenience shortcut for building LIKE expression. 	 *</p> 	 *<p> 	 * The escape character allows for escaping meta-characters in the LIKE 	 * clause. Note that the escape character cannot be '?'. To specify no 	 * escape character, supply 0 as the escape character. 	 *</p> 	 *  	 * @since 3.0.1 	 */
specifier|public
specifier|static
name|Expression
name|likeExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|,
name|char
name|escapeChar
parameter_list|)
block|{
return|return
name|likeExpInternal
argument_list|(
name|pathSpec
argument_list|,
name|value
argument_list|,
name|escapeChar
argument_list|)
return|;
block|}
specifier|static
name|ASTLike
name|likeExpInternal
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|,
name|char
name|escapeChar
parameter_list|)
block|{
return|return
operator|new
name|ASTLike
argument_list|(
operator|new
name|ASTObjPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|,
name|escapeChar
argument_list|)
return|;
block|}
comment|/** 	 * A convenience shortcut for building LIKE DB_PATH expression. 	 *  	 * @since 3.0 	 */
specifier|public
specifier|static
name|Expression
name|likeDbExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
operator|new
name|ASTLike
argument_list|(
operator|new
name|ASTDbPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** 	 *<p> 	 * A convenience shortcut for building LIKE DB_PATH expression. 	 *</p> 	 *<p> 	 * The escape character allows for escaping meta-characters in the LIKE 	 * clause. Note that the escape character cannot be '?'. To specify no 	 * escape character, supply 0 as the escape character. 	 *</p> 	 *  	 * @since 3.0.1 	 */
specifier|public
specifier|static
name|Expression
name|likeDbExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|,
name|char
name|escapeChar
parameter_list|)
block|{
return|return
operator|new
name|ASTLike
argument_list|(
operator|new
name|ASTDbPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|,
name|escapeChar
argument_list|)
return|;
block|}
comment|/** 	 * A convenience shortcut for building NOT_LIKE expression. 	 */
specifier|public
specifier|static
name|Expression
name|notLikeExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
operator|new
name|ASTNotLike
argument_list|(
operator|new
name|ASTObjPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** 	 *<p> 	 * A convenience shortcut for building NOT_LIKE expression. 	 *</p> 	 *<p> 	 * The escape character allows for escaping meta-characters in the LIKE 	 * clause. Note that the escape character cannot be '?'. To specify no 	 * escape character, supply 0 as the escape character. 	 *</p> 	 *  	 * @since 3.0.1 	 */
specifier|public
specifier|static
name|Expression
name|notLikeExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|,
name|char
name|escapeChar
parameter_list|)
block|{
return|return
operator|new
name|ASTNotLike
argument_list|(
operator|new
name|ASTObjPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|,
name|escapeChar
argument_list|)
return|;
block|}
comment|/** 	 * A convenience shortcut for building NOT_LIKE expression. 	 *  	 * @since 3.0 	 */
specifier|public
specifier|static
name|Expression
name|notLikeDbExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
operator|new
name|ASTNotLike
argument_list|(
operator|new
name|ASTDbPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** 	 *<p> 	 * A convenience shortcut for building NOT_LIKE expression. 	 *</p> 	 *<p> 	 * The escape character allows for escaping meta-characters in the LIKE 	 * clause. Note that the escape character cannot be '?'. To specify no 	 * escape character, supply 0 as the escape character. 	 *</p> 	 *  	 * @since 3.0.1 	 */
specifier|public
specifier|static
name|Expression
name|notLikeDbExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|,
name|char
name|escapeChar
parameter_list|)
block|{
return|return
operator|new
name|ASTNotLike
argument_list|(
operator|new
name|ASTDbPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|,
name|escapeChar
argument_list|)
return|;
block|}
comment|/** 	 * A convenience shortcut for building LIKE_IGNORE_CASE expression. 	 */
specifier|public
specifier|static
name|Expression
name|likeIgnoreCaseExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
name|likeIgnoreCaseExpInternal
argument_list|(
name|pathSpec
argument_list|,
name|value
argument_list|,
operator|(
name|char
operator|)
literal|0
argument_list|)
return|;
block|}
comment|/** 	 *<p> 	 * A convenience shortcut for building LIKE_IGNORE_CASE expression. 	 *</p> 	 *<p> 	 * The escape character allows for escaping meta-characters in the LIKE 	 * clause. Note that the escape character cannot be '?'. To specify no 	 * escape character, supply 0 as the escape character. 	 *</p> 	 *  	 * @since 3.0.1 	 */
specifier|public
specifier|static
name|Expression
name|likeIgnoreCaseExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|,
name|char
name|escapeChar
parameter_list|)
block|{
return|return
name|likeIgnoreCaseExpInternal
argument_list|(
name|pathSpec
argument_list|,
name|value
argument_list|,
name|escapeChar
argument_list|)
return|;
block|}
specifier|static
name|ASTLikeIgnoreCase
name|likeIgnoreCaseExpInternal
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|,
name|char
name|escapeChar
parameter_list|)
block|{
return|return
operator|new
name|ASTLikeIgnoreCase
argument_list|(
operator|new
name|ASTObjPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|,
name|escapeChar
argument_list|)
return|;
block|}
comment|/** 	 * A convenience shortcut for building LIKE_IGNORE_CASE expression. 	 *  	 * @since 3.0 	 */
specifier|public
specifier|static
name|Expression
name|likeIgnoreCaseDbExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
operator|new
name|ASTLikeIgnoreCase
argument_list|(
operator|new
name|ASTDbPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** 	 *<p> 	 * A convenience shortcut for building LIKE_IGNORE_CASE expression. 	 *</p> 	 *<p> 	 * The escape character allows for escaping meta-characters in the LIKE 	 * clause. Note that the escape character cannot be '?'. To specify no 	 * escape character, supply 0 as the escape character. 	 *</p> 	 *  	 * @since 3.0.1 	 */
specifier|public
specifier|static
name|Expression
name|likeIgnoreCaseDbExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|,
name|char
name|escapeChar
parameter_list|)
block|{
return|return
operator|new
name|ASTLikeIgnoreCase
argument_list|(
operator|new
name|ASTDbPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|,
name|escapeChar
argument_list|)
return|;
block|}
comment|/** 	 * A convenience shortcut for building NOT_LIKE_IGNORE_CASE expression. 	 */
specifier|public
specifier|static
name|Expression
name|notLikeIgnoreCaseExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
operator|new
name|ASTNotLikeIgnoreCase
argument_list|(
operator|new
name|ASTObjPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** 	 *<p> 	 * A convenience shortcut for building NOT_LIKE_IGNORE_CASE expression. 	 *</p> 	 *<p> 	 * The escape character allows for escaping meta-characters in the LIKE 	 * clause. Note that the escape character cannot be '?'. To specify no 	 * escape character, supply 0 as the escape character. 	 *</p> 	 *  	 * @since 3.0.1 	 */
specifier|public
specifier|static
name|Expression
name|notLikeIgnoreCaseExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|,
name|char
name|escapeChar
parameter_list|)
block|{
return|return
operator|new
name|ASTNotLikeIgnoreCase
argument_list|(
operator|new
name|ASTObjPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|,
name|escapeChar
argument_list|)
return|;
block|}
comment|/** 	 * A convenience shortcut for building NOT_LIKE_IGNORE_CASE expression. 	 *  	 * @since 3.0 	 */
specifier|public
specifier|static
name|Expression
name|notLikeIgnoreCaseDbExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
operator|new
name|ASTNotLikeIgnoreCase
argument_list|(
operator|new
name|ASTDbPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** 	 *<p> 	 * A convenience shortcut for building NOT_LIKE_IGNORE_CASE expression. 	 *</p> 	 *<p> 	 * The escape character allows for escaping meta-characters in the LIKE 	 * clause. Note that the escape character cannot be '?'. To specify no 	 * escape character, supply 0 as the escape character. 	 *</p> 	 *  	 * @since 3.0.1 	 */
specifier|public
specifier|static
name|Expression
name|notLikeIgnoreCaseDbExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|Object
name|value
parameter_list|,
name|char
name|escapeChar
parameter_list|)
block|{
return|return
operator|new
name|ASTNotLikeIgnoreCase
argument_list|(
operator|new
name|ASTDbPath
argument_list|(
name|pathSpec
argument_list|)
argument_list|,
name|value
argument_list|,
name|escapeChar
argument_list|)
return|;
block|}
comment|/** 	 * @return An expression for a database "LIKE" query with the value 	 *         converted to a pattern matching anywhere in the String. 	 * @since 4.0 	 */
specifier|public
specifier|static
name|Expression
name|containsExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|String
name|value
parameter_list|)
block|{
name|ASTLike
name|like
init|=
name|likeExpInternal
argument_list|(
name|pathSpec
argument_list|,
name|value
argument_list|,
operator|(
name|char
operator|)
literal|0
argument_list|)
decl_stmt|;
name|LikeExpressionHelper
operator|.
name|toContains
argument_list|(
name|like
argument_list|)
expr_stmt|;
return|return
name|like
return|;
block|}
comment|/** 	 * @return An expression for a database "LIKE" query with the value 	 *         converted to a pattern matching the beginning of the String. 	 * @since 4.0 	 */
specifier|public
specifier|static
name|Expression
name|startsWithExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|String
name|value
parameter_list|)
block|{
name|ASTLike
name|like
init|=
name|likeExpInternal
argument_list|(
name|pathSpec
argument_list|,
name|value
argument_list|,
operator|(
name|char
operator|)
literal|0
argument_list|)
decl_stmt|;
name|LikeExpressionHelper
operator|.
name|toStartsWith
argument_list|(
name|like
argument_list|)
expr_stmt|;
return|return
name|like
return|;
block|}
comment|/** 	 * @return An expression for a database "LIKE" query with the value 	 *         converted to a pattern matching the beginning of the String. 	 * @since 4.0 	 */
specifier|public
specifier|static
name|Expression
name|endsWithExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|String
name|value
parameter_list|)
block|{
name|ASTLike
name|like
init|=
name|likeExpInternal
argument_list|(
name|pathSpec
argument_list|,
name|value
argument_list|,
operator|(
name|char
operator|)
literal|0
argument_list|)
decl_stmt|;
name|LikeExpressionHelper
operator|.
name|toEndsWith
argument_list|(
name|like
argument_list|)
expr_stmt|;
return|return
name|like
return|;
block|}
comment|/** 	 * Same as {@link #containsExp(String, String)} only using case-insensitive 	 * comparison. 	 *  	 * @since 4.0 	 */
specifier|public
specifier|static
name|Expression
name|containsIgnoreCaseExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|String
name|value
parameter_list|)
block|{
name|ASTLikeIgnoreCase
name|like
init|=
name|likeIgnoreCaseExpInternal
argument_list|(
name|pathSpec
argument_list|,
name|value
argument_list|,
operator|(
name|char
operator|)
literal|0
argument_list|)
decl_stmt|;
name|LikeExpressionHelper
operator|.
name|toContains
argument_list|(
name|like
argument_list|)
expr_stmt|;
return|return
name|like
return|;
block|}
comment|/** 	 * Same as {@link #startsWithExp(String, String)} only using 	 * case-insensitive comparison. 	 *  	 * @since 4.0 	 */
specifier|public
specifier|static
name|Expression
name|startsWithIgnoreCaseExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|String
name|value
parameter_list|)
block|{
name|ASTLikeIgnoreCase
name|like
init|=
name|likeIgnoreCaseExpInternal
argument_list|(
name|pathSpec
argument_list|,
name|value
argument_list|,
operator|(
name|char
operator|)
literal|0
argument_list|)
decl_stmt|;
name|LikeExpressionHelper
operator|.
name|toStartsWith
argument_list|(
name|like
argument_list|)
expr_stmt|;
return|return
name|like
return|;
block|}
comment|/** 	 * Same as {@link #endsWithExp(String, String)} only using case-insensitive 	 * comparison. 	 *  	 * @since 4.0 	 */
specifier|public
specifier|static
name|Expression
name|endsWithIgnoreCaseExp
parameter_list|(
name|String
name|pathSpec
parameter_list|,
name|String
name|value
parameter_list|)
block|{
name|ASTLikeIgnoreCase
name|like
init|=
name|likeIgnoreCaseExpInternal
argument_list|(
name|pathSpec
argument_list|,
name|value
argument_list|,
operator|(
name|char
operator|)
literal|0
argument_list|)
decl_stmt|;
name|LikeExpressionHelper
operator|.
name|toEndsWith
argument_list|(
name|like
argument_list|)
expr_stmt|;
return|return
name|like
return|;
block|}
comment|/** 	 * @param pathSpec a String "obj:" path. 	 * @since 4.0 	 * @return a new "obj:" path expression for the specified String path. 	 */
specifier|public
specifier|static
name|Expression
name|pathExp
parameter_list|(
name|String
name|pathSpec
parameter_list|)
block|{
return|return
operator|new
name|ASTObjPath
argument_list|(
name|pathSpec
argument_list|)
return|;
block|}
comment|/** 	 * @param pathSpec a String db: path. 	 * @since 4.0 	 * @return a new "db:" path expression for the specified String path. 	 */
specifier|public
specifier|static
name|Expression
name|dbPathExp
parameter_list|(
name|String
name|pathSpec
parameter_list|)
block|{
return|return
operator|new
name|ASTDbPath
argument_list|(
name|pathSpec
argument_list|)
return|;
block|}
comment|/** 	 * A convenience shortcut for boolean true expression. 	 *  	 * @since 3.0 	 */
specifier|public
specifier|static
name|Expression
name|expTrue
parameter_list|()
block|{
return|return
operator|new
name|ASTTrue
argument_list|()
return|;
block|}
comment|/** 	 * A convenience shortcut for boolean false expression. 	 *  	 * @since 3.0 	 */
specifier|public
specifier|static
name|Expression
name|expFalse
parameter_list|()
block|{
return|return
operator|new
name|ASTFalse
argument_list|()
return|;
block|}
comment|/** 	 * Joins all expressions, making a single expression.<code>type</code> is 	 * used as an expression type for expressions joining each one of the items 	 * on the list.<code>type</code> must be binary expression type. 	 *<p> 	 * For example, if type is Expression.AND, resulting expression would match 	 * all expressions in the list. If type is Expression.OR, resulting 	 * expression would match any of the expressions. 	 *</p> 	 */
specifier|public
specifier|static
name|Expression
name|joinExp
parameter_list|(
name|int
name|type
parameter_list|,
name|Collection
argument_list|<
name|Expression
argument_list|>
name|expressions
parameter_list|)
block|{
name|int
name|len
init|=
name|expressions
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|join
argument_list|(
name|type
argument_list|,
name|expressions
operator|.
name|toArray
argument_list|(
operator|new
name|Expression
index|[
name|len
index|]
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|Expression
name|join
parameter_list|(
name|int
name|type
parameter_list|,
name|Expression
modifier|...
name|expressions
parameter_list|)
block|{
name|int
name|len
init|=
name|expressions
operator|!=
literal|null
condition|?
name|expressions
operator|.
name|length
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Expression
name|currentExp
init|=
name|expressions
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
return|return
name|currentExp
return|;
block|}
name|Expression
name|exp
init|=
name|expressionOfType
argument_list|(
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|exp
operator|.
name|setOperand
argument_list|(
name|i
argument_list|,
name|expressions
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|exp
return|;
block|}
comment|/** 	 * Creates an expression that matches the primary key of object in 	 *<code>ObjectId</code>'s<code>IdSnapshot</code> for the argument 	 *<code>object</code>. 	 */
specifier|public
specifier|static
name|Expression
name|matchExp
parameter_list|(
name|Persistent
name|object
parameter_list|)
block|{
return|return
name|matchAllDbExp
argument_list|(
name|object
operator|.
name|getObjectId
argument_list|()
operator|.
name|getIdSnapshot
argument_list|()
argument_list|,
name|Expression
operator|.
name|EQUAL_TO
argument_list|)
return|;
block|}
comment|/** 	 * Creates an expression that matches any of the objects contained in the 	 * list<code>objects</code> 	 */
specifier|public
specifier|static
name|Expression
name|matchAnyExp
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Persistent
argument_list|>
name|objects
parameter_list|)
block|{
if|if
condition|(
name|objects
operator|==
literal|null
operator|||
name|objects
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|expFalse
argument_list|()
return|;
block|}
return|return
name|matchAnyExp
argument_list|(
name|objects
operator|.
name|toArray
argument_list|(
operator|new
name|Persistent
index|[
name|objects
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
comment|/** 	 * Creates an expression that matches any of the objects contained in the 	 *<code>objects</code> array 	 */
specifier|public
specifier|static
name|Expression
name|matchAnyExp
parameter_list|(
name|Persistent
modifier|...
name|objects
parameter_list|)
block|{
if|if
condition|(
name|objects
operator|==
literal|null
operator|||
name|objects
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|expFalse
argument_list|()
return|;
block|}
name|List
argument_list|<
name|Expression
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|Expression
argument_list|>
argument_list|(
name|objects
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|Persistent
name|object
range|:
name|objects
control|)
block|{
name|pairs
operator|.
name|add
argument_list|(
name|matchExp
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|joinExp
argument_list|(
name|Expression
operator|.
name|OR
argument_list|,
name|pairs
argument_list|)
return|;
block|}
comment|/** 	 * @since 4.0 	 */
specifier|public
specifier|static
name|Expression
name|and
parameter_list|(
name|Collection
argument_list|<
name|Expression
argument_list|>
name|expressions
parameter_list|)
block|{
return|return
name|joinExp
argument_list|(
name|Expression
operator|.
name|AND
argument_list|,
name|expressions
argument_list|)
return|;
block|}
comment|/** 	 * @since 4.0 	 */
specifier|public
specifier|static
name|Expression
name|and
parameter_list|(
name|Expression
modifier|...
name|expressions
parameter_list|)
block|{
return|return
name|join
argument_list|(
name|Expression
operator|.
name|AND
argument_list|,
name|expressions
argument_list|)
return|;
block|}
comment|/** 	 * @since 4.0 	 */
specifier|public
specifier|static
name|Expression
name|or
parameter_list|(
name|Collection
argument_list|<
name|Expression
argument_list|>
name|expressions
parameter_list|)
block|{
return|return
name|joinExp
argument_list|(
name|Expression
operator|.
name|OR
argument_list|,
name|expressions
argument_list|)
return|;
block|}
comment|/** 	 * @since 4.0 	 */
specifier|public
specifier|static
name|Expression
name|or
parameter_list|(
name|Expression
modifier|...
name|expressions
parameter_list|)
block|{
return|return
name|join
argument_list|(
name|Expression
operator|.
name|OR
argument_list|,
name|expressions
argument_list|)
return|;
block|}
comment|/** 	 * Parses string, converting it to Expression and optionally binding 	 * positional parameters. If a string does not represent a semantically 	 * correct expression, an ExpressionException is thrown. 	 *<p> 	 * Binding of parameters by name (as opposed to binding by position) can be 	 * achieved by chaining this call with {@link Expression#params(Map)}. 	 *  	 * @since 4.0 	 */
specifier|public
specifier|static
name|Expression
name|exp
parameter_list|(
name|String
name|expressionString
parameter_list|,
name|Object
modifier|...
name|parameters
parameter_list|)
block|{
name|Expression
name|e
init|=
name|fromString
argument_list|(
name|expressionString
argument_list|)
decl_stmt|;
if|if
condition|(
name|parameters
operator|!=
literal|null
operator|&&
name|parameters
operator|.
name|length
operator|>
literal|0
condition|)
block|{
comment|// apply parameters in-place... it is wasteful to clone the
comment|// expression that hasn't been exposed to the callers
name|e
operator|.
name|inPlaceParamsArray
argument_list|(
name|parameters
argument_list|)
expr_stmt|;
block|}
return|return
name|e
return|;
block|}
comment|/** 	 * Parses string, converting it to Expression. If string does not represent 	 * a semantically correct expression, an ExpressionException is thrown. 	 *  	 * @since 4.0 	 */
specifier|private
specifier|static
name|Expression
name|fromString
parameter_list|(
name|String
name|expressionString
parameter_list|)
block|{
if|if
condition|(
name|expressionString
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Null expression string."
argument_list|)
throw|;
block|}
comment|// optimizing parser buffers per CAY-1667...
comment|// adding 1 extra char to the buffer size above the String length, as
comment|// otherwise resizing still occurs at the end of the stream
name|int
name|bufferSize
init|=
name|expressionString
operator|.
name|length
argument_list|()
operator|>
name|PARSE_BUFFER_MAX_SIZE
condition|?
name|PARSE_BUFFER_MAX_SIZE
else|:
name|expressionString
operator|.
name|length
argument_list|()
operator|+
literal|1
decl_stmt|;
name|Reader
name|reader
init|=
operator|new
name|StringReader
argument_list|(
name|expressionString
argument_list|)
decl_stmt|;
name|JavaCharStream
name|stream
init|=
operator|new
name|JavaCharStream
argument_list|(
name|reader
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|bufferSize
argument_list|)
decl_stmt|;
name|ExpressionParserTokenManager
name|tm
init|=
operator|new
name|ExpressionParserTokenManager
argument_list|(
name|stream
argument_list|)
decl_stmt|;
name|ExpressionParser
name|parser
init|=
operator|new
name|ExpressionParser
argument_list|(
name|tm
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|parser
operator|.
name|expression
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|ex
parameter_list|)
block|{
comment|// can be null
name|String
name|message
init|=
name|ex
operator|.
name|getMessage
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|ExpressionException
argument_list|(
name|message
operator|!=
literal|null
condition|?
name|message
else|:
literal|""
argument_list|,
name|ex
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|th
parameter_list|)
block|{
comment|// can be null
name|String
name|message
init|=
name|th
operator|.
name|getMessage
argument_list|()
decl_stmt|;
comment|// another common error is TokenManagerError
throw|throw
operator|new
name|ExpressionException
argument_list|(
name|message
operator|!=
literal|null
condition|?
name|message
else|:
literal|""
argument_list|,
name|th
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

