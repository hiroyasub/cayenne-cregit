begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************  *   Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *    https://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing,  *  software distributed under the License is distributed on an  *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *  KIND, either express or implied.  See the License for the  *  specific language governing permissions and limitations  *  under the License.  ****************************************************************/
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|access
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|CayenneRuntimeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|DataObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|DataRow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|ObjectContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|ObjectId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|PersistenceState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|Persistent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|access
operator|.
name|ObjectDiff
operator|.
name|ArcOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|access
operator|.
name|event
operator|.
name|SnapshotEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|access
operator|.
name|event
operator|.
name|SnapshotEventListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|ArcId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|ChildDiffLoader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|GraphChangeHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|GraphDiff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|GraphManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|NodeCreateOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|NodeDeleteOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|NodeDiff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|NodePropertyChangeOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|query
operator|.
name|ObjectIdQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|AttributeProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|ClassDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|PropertyVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|ToManyProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|ToOneProperty
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_comment
comment|/**  * ObjectStore stores objects using their ObjectId as a key. It works as a dedicated  * object cache for a DataContext. Users rarely need to access ObjectStore directly, as  * DataContext serves as a facade, providing cover methods for most ObjectStore  * operations.  *   * @since 1.0  */
end_comment

begin_class
specifier|public
class|class
name|ObjectStore
implements|implements
name|Serializable
implements|,
name|SnapshotEventListener
implements|,
name|GraphManager
block|{
specifier|protected
name|Map
argument_list|<
name|Object
argument_list|,
name|Persistent
argument_list|>
name|objectMap
decl_stmt|;
specifier|protected
name|Map
argument_list|<
name|Object
argument_list|,
name|ObjectDiff
argument_list|>
name|changes
decl_stmt|;
comment|/**      * Map that tracks flattened paths for given object Id that is present in db.      * Presence of path in this map is used to separate insert from update case of flattened records.      * @since 4.1      */
specifier|protected
name|Map
argument_list|<
name|Object
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ObjectId
argument_list|>
argument_list|>
name|trackedFlattenedPaths
decl_stmt|;
comment|// a sequential id used to tag GraphDiffs so that they can later be sorted in the
comment|// original creation order
name|int
name|currentDiffId
decl_stmt|;
comment|/**      * Stores a reference to the DataRowStore.      *<p>      *<i>Serialization note:</i> It is up to the owner of this ObjectStore to initialize      * DataRowStore after deserialization of this object. ObjectStore will not know how to      * restore the DataRowStore by itself.      *</p>      */
specifier|protected
specifier|transient
name|DataRowStore
name|dataRowCache
decl_stmt|;
comment|// used to avoid incorrect on-demand DataRowStore initialization after deserialization
specifier|protected
name|boolean
name|dataRowCacheSet
decl_stmt|;
specifier|private
name|Collection
argument_list|<
name|GraphDiff
argument_list|>
name|lifecycleEventInducedChanges
decl_stmt|;
comment|/**      * The DataContext that owns this ObjectStore.      */
specifier|protected
name|DataContext
name|context
decl_stmt|;
comment|/**      * Creates an ObjectStore with {@link DataRowStore} and a map to use for storing      * registered objects. Passed map doesn't require any special synchronization      * behavior, as ObjectStore is synchronized itself.      *       * @since 3.0      */
specifier|public
name|ObjectStore
parameter_list|(
name|DataRowStore
name|dataRowCache
parameter_list|,
name|Map
argument_list|<
name|Object
argument_list|,
name|Persistent
argument_list|>
name|objectMap
parameter_list|)
block|{
name|setDataRowCache
argument_list|(
name|dataRowCache
argument_list|)
expr_stmt|;
if|if
condition|(
name|objectMap
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|objectMap
operator|=
name|objectMap
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Object map is null."
argument_list|)
throw|;
block|}
name|this
operator|.
name|changes
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
comment|/**      * @since 3.0      */
name|void
name|childContextSyncStarted
parameter_list|()
block|{
name|lifecycleEventInducedChanges
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
comment|/**      * @since 3.0      */
name|void
name|childContextSyncStopped
parameter_list|()
block|{
name|lifecycleEventInducedChanges
operator|=
literal|null
expr_stmt|;
block|}
comment|/**      * @since 3.0      */
name|Collection
argument_list|<
name|GraphDiff
argument_list|>
name|getLifecycleEventInducedChanges
parameter_list|()
block|{
return|return
name|lifecycleEventInducedChanges
operator|!=
literal|null
condition|?
name|lifecycleEventInducedChanges
else|:
name|Collections
operator|.
expr|<
name|GraphDiff
operator|>
name|emptyList
argument_list|()
return|;
block|}
name|void
name|registerLifecycleEventInducedChange
parameter_list|(
name|GraphDiff
name|diff
parameter_list|)
block|{
if|if
condition|(
name|ChildDiffLoader
operator|.
name|isProcessingChildDiff
argument_list|()
condition|)
block|{
comment|// reset so that subsequent event-induced changes could get registered...
name|ChildDiffLoader
operator|.
name|setExternalChange
argument_list|(
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lifecycleEventInducedChanges
operator|.
name|add
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Registers object change.      *       * @since 1.2      */
specifier|synchronized
name|ObjectDiff
name|registerDiff
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|NodeDiff
name|diff
parameter_list|)
block|{
if|if
condition|(
name|diff
operator|!=
literal|null
condition|)
block|{
name|diff
operator|.
name|setDiffId
argument_list|(
operator|++
name|currentDiffId
argument_list|)
expr_stmt|;
block|}
name|ObjectDiff
name|objectDiff
init|=
name|changes
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|objectDiff
operator|==
literal|null
condition|)
block|{
name|Persistent
name|object
init|=
name|objectMap
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|object
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"No object is registered in context with Id %s"
argument_list|,
name|nodeId
argument_list|)
throw|;
block|}
if|if
condition|(
name|object
operator|.
name|getPersistenceState
argument_list|()
operator|==
name|PersistenceState
operator|.
name|COMMITTED
condition|)
block|{
name|object
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|MODIFIED
argument_list|)
expr_stmt|;
comment|// TODO: andrus 3/23/2006 snapshot versions are obsolete, but there is no
comment|// replacement yet, so we still need to handle them...
if|if
condition|(
name|object
operator|instanceof
name|DataObject
condition|)
block|{
name|DataObject
name|dataObject
init|=
operator|(
name|DataObject
operator|)
name|object
decl_stmt|;
name|DataRow
name|snapshot
init|=
name|getCachedSnapshot
argument_list|(
operator|(
name|ObjectId
operator|)
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|snapshot
operator|!=
literal|null
operator|&&
name|snapshot
operator|.
name|getVersion
argument_list|()
operator|!=
name|dataObject
operator|.
name|getSnapshotVersion
argument_list|()
condition|)
block|{
name|DataContextDelegate
name|delegate
init|=
name|context
operator|.
name|nonNullDelegate
argument_list|()
decl_stmt|;
if|if
condition|(
name|delegate
operator|.
name|shouldMergeChanges
argument_list|(
name|dataObject
argument_list|,
name|snapshot
argument_list|)
condition|)
block|{
name|ClassDescriptor
name|descriptor
init|=
name|context
operator|.
name|getEntityResolver
argument_list|()
operator|.
name|getClassDescriptor
argument_list|(
operator|(
operator|(
name|ObjectId
operator|)
name|nodeId
operator|)
operator|.
name|getEntityName
argument_list|()
argument_list|)
decl_stmt|;
name|DataRowUtils
operator|.
name|forceMergeWithSnapshot
argument_list|(
name|context
argument_list|,
name|descriptor
argument_list|,
name|dataObject
argument_list|,
name|snapshot
argument_list|)
expr_stmt|;
name|dataObject
operator|.
name|setSnapshotVersion
argument_list|(
name|snapshot
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
name|delegate
operator|.
name|finishedMergeChanges
argument_list|(
name|dataObject
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|objectDiff
operator|=
operator|new
name|ObjectDiff
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|objectDiff
operator|.
name|setDiffId
argument_list|(
operator|++
name|currentDiffId
argument_list|)
expr_stmt|;
name|changes
operator|.
name|put
argument_list|(
name|nodeId
argument_list|,
name|objectDiff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|diff
operator|!=
literal|null
condition|)
block|{
name|objectDiff
operator|.
name|addDiff
argument_list|(
name|diff
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
return|return
name|objectDiff
return|;
block|}
comment|/**      * Returns a number of objects currently registered with this ObjectStore.      *       * @since 1.2      */
specifier|public
name|int
name|registeredObjectsCount
parameter_list|()
block|{
return|return
name|objectMap
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Returns a DataRowStore associated with this ObjectStore.      */
specifier|public
name|DataRowStore
name|getDataRowCache
parameter_list|()
block|{
comment|// perform deferred initialization...
comment|// Andrus, 11/7/2005 - potential problem with on-demand deferred initialization is
comment|// that deserialized context won't receive any events... which maybe ok, since it
comment|// didn't while it was stored in serialized form.
if|if
condition|(
name|dataRowCache
operator|==
literal|null
operator|&&
name|context
operator|!=
literal|null
operator|&&
name|dataRowCacheSet
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|dataRowCache
operator|==
literal|null
condition|)
block|{
name|DataDomain
name|domain
init|=
name|context
operator|.
name|getParentDataDomain
argument_list|()
decl_stmt|;
if|if
condition|(
name|domain
operator|!=
literal|null
condition|)
block|{
name|setDataRowCache
argument_list|(
name|domain
operator|.
name|getSharedSnapshotCache
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|dataRowCache
return|;
block|}
comment|/**      * Sets parent DataRowStore. Registers to receive SnapshotEvents if the cache is      * configured to allow ObjectStores to receive such events.      */
comment|// note that as of 1.2, ObjectStore does not access DataRowStore directly when
comment|// retrieving snapshots. Instead it sends a query via the DataContext's channel so
comment|// that every element in the channel chain could intercept snapshot requests
specifier|public
name|void
name|setDataRowCache
parameter_list|(
name|DataRowStore
name|dataRowCache
parameter_list|)
block|{
if|if
condition|(
name|dataRowCache
operator|==
name|this
operator|.
name|dataRowCache
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|this
operator|.
name|dataRowCache
operator|!=
literal|null
operator|&&
name|this
operator|.
name|dataRowCache
operator|.
name|getEventManager
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|dataRowCache
operator|.
name|getEventManager
argument_list|()
operator|.
name|removeListener
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|dataRowCache
operator|.
name|getSnapshotEventSubject
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|dataRowCache
operator|=
name|dataRowCache
expr_stmt|;
if|if
condition|(
name|dataRowCache
operator|!=
literal|null
operator|&&
name|dataRowCache
operator|.
name|getEventManager
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// setting itself as non-blocking listener,
comment|// since event sending thread will likely be locking sender's
comment|// ObjectStore and snapshot cache itself.
name|dataRowCache
operator|.
name|getEventManager
argument_list|()
operator|.
name|addNonBlockingListener
argument_list|(
name|this
argument_list|,
literal|"snapshotsChanged"
argument_list|,
name|SnapshotEvent
operator|.
name|class
argument_list|,
name|dataRowCache
operator|.
name|getSnapshotEventSubject
argument_list|()
argument_list|,
name|dataRowCache
argument_list|)
expr_stmt|;
block|}
name|dataRowCacheSet
operator|=
name|dataRowCache
operator|!=
literal|null
expr_stmt|;
block|}
comment|/**      * Evicts a collection of DataObjects from the ObjectStore, invalidates the underlying      * cache snapshots. Changes objects state to TRANSIENT. This method can be used for      * manual cleanup of Cayenne cache.      */
comment|// this method is exactly the same as "objectsInvalidated", only additionally it
comment|// throws out registered objects
specifier|public
specifier|synchronized
name|void
name|objectsUnregistered
parameter_list|(
name|Collection
name|objects
parameter_list|)
block|{
if|if
condition|(
name|objects
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|Collection
argument_list|<
name|ObjectId
argument_list|>
name|ids
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|objects
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
name|object1
range|:
name|objects
control|)
block|{
name|Persistent
name|object
init|=
operator|(
name|Persistent
operator|)
name|object1
decl_stmt|;
name|ObjectId
name|id
init|=
name|object
operator|.
name|getObjectId
argument_list|()
decl_stmt|;
comment|// remove object but not snapshot
name|objectMap
operator|.
name|remove
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|changes
operator|.
name|remove
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
literal|null
operator|&&
name|trackedFlattenedPaths
operator|!=
literal|null
condition|)
block|{
name|trackedFlattenedPaths
operator|.
name|remove
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|ids
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|object
operator|.
name|setObjectContext
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|object
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|TRANSIENT
argument_list|)
expr_stmt|;
block|}
comment|// TODO, andrus 3/28/2006 - DRC is null in nested contexts... implement
comment|// propagation of unregister operation through the stack ... or do the opposite
comment|// and keep unregister local even for non-nested DC?
if|if
condition|(
name|getDataRowCache
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// send an event for removed snapshots
name|getDataRowCache
argument_list|()
operator|.
name|processSnapshotChanges
argument_list|(
name|this
argument_list|,
name|Collections
operator|.
expr|<
name|ObjectId
argument_list|,
name|DataRow
operator|>
name|emptyMap
argument_list|()
argument_list|,
name|Collections
operator|.
expr|<
name|ObjectId
operator|>
name|emptyList
argument_list|()
argument_list|,
name|ids
argument_list|,
name|Collections
operator|.
expr|<
name|ObjectId
operator|>
name|emptyList
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Reverts changes to all stored uncomitted objects.      *       * @since 1.1      */
specifier|public
specifier|synchronized
name|void
name|objectsRolledBack
parameter_list|()
block|{
name|Iterator
argument_list|<
name|Persistent
argument_list|>
name|it
init|=
name|getObjectIterator
argument_list|()
decl_stmt|;
comment|// collect candidates
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Persistent
name|object
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|int
name|objectState
init|=
name|object
operator|.
name|getPersistenceState
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|objectState
condition|)
block|{
case|case
name|PersistenceState
operator|.
name|NEW
case|:
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|object
operator|.
name|setObjectContext
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|object
operator|.
name|setObjectId
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|object
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|TRANSIENT
argument_list|)
expr_stmt|;
break|break;
case|case
name|PersistenceState
operator|.
name|DELETED
case|:
comment|// Do the same as for modified... deleted is only a persistence state,
comment|// so
comment|// rolling the object back will set the state to committed
case|case
name|PersistenceState
operator|.
name|MODIFIED
case|:
comment|// this will clean any modifications and defer refresh from snapshot
comment|// till the next object accessor is called
name|object
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|HOLLOW
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// Transient, committed and hollow need no handling
break|break;
block|}
block|}
comment|// reset changes ... using new HashMap to allow event listeners to analyze the
comment|// original changes map after the rollback
name|this
operator|.
name|changes
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
comment|/**      * Builds and returns GraphDiff reflecting all uncommitted object changes.      *       * @since 1.2      */
name|ObjectStoreGraphDiff
name|getChanges
parameter_list|()
block|{
return|return
operator|new
name|ObjectStoreGraphDiff
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**      * Returns internal changes map.      *       * @since 1.2      */
name|Map
argument_list|<
name|Object
argument_list|,
name|ObjectDiff
argument_list|>
name|getChangesByObjectId
parameter_list|()
block|{
return|return
name|changes
return|;
block|}
comment|/**      * @since 1.2      */
name|void
name|postprocessAfterPhantomCommit
parameter_list|()
block|{
for|for
control|(
name|Object
name|id
range|:
name|changes
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Persistent
name|object
init|=
name|objectMap
operator|.
name|get
argument_list|(
name|id
argument_list|)
decl_stmt|;
comment|// assume that no new or deleted objects are present (as otherwise commit
comment|// wouldn't have been phantom).
name|object
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|COMMITTED
argument_list|)
expr_stmt|;
block|}
comment|// clear caches
name|this
operator|.
name|changes
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**      * Internal unsynchronized method to process objects state after commit.      *       * @since 1.2      */
specifier|public
name|void
name|postprocessAfterCommit
parameter_list|(
name|GraphDiff
name|parentChanges
parameter_list|)
block|{
comment|// scan through changed objects, set persistence state to committed
for|for
control|(
name|Object
name|id
range|:
name|changes
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Persistent
name|object
init|=
name|objectMap
operator|.
name|get
argument_list|(
name|id
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|object
operator|.
name|getPersistenceState
argument_list|()
condition|)
block|{
case|case
name|PersistenceState
operator|.
name|DELETED
case|:
name|objectMap
operator|.
name|remove
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|object
operator|.
name|setObjectContext
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|object
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|TRANSIENT
argument_list|)
expr_stmt|;
break|break;
case|case
name|PersistenceState
operator|.
name|NEW
case|:
case|case
name|PersistenceState
operator|.
name|MODIFIED
case|:
name|object
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|COMMITTED
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|// re-register changed object ids
if|if
condition|(
operator|!
name|parentChanges
operator|.
name|isNoop
argument_list|()
condition|)
block|{
name|parentChanges
operator|.
name|apply
argument_list|(
operator|new
name|GraphChangeHandler
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|arcCreated
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|Object
name|targetNodeId
parameter_list|,
name|ArcId
name|arcId
parameter_list|)
block|{
block|}
annotation|@
name|Override
specifier|public
name|void
name|arcDeleted
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|Object
name|targetNodeId
parameter_list|,
name|ArcId
name|arcId
parameter_list|)
block|{
block|}
annotation|@
name|Override
specifier|public
name|void
name|nodeCreated
parameter_list|(
name|Object
name|nodeId
parameter_list|)
block|{
block|}
annotation|@
name|Override
specifier|public
name|void
name|nodeIdChanged
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|Object
name|newId
parameter_list|)
block|{
name|processIdChange
argument_list|(
name|nodeId
argument_list|,
name|newId
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|nodePropertyChanged
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|String
name|property
parameter_list|,
name|Object
name|oldValue
parameter_list|,
name|Object
name|newValue
parameter_list|)
block|{
block|}
annotation|@
name|Override
specifier|public
name|void
name|nodeRemoved
parameter_list|(
name|Object
name|nodeId
parameter_list|)
block|{
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|// create new instance of changes map so that event listeners who stored the
comment|// original diff don't get affected
name|this
operator|.
name|changes
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns a snapshot for ObjectId from the underlying snapshot cache. If cache      * contains no snapshot, a null is returned.      *       * @since 1.1      */
specifier|public
name|DataRow
name|getCachedSnapshot
parameter_list|(
name|ObjectId
name|oid
parameter_list|)
block|{
if|if
condition|(
name|context
operator|!=
literal|null
operator|&&
name|context
operator|.
name|getChannel
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|ObjectIdQuery
name|query
init|=
operator|new
name|CachedSnapshotQuery
argument_list|(
name|oid
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|?
argument_list|>
name|results
init|=
name|context
operator|.
name|getChannel
argument_list|()
operator|.
name|onQuery
argument_list|(
name|context
argument_list|,
name|query
argument_list|)
operator|.
name|firstList
argument_list|()
decl_stmt|;
return|return
name|results
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
operator|(
name|DataRow
operator|)
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Returns a snapshot for ObjectId from the underlying snapshot cache. If cache      * contains no snapshot, it will attempt fetching it using provided QueryEngine. If      * fetch attempt fails or inconsistent data is returned, underlying cache will throw a      * CayenneRuntimeException.      *       * @since 1.2      */
specifier|public
specifier|synchronized
name|DataRow
name|getSnapshot
parameter_list|(
name|ObjectId
name|oid
parameter_list|)
block|{
if|if
condition|(
name|context
operator|!=
literal|null
operator|&&
name|context
operator|.
name|getChannel
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|ObjectIdQuery
name|query
init|=
operator|new
name|ObjectIdQuery
argument_list|(
name|oid
argument_list|,
literal|true
argument_list|,
name|ObjectIdQuery
operator|.
name|CACHE
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|?
argument_list|>
name|results
init|=
name|context
operator|.
name|getChannel
argument_list|()
operator|.
name|onQuery
argument_list|(
name|context
argument_list|,
name|query
argument_list|)
operator|.
name|firstList
argument_list|()
decl_stmt|;
return|return
name|results
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
operator|(
name|DataRow
operator|)
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Returns an iterator over the registered objects.      */
specifier|public
specifier|synchronized
name|Iterator
argument_list|<
name|Persistent
argument_list|>
name|getObjectIterator
parameter_list|()
block|{
return|return
name|objectMap
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|/**      * Returns<code>true</code> if there are any modified, deleted or new objects      * registered with this ObjectStore,<code>false</code> otherwise. This method will      * treat "phantom" modifications are real ones. I.e. if you "change" an object      * property to an equivalent value, this method will still think such object is      * modified. Phantom modifications are only detected and discarded during commit.      */
specifier|public
specifier|synchronized
name|boolean
name|hasChanges
parameter_list|()
block|{
return|return
operator|!
name|changes
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**      * Return a subset of registered objects that are in a certain persistence state.      * Collection is returned by copy.      */
specifier|public
specifier|synchronized
name|List
argument_list|<
name|Persistent
argument_list|>
name|objectsInState
parameter_list|(
name|int
name|state
parameter_list|)
block|{
name|List
argument_list|<
name|Persistent
argument_list|>
name|filteredObjects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Persistent
name|object
range|:
name|objectMap
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|object
operator|.
name|getPersistenceState
argument_list|()
operator|==
name|state
condition|)
block|{
name|filteredObjects
operator|.
name|add
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|filteredObjects
return|;
block|}
comment|/**      * SnapshotEventListener implementation that processes snapshot change event, updating      * DataObjects that have the changes.      *<p>      *<i>Implementation note:</i> This method should not attempt to alter the underlying      * DataRowStore, since it is normally invoked *AFTER* the DataRowStore was modified as      * a result of some external interaction.      *</p>      *       * @since 1.1      */
annotation|@
name|Override
specifier|public
name|void
name|snapshotsChanged
parameter_list|(
name|SnapshotEvent
name|event
parameter_list|)
block|{
comment|// filter events that we should not process
if|if
condition|(
name|event
operator|.
name|getPostedBy
argument_list|()
operator|!=
name|this
operator|&&
name|event
operator|.
name|getSource
argument_list|()
operator|==
name|this
operator|.
name|getDataRowCache
argument_list|()
condition|)
block|{
name|processSnapshotEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @since 1.2      */
specifier|synchronized
name|void
name|processSnapshotEvent
parameter_list|(
name|SnapshotEvent
name|event
parameter_list|)
block|{
name|Map
argument_list|<
name|ObjectId
argument_list|,
name|DataRow
argument_list|>
name|modifiedDiffs
init|=
name|event
operator|.
name|getModifiedDiffs
argument_list|()
decl_stmt|;
if|if
condition|(
name|modifiedDiffs
operator|!=
literal|null
operator|&&
operator|!
name|modifiedDiffs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ObjectId
argument_list|,
name|DataRow
argument_list|>
name|entry
range|:
name|modifiedDiffs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|processUpdatedSnapshot
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|Collection
argument_list|<
name|ObjectId
argument_list|>
name|deletedIDs
init|=
name|event
operator|.
name|getDeletedIds
argument_list|()
decl_stmt|;
if|if
condition|(
name|deletedIDs
operator|!=
literal|null
operator|&&
operator|!
name|deletedIDs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|ObjectId
name|deletedID
range|:
name|deletedIDs
control|)
block|{
name|processDeletedID
argument_list|(
name|deletedID
argument_list|)
expr_stmt|;
block|}
block|}
name|processInvalidatedIDs
argument_list|(
name|event
operator|.
name|getInvalidatedIds
argument_list|()
argument_list|)
expr_stmt|;
name|processIndirectlyModifiedIDs
argument_list|(
name|event
operator|.
name|getIndirectlyModifiedIds
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO: andrus, 3/28/2006 - 'SnapshotEventDecorator' serves as a bridge (or
comment|// rather a noop wrapper) between old snapshot events and new GraphEvents. Once
comment|// SnapshotEvents are replaced with GraphEvents (in 2.0) we won't need it
name|GraphDiff
name|diff
init|=
operator|new
name|SnapshotEventDecorator
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|ObjectContext
name|originatingContext
init|=
operator|(
name|event
operator|.
name|getPostedBy
argument_list|()
operator|instanceof
name|ObjectContext
operator|)
condition|?
operator|(
name|ObjectContext
operator|)
name|event
operator|.
name|getPostedBy
argument_list|()
else|:
literal|null
decl_stmt|;
name|context
operator|.
name|fireDataChannelChanged
argument_list|(
name|originatingContext
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
name|void
name|processIdChange
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|Object
name|newId
parameter_list|)
block|{
name|Persistent
name|object
init|=
name|objectMap
operator|.
name|remove
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|object
operator|!=
literal|null
condition|)
block|{
name|object
operator|.
name|setObjectId
argument_list|(
operator|(
name|ObjectId
operator|)
name|newId
argument_list|)
expr_stmt|;
name|objectMap
operator|.
name|put
argument_list|(
name|newId
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|ObjectDiff
name|change
init|=
name|changes
operator|.
name|remove
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|change
operator|!=
literal|null
condition|)
block|{
name|changes
operator|.
name|put
argument_list|(
name|newId
argument_list|,
name|change
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|trackedFlattenedPaths
operator|!=
literal|null
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ObjectId
argument_list|>
name|paths
init|=
name|trackedFlattenedPaths
operator|.
name|remove
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|paths
operator|!=
literal|null
condition|)
block|{
name|trackedFlattenedPaths
operator|.
name|put
argument_list|(
name|newId
argument_list|,
name|paths
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Requires external synchronization.      *       * @since 1.2      */
name|void
name|processDeletedID
parameter_list|(
name|ObjectId
name|nodeId
parameter_list|)
block|{
comment|// access object map directly - the method should be called in a synchronized context...
name|Persistent
name|object
init|=
name|objectMap
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|object
operator|!=
literal|null
condition|)
block|{
name|DataObject
name|dataObject
init|=
operator|(
name|object
operator|instanceof
name|DataObject
operator|)
condition|?
operator|(
name|DataObject
operator|)
name|object
else|:
literal|null
decl_stmt|;
name|DataContextDelegate
name|delegate
decl_stmt|;
switch|switch
condition|(
name|object
operator|.
name|getPersistenceState
argument_list|()
condition|)
block|{
case|case
name|PersistenceState
operator|.
name|COMMITTED
case|:
case|case
name|PersistenceState
operator|.
name|HOLLOW
case|:
case|case
name|PersistenceState
operator|.
name|DELETED
case|:
comment|// consult delegate
name|delegate
operator|=
name|context
operator|.
name|nonNullDelegate
argument_list|()
expr_stmt|;
if|if
condition|(
name|dataObject
operator|==
literal|null
operator|||
name|delegate
operator|.
name|shouldProcessDelete
argument_list|(
name|dataObject
argument_list|)
condition|)
block|{
name|objectMap
operator|.
name|remove
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
name|changes
operator|.
name|remove
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
comment|// setting DataContext to null will also set
comment|// state to transient
name|object
operator|.
name|setObjectContext
argument_list|(
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|dataObject
operator|!=
literal|null
condition|)
block|{
name|delegate
operator|.
name|finishedProcessDelete
argument_list|(
name|dataObject
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PersistenceState
operator|.
name|MODIFIED
case|:
comment|// consult delegate
name|delegate
operator|=
name|context
operator|.
name|nonNullDelegate
argument_list|()
expr_stmt|;
if|if
condition|(
name|dataObject
operator|!=
literal|null
operator|&&
name|delegate
operator|.
name|shouldProcessDelete
argument_list|(
name|dataObject
argument_list|)
condition|)
block|{
name|object
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|NEW
argument_list|)
expr_stmt|;
name|changes
operator|.
name|remove
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
name|registerNode
argument_list|(
name|nodeId
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|nodeCreated
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
name|delegate
operator|.
name|finishedProcessDelete
argument_list|(
name|dataObject
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
comment|/**      * @since 1.1      */
name|void
name|processInvalidatedIDs
parameter_list|(
name|Collection
argument_list|<
name|ObjectId
argument_list|>
name|invalidatedIDs
parameter_list|)
block|{
if|if
condition|(
name|invalidatedIDs
operator|!=
literal|null
operator|&&
operator|!
name|invalidatedIDs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|ObjectId
name|oid
range|:
name|invalidatedIDs
control|)
block|{
name|DataObject
name|object
init|=
operator|(
name|DataObject
operator|)
name|getNode
argument_list|(
name|oid
argument_list|)
decl_stmt|;
if|if
condition|(
name|object
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
comment|// TODO: refactor "switch" to avoid code duplication
switch|switch
condition|(
name|object
operator|.
name|getPersistenceState
argument_list|()
condition|)
block|{
case|case
name|PersistenceState
operator|.
name|COMMITTED
case|:
name|object
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|HOLLOW
argument_list|)
expr_stmt|;
break|break;
case|case
name|PersistenceState
operator|.
name|MODIFIED
case|:
name|DataContext
name|context
init|=
operator|(
name|DataContext
operator|)
name|object
operator|.
name|getObjectContext
argument_list|()
decl_stmt|;
name|DataRow
name|diff
init|=
name|getSnapshot
argument_list|(
name|oid
argument_list|)
decl_stmt|;
comment|// consult delegate if it exists
name|DataContextDelegate
name|delegate
init|=
name|context
operator|.
name|nonNullDelegate
argument_list|()
decl_stmt|;
if|if
condition|(
name|delegate
operator|.
name|shouldMergeChanges
argument_list|(
name|object
argument_list|,
name|diff
argument_list|)
condition|)
block|{
name|ClassDescriptor
name|descriptor
init|=
name|context
operator|.
name|getEntityResolver
argument_list|()
operator|.
name|getClassDescriptor
argument_list|(
name|oid
operator|.
name|getEntityName
argument_list|()
argument_list|)
decl_stmt|;
name|DataRowUtils
operator|.
name|forceMergeWithSnapshot
argument_list|(
name|context
argument_list|,
name|descriptor
argument_list|,
name|object
argument_list|,
name|diff
argument_list|)
expr_stmt|;
name|delegate
operator|.
name|finishedMergeChanges
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
case|case
name|PersistenceState
operator|.
name|HOLLOW
case|:
comment|// do nothing
break|break;
case|case
name|PersistenceState
operator|.
name|DELETED
case|:
comment|// TODO: Do nothing? Or treat as merged?
break|break;
block|}
block|}
block|}
block|}
comment|/**      * Requires external synchronization.      *       * @since 1.1      */
name|void
name|processIndirectlyModifiedIDs
parameter_list|(
name|Collection
argument_list|<
name|ObjectId
argument_list|>
name|indirectlyModifiedIDs
parameter_list|)
block|{
for|for
control|(
name|ObjectId
name|oid
range|:
name|indirectlyModifiedIDs
control|)
block|{
comment|// access object map directly - the method should be called in a synchronized context...
specifier|final
name|DataObject
name|object
init|=
operator|(
name|DataObject
operator|)
name|objectMap
operator|.
name|get
argument_list|(
name|oid
argument_list|)
decl_stmt|;
if|if
condition|(
name|object
operator|==
literal|null
operator|||
name|object
operator|.
name|getPersistenceState
argument_list|()
operator|!=
name|PersistenceState
operator|.
name|COMMITTED
condition|)
block|{
continue|continue;
block|}
comment|// for now break all "independent" object relationships...
comment|// in the future we may want to be more precise and go after modified
comment|// relationships only, or even process updated lists without invalidating...
name|DataContextDelegate
name|delegate
init|=
name|context
operator|.
name|nonNullDelegate
argument_list|()
decl_stmt|;
if|if
condition|(
name|delegate
operator|.
name|shouldMergeChanges
argument_list|(
name|object
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|ClassDescriptor
name|descriptor
init|=
name|context
operator|.
name|getEntityResolver
argument_list|()
operator|.
name|getClassDescriptor
argument_list|(
name|oid
operator|.
name|getEntityName
argument_list|()
argument_list|)
decl_stmt|;
name|descriptor
operator|.
name|visitProperties
argument_list|(
operator|new
name|PropertyVisitor
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|visitToMany
parameter_list|(
name|ToManyProperty
name|property
parameter_list|)
block|{
name|property
operator|.
name|invalidate
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|visitToOne
parameter_list|(
name|ToOneProperty
name|property
parameter_list|)
block|{
if|if
condition|(
name|property
operator|.
name|getRelationship
argument_list|()
operator|.
name|isSourceIndependentFromTargetChange
argument_list|()
condition|)
block|{
name|property
operator|.
name|invalidate
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|visitAttribute
parameter_list|(
name|AttributeProperty
name|property
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|delegate
operator|.
name|finishedProcessDelete
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Requires external synchronization.      *       * @since 1.1      */
name|void
name|processUpdatedSnapshot
parameter_list|(
name|ObjectId
name|nodeId
parameter_list|,
name|DataRow
name|diff
parameter_list|)
block|{
comment|// access object map directly - the method should be called in a synchronized context...
name|DataObject
name|object
init|=
operator|(
name|DataObject
operator|)
name|objectMap
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
comment|// no object, or HOLLOW object require no processing
if|if
condition|(
name|object
operator|!=
literal|null
condition|)
block|{
name|int
name|state
init|=
name|object
operator|.
name|getPersistenceState
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|!=
name|PersistenceState
operator|.
name|HOLLOW
condition|)
block|{
comment|// perform same steps as resolveHollow()
if|if
condition|(
name|state
operator|==
name|PersistenceState
operator|.
name|COMMITTED
condition|)
block|{
comment|// consult delegate if it exists
name|DataContextDelegate
name|delegate
init|=
name|context
operator|.
name|nonNullDelegate
argument_list|()
decl_stmt|;
if|if
condition|(
name|delegate
operator|.
name|shouldMergeChanges
argument_list|(
name|object
argument_list|,
name|diff
argument_list|)
condition|)
block|{
name|ClassDescriptor
name|descriptor
init|=
name|context
operator|.
name|getEntityResolver
argument_list|()
operator|.
name|getClassDescriptor
argument_list|(
name|nodeId
operator|.
name|getEntityName
argument_list|()
argument_list|)
decl_stmt|;
comment|// TODO: andrus, 5/26/2006 - call to 'getSnapshot' is expensive,
comment|// however my attempts to merge the 'diff' instead of snapshot
comment|// via 'refreshObjectWithSnapshot' resulted in even worse performance.
comment|// This sounds counterintuitive (Not sure if this is some HotSpot related glitch)...
comment|// still keeping the old algorithm here until we switch from snapshot events
comment|// to GraphEvents and all this code becomes obsolete.
name|DataRow
name|snapshot
init|=
name|getSnapshot
argument_list|(
name|object
operator|.
name|getObjectId
argument_list|()
argument_list|)
decl_stmt|;
name|DataRowUtils
operator|.
name|refreshObjectWithSnapshot
argument_list|(
name|descriptor
argument_list|,
name|object
argument_list|,
name|snapshot
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|delegate
operator|.
name|finishedMergeChanges
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
block|}
comment|// merge modified and deleted
if|else if
condition|(
name|state
operator|==
name|PersistenceState
operator|.
name|DELETED
operator|||
name|state
operator|==
name|PersistenceState
operator|.
name|MODIFIED
condition|)
block|{
comment|// consult delegate if it exists
name|DataContextDelegate
name|delegate
init|=
name|context
operator|.
name|nonNullDelegate
argument_list|()
decl_stmt|;
if|if
condition|(
name|delegate
operator|.
name|shouldMergeChanges
argument_list|(
name|object
argument_list|,
name|diff
argument_list|)
condition|)
block|{
name|ClassDescriptor
name|descriptor
init|=
name|context
operator|.
name|getEntityResolver
argument_list|()
operator|.
name|getClassDescriptor
argument_list|(
name|nodeId
operator|.
name|getEntityName
argument_list|()
argument_list|)
decl_stmt|;
name|DataRowUtils
operator|.
name|forceMergeWithSnapshot
argument_list|(
name|context
argument_list|,
name|descriptor
argument_list|,
name|object
argument_list|,
name|diff
argument_list|)
expr_stmt|;
name|delegate
operator|.
name|finishedMergeChanges
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * @since 1.2      */
specifier|public
name|DataContext
name|getContext
parameter_list|()
block|{
return|return
name|context
return|;
block|}
comment|/**      * @since 1.2      */
specifier|public
name|void
name|setContext
parameter_list|(
name|DataContext
name|context
parameter_list|)
block|{
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
block|}
comment|// *********** GraphManager Methods ********
comment|// =========================================
comment|/**      * Returns a registered DataObject or null of no object exists for the ObjectId.      *       * @since 1.2      */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|Object
name|getNode
parameter_list|(
name|Object
name|nodeId
parameter_list|)
block|{
return|return
name|objectMap
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
return|;
block|}
comment|// non-synchronized version of getNode for private use
specifier|final
name|Object
name|getNodeNoSync
parameter_list|(
name|Object
name|nodeId
parameter_list|)
block|{
return|return
name|objectMap
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
return|;
block|}
comment|/**      * Returns all registered DataObjects. List is returned by copy and can be modified by      * the caller.      *       * @since 1.2      */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|Collection
argument_list|<
name|Object
argument_list|>
name|registeredNodes
parameter_list|()
block|{
return|return
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|(
name|objectMap
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * @since 1.2      */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|registerNode
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|Object
name|nodeObject
parameter_list|)
block|{
name|objectMap
operator|.
name|put
argument_list|(
name|nodeId
argument_list|,
operator|(
name|Persistent
operator|)
name|nodeObject
argument_list|)
expr_stmt|;
block|}
comment|/**      * @since 1.2      */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|Object
name|unregisterNode
parameter_list|(
name|Object
name|nodeId
parameter_list|)
block|{
name|Object
name|object
init|=
name|getNode
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|object
operator|!=
literal|null
condition|)
block|{
name|objectsUnregistered
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|object
return|;
block|}
comment|/**      * Does nothing.      *       * @since 1.2      */
annotation|@
name|Override
specifier|public
name|void
name|nodeIdChanged
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|Object
name|newId
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"nodeIdChanged"
argument_list|)
throw|;
block|}
comment|/**      * @since 1.2      */
annotation|@
name|Override
specifier|public
name|void
name|nodeCreated
parameter_list|(
name|Object
name|nodeId
parameter_list|)
block|{
name|NodeDiff
name|diff
init|=
operator|new
name|NodeCreateOperation
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|lifecycleEventInducedChanges
operator|!=
literal|null
condition|)
block|{
name|registerLifecycleEventInducedChange
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
name|registerDiff
argument_list|(
name|nodeId
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
comment|/**      * @since 1.2      */
annotation|@
name|Override
specifier|public
name|void
name|nodeRemoved
parameter_list|(
name|Object
name|nodeId
parameter_list|)
block|{
name|NodeDiff
name|diff
init|=
operator|new
name|NodeDeleteOperation
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|lifecycleEventInducedChanges
operator|!=
literal|null
condition|)
block|{
name|registerLifecycleEventInducedChange
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
name|registerDiff
argument_list|(
name|nodeId
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
comment|/**      * Records dirty object snapshot.      *       * @since 1.2      */
annotation|@
name|Override
specifier|public
name|void
name|nodePropertyChanged
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|String
name|property
parameter_list|,
name|Object
name|oldValue
parameter_list|,
name|Object
name|newValue
parameter_list|)
block|{
if|if
condition|(
name|lifecycleEventInducedChanges
operator|!=
literal|null
condition|)
block|{
name|registerLifecycleEventInducedChange
argument_list|(
operator|new
name|NodePropertyChangeOperation
argument_list|(
name|nodeId
argument_list|,
name|property
argument_list|,
name|oldValue
argument_list|,
name|newValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|registerDiff
argument_list|(
name|nodeId
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * @since 1.2      */
annotation|@
name|Override
specifier|public
name|void
name|arcCreated
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|Object
name|targetNodeId
parameter_list|,
name|ArcId
name|arcId
parameter_list|)
block|{
name|NodeDiff
name|diff
init|=
operator|new
name|ArcOperation
argument_list|(
name|nodeId
argument_list|,
name|targetNodeId
argument_list|,
name|arcId
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|lifecycleEventInducedChanges
operator|!=
literal|null
condition|)
block|{
name|registerLifecycleEventInducedChange
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
name|registerDiff
argument_list|(
name|nodeId
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
comment|/**      * @since 1.2      */
annotation|@
name|Override
specifier|public
name|void
name|arcDeleted
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|Object
name|targetNodeId
parameter_list|,
name|ArcId
name|arcId
parameter_list|)
block|{
name|NodeDiff
name|diff
init|=
operator|new
name|ArcOperation
argument_list|(
name|nodeId
argument_list|,
name|targetNodeId
argument_list|,
name|arcId
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|lifecycleEventInducedChanges
operator|!=
literal|null
condition|)
block|{
name|registerLifecycleEventInducedChange
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
name|registerDiff
argument_list|(
name|nodeId
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
comment|/**      * Check that flattened path for given object ID has data row in DB.      * @since 4.1      */
name|boolean
name|hasFlattenedPath
parameter_list|(
name|ObjectId
name|objectId
parameter_list|,
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|trackedFlattenedPaths
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|trackedFlattenedPaths
operator|.
name|getOrDefault
argument_list|(
name|objectId
argument_list|,
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|)
operator|.
name|containsKey
argument_list|(
name|path
argument_list|)
return|;
block|}
comment|/**      * @since 4.2      */
specifier|public
name|ObjectId
name|getFlattenedId
parameter_list|(
name|ObjectId
name|objectId
parameter_list|,
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|trackedFlattenedPaths
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|trackedFlattenedPaths
operator|.
name|getOrDefault
argument_list|(
name|objectId
argument_list|,
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|)
operator|.
name|get
argument_list|(
name|path
argument_list|)
return|;
block|}
comment|/**      * @since 4.2      */
specifier|public
name|Collection
argument_list|<
name|ObjectId
argument_list|>
name|getFlattenedIds
parameter_list|(
name|ObjectId
name|objectId
parameter_list|)
block|{
if|if
condition|(
name|trackedFlattenedPaths
operator|==
literal|null
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
return|return
name|trackedFlattenedPaths
operator|.
name|getOrDefault
argument_list|(
name|objectId
argument_list|,
name|Collections
operator|.
name|emptyMap
argument_list|()
argument_list|)
operator|.
name|values
argument_list|()
return|;
block|}
comment|/**      * Mark that flattened path for object has data row in DB.      * @since 4.1      */
specifier|public
name|void
name|markFlattenedPath
parameter_list|(
name|ObjectId
name|objectId
parameter_list|,
name|String
name|path
parameter_list|,
name|ObjectId
name|id
parameter_list|)
block|{
if|if
condition|(
name|trackedFlattenedPaths
operator|==
literal|null
condition|)
block|{
name|trackedFlattenedPaths
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|trackedFlattenedPaths
operator|.
name|computeIfAbsent
argument_list|(
name|objectId
argument_list|,
name|o
lambda|->
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
name|path
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
comment|// an ObjectIdQuery optimized for retrieval of multiple snapshots - it can be reset
comment|// with the new id
specifier|final
class|class
name|CachedSnapshotQuery
extends|extends
name|ObjectIdQuery
block|{
name|CachedSnapshotQuery
parameter_list|(
name|ObjectId
name|oid
parameter_list|)
block|{
name|super
argument_list|(
name|oid
argument_list|,
literal|true
argument_list|,
name|ObjectIdQuery
operator|.
name|CACHE_NOREFRESH
argument_list|)
expr_stmt|;
block|}
name|void
name|resetId
parameter_list|(
name|ObjectId
name|oid
parameter_list|)
block|{
name|this
operator|.
name|objectId
operator|=
name|oid
expr_stmt|;
name|this
operator|.
name|replacementQuery
operator|=
literal|null
expr_stmt|;
block|}
block|}
class|class
name|SnapshotEventDecorator
implements|implements
name|GraphDiff
block|{
name|SnapshotEvent
name|event
decl_stmt|;
name|SnapshotEventDecorator
parameter_list|(
name|SnapshotEvent
name|event
parameter_list|)
block|{
name|this
operator|.
name|event
operator|=
name|event
expr_stmt|;
block|}
name|SnapshotEvent
name|getEvent
parameter_list|()
block|{
return|return
name|event
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|GraphChangeHandler
name|handler
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isNoop
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|undo
parameter_list|(
name|GraphChangeHandler
name|handler
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
block|}
end_class

end_unit

