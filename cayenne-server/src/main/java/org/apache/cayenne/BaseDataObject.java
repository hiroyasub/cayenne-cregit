begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************  *   Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *    https://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing,  *  software distributed under the License is distributed on an  *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *  KIND, either express or implied.  See the License for the  *  specific language governing permissions and limitations  *  under the License.  ****************************************************************/
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cayenne
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|DbAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|DbJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|DbRelationship
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|EmbeddedAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|EntityResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|ObjAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|ObjEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|ObjRelationship
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|PropertyUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|validation
operator|.
name|BeanValidationFailure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|validation
operator|.
name|ValidationFailure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|validation
operator|.
name|ValidationResult
import|;
end_import

begin_comment
comment|/**  * Base implementation of {@link DataObject},  * have no assumption about how data is actually stored.  *<p>  * Three variants are currently supported:  *<ul>  *<li> field based storage, e.g. each entity class will directly define fields to store data  *<li> {@link Map} based storage, e.g. values will be stored in general Map ({@link CayenneDataObject})  *<li> mixed fields and generic Map to store runtime attributes ({@link HybridDataObject})  *</ul>  *<p>  * This class can be used directly as superclass for field-based data objects.  *<p>  * To create own implementation of {@link DataObject} with custom field storage logic it is enough  * to implement {@link #readPropertyDirectly(String)} and {@link #writePropertyDirectly(String, Object)} methods  * and serialization support if needed (helper methods {@link #writeState(ObjectOutputStream)}  * and {@link #readState(ObjectInputStream)} are provided).  *  * @see CayenneDataObject  * @see HybridDataObject  *  * @since 4.1  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|BaseDataObject
extends|extends
name|PersistentObject
implements|implements
name|DataObject
implements|,
name|Validating
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|4598677040697008371L
decl_stmt|;
specifier|protected
name|long
name|snapshotVersion
init|=
name|DEFAULT_VERSION
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Object
name|readPropertyDirectly
parameter_list|(
name|String
name|propName
parameter_list|)
block|{
comment|// return null by default to keep compatibility with pre 4.1 versions
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writePropertyDirectly
parameter_list|(
name|String
name|propName
parameter_list|,
name|Object
name|val
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown property: "
operator|+
name|propName
argument_list|)
throw|;
block|}
specifier|protected
name|void
name|beforePropertyRead
parameter_list|(
name|String
name|propName
parameter_list|)
block|{
if|if
condition|(
name|objectContext
operator|!=
literal|null
condition|)
block|{
comment|// will resolve faults ourselves below as checking class descriptors
comment|// for the "lazyFaulting" flag is inefficient. Passing "false" here to
comment|// suppress fault processing
name|objectContext
operator|.
name|prepareForAccess
argument_list|(
name|this
argument_list|,
name|propName
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|beforePropertyWrite
parameter_list|(
name|String
name|propName
parameter_list|,
name|Object
name|oldValue
parameter_list|,
name|Object
name|newValue
parameter_list|)
block|{
if|if
condition|(
name|objectContext
operator|!=
literal|null
condition|)
block|{
name|objectContext
operator|.
name|prepareForAccess
argument_list|(
name|this
argument_list|,
name|propName
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|objectContext
operator|.
name|propertyChanged
argument_list|(
name|this
argument_list|,
name|propName
argument_list|,
name|oldValue
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Object
name|readProperty
parameter_list|(
name|String
name|propertyName
parameter_list|)
block|{
name|beforePropertyRead
argument_list|(
name|propertyName
argument_list|)
expr_stmt|;
name|Object
name|object
init|=
name|readPropertyDirectly
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
if|if
condition|(
name|object
operator|instanceof
name|Fault
condition|)
block|{
name|object
operator|=
operator|(
operator|(
name|Fault
operator|)
name|object
operator|)
operator|.
name|resolveFault
argument_list|(
name|this
argument_list|,
name|propertyName
argument_list|)
expr_stmt|;
name|writePropertyDirectly
argument_list|(
name|propertyName
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
return|return
name|object
return|;
block|}
comment|/**      * Returns a value of the property identified by a property path. Supports      * reading both mapped and unmapped properties. Unmapped properties are      * accessed in a manner consistent with JavaBeans specification.      *<p>      * Property path (or nested property) is a dot-separated path used to      * traverse object relationships until the final object is found. If a null      * object found while traversing path, null is returned. If a list is      * encountered in the middle of the path, CayenneRuntimeException is thrown.      * Unlike {@link #readPropertyDirectly(String)}, this method will resolve an      * object if it is HOLLOW.      *<p>      * Examples:      *</p>      *<ul>      *<li>Read this object property:<br>      *<code>String name = (String)artist.readNestedProperty("name");</code><br>      *<br>      *</li>      *<li>Read an object related to this object:<br>      *<code>Gallery g = (Gallery)paintingInfo.readNestedProperty("toPainting.toGallery");</code>      *<br>      *<br>      *</li>      *<li>Read a property of an object related to this object:<br>      *<code>String name = (String)painting.readNestedProperty("toArtist.artistName");</code>      *<br>      *<br>      *</li>      *<li>Read to-many relationship list:<br>      *<code>List exhibits = (List)painting.readNestedProperty("toGallery.exhibitArray");</code>      *<br>      *<br>      *</li>      *<li>Read to-many relationship in the middle of the path:<br>      *<code>List&lt;String&gt; names = (List&lt;String&gt;)artist.readNestedProperty("paintingArray.paintingName");</code>      *<br>      *<br>      *</li>      *</ul>      *      * @since 1.0.5      */
specifier|public
name|Object
name|readNestedProperty
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
operator|(
literal|null
operator|==
name|path
operator|)
operator|||
operator|(
literal|0
operator|==
name|path
operator|.
name|length
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"the path must be supplied in order to lookup a nested property"
argument_list|)
throw|;
block|}
name|int
name|dotIndex
init|=
name|path
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|dotIndex
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"the path is invalid because it starts with a period character"
argument_list|)
throw|;
block|}
if|if
condition|(
name|dotIndex
operator|==
name|path
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"the path is invalid because it ends with a period character"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|-
literal|1
operator|==
name|dotIndex
condition|)
block|{
return|return
name|readSimpleProperty
argument_list|(
name|path
argument_list|)
return|;
block|}
name|String
name|path0
init|=
name|path
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|dotIndex
argument_list|)
decl_stmt|;
name|String
name|pathRemainder
init|=
name|path
operator|.
name|substring
argument_list|(
name|dotIndex
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|// this is copied from the old code where the placement of a plus
comment|// character at the end of a segment of a property path would
comment|// simply strip out the plus. I am not entirely sure why this is
comment|// done. See unit test 'testReadNestedPropertyToManyInMiddle1'.
if|if
condition|(
literal|'+'
operator|==
name|path0
operator|.
name|charAt
argument_list|(
name|path0
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
condition|)
block|{
name|path0
operator|=
name|path0
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|path0
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|Object
name|property
init|=
name|readSimpleProperty
argument_list|(
name|path0
argument_list|)
decl_stmt|;
if|if
condition|(
name|property
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|else if
condition|(
name|property
operator|instanceof
name|DataObject
condition|)
block|{
return|return
operator|(
operator|(
name|DataObject
operator|)
name|property
operator|)
operator|.
name|readNestedProperty
argument_list|(
name|pathRemainder
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Cayenne
operator|.
name|readNestedProperty
argument_list|(
name|property
argument_list|,
name|pathRemainder
argument_list|)
return|;
block|}
block|}
name|Object
name|readSimpleProperty
parameter_list|(
name|String
name|property
parameter_list|)
block|{
comment|// side effect - resolves HOLLOW object
name|Object
name|object
init|=
name|readProperty
argument_list|(
name|property
argument_list|)
decl_stmt|;
comment|// if a null value is returned, there is still a chance to
comment|// find a non-persistent property via reflection
if|if
condition|(
name|object
operator|==
literal|null
condition|)
block|{
name|object
operator|=
name|PropertyUtils
operator|.
name|getProperty
argument_list|(
name|this
argument_list|,
name|property
argument_list|)
expr_stmt|;
block|}
return|return
name|object
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeProperty
parameter_list|(
name|String
name|propName
parameter_list|,
name|Object
name|val
parameter_list|)
block|{
name|Object
name|oldValue
init|=
name|readPropertyDirectly
argument_list|(
name|propName
argument_list|)
decl_stmt|;
name|beforePropertyWrite
argument_list|(
name|propName
argument_list|,
name|oldValue
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|writePropertyDirectly
argument_list|(
name|propName
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
specifier|public
name|void
name|removeToManyTarget
parameter_list|(
name|String
name|relName
parameter_list|,
name|DataObject
name|value
parameter_list|,
name|boolean
name|setReverse
parameter_list|)
block|{
comment|// Now do the rest of the normal handling (regardless of whether it was
comment|// flattened or not)
name|Object
name|holder
init|=
name|readProperty
argument_list|(
name|relName
argument_list|)
decl_stmt|;
comment|// call 'propertyChanged' AFTER readProperty as readProperty ensures
comment|// that this object fault is resolved
name|objectContext
operator|.
name|propertyChanged
argument_list|(
name|this
argument_list|,
name|relName
argument_list|,
name|value
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// TODO: andrus 8/20/2007 - can we optimize this somehow, avoiding type checking??
if|if
condition|(
name|holder
operator|instanceof
name|Collection
condition|)
block|{
operator|(
operator|(
name|Collection
argument_list|<
name|Object
argument_list|>
operator|)
name|holder
operator|)
operator|.
name|remove
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|holder
operator|instanceof
name|Map
condition|)
block|{
operator|(
operator|(
name|Map
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
operator|)
name|holder
operator|)
operator|.
name|remove
argument_list|(
name|getMapKey
argument_list|(
name|relName
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|setReverse
condition|)
block|{
name|unsetReverseRelationship
argument_list|(
name|relName
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
specifier|public
name|void
name|addToManyTarget
parameter_list|(
name|String
name|relName
parameter_list|,
name|DataObject
name|value
parameter_list|,
name|boolean
name|setReverse
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Attempt to add null target DataObject."
argument_list|)
throw|;
block|}
name|willConnect
argument_list|(
name|relName
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|// Now do the rest of the normal handling (regardless of whether it was
comment|// flattened or not)
name|Object
name|holder
init|=
name|readProperty
argument_list|(
name|relName
argument_list|)
decl_stmt|;
comment|// call 'propertyChanged' AFTER readProperty as readProperty ensures
comment|// that this object fault is resolved
name|objectContext
operator|.
name|propertyChanged
argument_list|(
name|this
argument_list|,
name|relName
argument_list|,
literal|null
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|// TODO: andrus 8/20/2007 - can we optimize this somehow, avoiding type checking??
if|if
condition|(
name|holder
operator|instanceof
name|Collection
condition|)
block|{
operator|(
operator|(
name|Collection
argument_list|<
name|Object
argument_list|>
operator|)
name|holder
operator|)
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|holder
operator|instanceof
name|Map
condition|)
block|{
operator|(
operator|(
name|Map
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
operator|)
name|holder
operator|)
operator|.
name|put
argument_list|(
name|getMapKey
argument_list|(
name|relName
argument_list|,
name|value
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setReverse
condition|)
block|{
name|setReverseRelationship
argument_list|(
name|relName
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Sets the relationships to the specified<code>DataObject</code> objects.      *      *<p>      * New relationships will be created with      * {@link #addToManyTarget(String, org.apache.cayenne.DataObject, boolean)},      * already established relationships stay untouched. Missing relationships      * will be removed with      * {@link #removeToManyTarget(String, org.apache.cayenne.DataObject, boolean)}      * and returnd as List. You may delete them manually.      *</p>      *      *<p>      * Notice: Moving an object relationship to another object, is still needing      * an manually "unregister" from the first object by      * {@link #removeToManyTarget(String, org.apache.cayenne.DataObject, boolean)}      *</p>      *      * @param relName      *            name of the relation      * @param values      *<code>DataObject</code> objects of this      *<code>Collection</code> are set to the object. No changes will      *            be made to the the<code>Collection</code>, a copy is used. It      *            is safe to pass a persisted<code>Collection</code> of another      *            object.      * @param setReverse      *            update reverse relationships      * @return<code>List&lt;? extends DataObject&gt;</code> of unrelated      *         DataObjects. If no relationship was removed an empty List is      *         returned.      * @throws IllegalArgumentException      *             if no relationship could be read by relName, or if the passed      *<code>Collection</code> is null. To clear all relationships      *             use an empty<code>Collection</code>      * @throws UnsupportedOperationException      *             if the relation Collection Type is neither      *<code>java.util.Collection</code> nor      *<code>java.util.Map</code>      * @since 4.0      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|List
argument_list|<
name|?
extends|extends
name|DataObject
argument_list|>
name|setToManyTarget
parameter_list|(
name|String
name|relName
parameter_list|,
name|Collection
argument_list|<
name|?
extends|extends
name|DataObject
argument_list|>
name|values
parameter_list|,
name|boolean
name|setReverse
parameter_list|)
block|{
if|if
condition|(
name|values
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"values Collection is null. To clear all relationships use an empty Collection"
argument_list|)
throw|;
block|}
name|Object
name|property
init|=
name|readProperty
argument_list|(
name|relName
argument_list|)
decl_stmt|;
if|if
condition|(
name|property
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"unknown relName "
operator|+
name|relName
argument_list|)
throw|;
block|}
name|Collection
argument_list|<
name|DataObject
argument_list|>
name|old
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|property
operator|instanceof
name|Map
condition|)
block|{
name|old
operator|=
operator|(
operator|(
name|Map
operator|)
name|property
operator|)
operator|.
name|values
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|property
operator|instanceof
name|Collection
condition|)
block|{
name|old
operator|=
operator|(
name|Collection
operator|)
name|property
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"setToManyTarget operates only with Map or Collection types"
argument_list|)
throw|;
block|}
comment|// operate on a copy of passed collection
name|values
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|values
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|DataObject
argument_list|>
name|removedObjects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// remove all relationships, which are missing in passed collection
name|Object
index|[]
name|oldValues
init|=
name|old
operator|.
name|toArray
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|obj
range|:
name|oldValues
control|)
block|{
if|if
condition|(
operator|!
name|values
operator|.
name|contains
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|DataObject
name|obj2
init|=
operator|(
name|DataObject
operator|)
name|obj
decl_stmt|;
name|removeToManyTarget
argument_list|(
name|relName
argument_list|,
name|obj2
argument_list|,
name|setReverse
argument_list|)
expr_stmt|;
comment|// collect objects whose relationship was removed
name|removedObjects
operator|.
name|add
argument_list|(
operator|(
name|DataObject
operator|)
name|obj2
argument_list|)
expr_stmt|;
block|}
block|}
comment|// dont add elements which are already present
for|for
control|(
name|Object
name|obj
range|:
name|old
control|)
block|{
name|values
operator|.
name|remove
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
comment|// add new elements
for|for
control|(
name|DataObject
name|obj
range|:
name|values
control|)
block|{
name|addToManyTarget
argument_list|(
name|relName
argument_list|,
name|obj
argument_list|,
name|setReverse
argument_list|)
expr_stmt|;
block|}
return|return
name|removedObjects
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setToOneTarget
parameter_list|(
name|String
name|relationshipName
parameter_list|,
name|DataObject
name|value
parameter_list|,
name|boolean
name|setReverse
parameter_list|)
block|{
name|willConnect
argument_list|(
name|relationshipName
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|Object
name|oldTarget
init|=
name|readProperty
argument_list|(
name|relationshipName
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldTarget
operator|==
name|value
condition|)
block|{
return|return;
block|}
name|getObjectContext
argument_list|()
operator|.
name|propertyChanged
argument_list|(
name|this
argument_list|,
name|relationshipName
argument_list|,
name|oldTarget
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|setReverse
condition|)
block|{
comment|// unset old reverse relationship
if|if
condition|(
name|oldTarget
operator|instanceof
name|DataObject
condition|)
block|{
name|unsetReverseRelationship
argument_list|(
name|relationshipName
argument_list|,
operator|(
name|DataObject
operator|)
name|oldTarget
argument_list|)
expr_stmt|;
block|}
comment|// set new reverse relationship
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|setReverseRelationship
argument_list|(
name|relationshipName
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|// readProperty will call this
comment|//objectContext.prepareForAccess(this, relationshipName, false);
name|writePropertyDirectly
argument_list|(
name|relationshipName
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**      * Called before establishing a relationship with another object. Applies      * "persistence by reachability" logic, pulling one of the two objects to a      * DataConext of another object in case one of the objects is transient. If      * both objects are persistent, and they don't have the same DataContext,      * CayenneRuntimeException is thrown.      *      * @since 1.2      */
specifier|protected
name|void
name|willConnect
parameter_list|(
name|String
name|relationshipName
parameter_list|,
name|Persistent
name|object
parameter_list|)
block|{
comment|// first handle most common case - both objects are in the same
comment|// ObjectContext or target is null
if|if
condition|(
name|object
operator|==
literal|null
operator|||
name|this
operator|.
name|getObjectContext
argument_list|()
operator|==
name|object
operator|.
name|getObjectContext
argument_list|()
condition|)
block|{
return|return;
block|}
if|else if
condition|(
name|this
operator|.
name|getObjectContext
argument_list|()
operator|==
literal|null
operator|&&
name|object
operator|.
name|getObjectContext
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|object
operator|.
name|getObjectContext
argument_list|()
operator|.
name|registerNewObject
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|this
operator|.
name|getObjectContext
argument_list|()
operator|!=
literal|null
operator|&&
name|object
operator|.
name|getObjectContext
argument_list|()
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|getObjectContext
argument_list|()
operator|.
name|registerNewObject
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Cannot set object as destination of relationship %s"
operator|+
literal|" because it is in a different ObjectContext"
argument_list|,
name|relationshipName
argument_list|)
throw|;
block|}
block|}
comment|/**      * Initializes reverse relationship from object<code>val</code> to this      * object.      *      * @param relName      *            name of relationship from this object to<code>val</code>.      */
specifier|protected
name|void
name|setReverseRelationship
parameter_list|(
name|String
name|relName
parameter_list|,
name|DataObject
name|val
parameter_list|)
block|{
name|ObjRelationship
name|rel
init|=
name|objectContext
operator|.
name|getEntityResolver
argument_list|()
operator|.
name|getObjEntity
argument_list|(
name|objectId
operator|.
name|getEntityName
argument_list|()
argument_list|)
operator|.
name|getRelationship
argument_list|(
name|relName
argument_list|)
decl_stmt|;
name|ObjRelationship
name|revRel
init|=
name|rel
operator|.
name|getReverseRelationship
argument_list|()
decl_stmt|;
if|if
condition|(
name|revRel
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|revRel
operator|.
name|isToMany
argument_list|()
condition|)
block|{
name|val
operator|.
name|addToManyTarget
argument_list|(
name|revRel
operator|.
name|getName
argument_list|()
argument_list|,
name|this
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|.
name|setToOneTarget
argument_list|(
name|revRel
operator|.
name|getName
argument_list|()
argument_list|,
name|this
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Removes current object from reverse relationship of object      *<code>val</code> to this object.      */
specifier|protected
name|void
name|unsetReverseRelationship
parameter_list|(
name|String
name|relName
parameter_list|,
name|DataObject
name|val
parameter_list|)
block|{
name|EntityResolver
name|resolver
init|=
name|objectContext
operator|.
name|getEntityResolver
argument_list|()
decl_stmt|;
name|ObjEntity
name|entity
init|=
name|resolver
operator|.
name|getObjEntity
argument_list|(
name|objectId
operator|.
name|getEntityName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|entity
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"DataObject's entity is unmapped, objectId: "
operator|+
name|objectId
argument_list|)
throw|;
block|}
name|ObjRelationship
name|rel
init|=
name|entity
operator|.
name|getRelationship
argument_list|(
name|relName
argument_list|)
decl_stmt|;
name|ObjRelationship
name|revRel
init|=
name|rel
operator|.
name|getReverseRelationship
argument_list|()
decl_stmt|;
if|if
condition|(
name|revRel
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|revRel
operator|.
name|isToMany
argument_list|()
condition|)
block|{
name|val
operator|.
name|removeToManyTarget
argument_list|(
name|revRel
operator|.
name|getName
argument_list|()
argument_list|,
name|this
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|.
name|setToOneTarget
argument_list|(
name|revRel
operator|.
name|getName
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|setPersistenceState
parameter_list|(
name|int
name|persistenceState
parameter_list|)
block|{
name|this
operator|.
name|persistenceState
operator|=
name|persistenceState
expr_stmt|;
block|}
comment|/**      * @since 1.1      */
annotation|@
name|Override
specifier|public
name|long
name|getSnapshotVersion
parameter_list|()
block|{
return|return
name|snapshotVersion
return|;
block|}
comment|/**      * @since 1.1      */
annotation|@
name|Override
specifier|public
name|void
name|setSnapshotVersion
parameter_list|(
name|long
name|snapshotVersion
parameter_list|)
block|{
name|this
operator|.
name|snapshotVersion
operator|=
name|snapshotVersion
expr_stmt|;
block|}
comment|/**      * Performs property validation of the object, appending any validation      * failures to the provided validationResult object. This method is invoked      * from "validateFor.." before committing a NEW or MODIFIED object to the      * database. Validation includes checking for null values and value sizes.      * CayenneDataObject subclasses may override this method, calling super.      *      * @since 1.1      */
specifier|protected
name|void
name|validateForSave
parameter_list|(
name|ValidationResult
name|validationResult
parameter_list|)
block|{
name|ObjEntity
name|objEntity
init|=
name|getObjectContext
argument_list|()
operator|.
name|getEntityResolver
argument_list|()
operator|.
name|getObjEntity
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|objEntity
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"No ObjEntity mapping found for DataObject %s"
argument_list|,
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
comment|// validate mandatory attributes
name|Map
argument_list|<
name|String
argument_list|,
name|ValidationFailure
argument_list|>
name|failedDbAttributes
init|=
literal|null
decl_stmt|;
for|for
control|(
name|ObjAttribute
name|next
range|:
name|objEntity
operator|.
name|getAttributes
argument_list|()
control|)
block|{
comment|// TODO: andrus, 2/20/2007 - handle embedded attribute
if|if
condition|(
name|next
operator|instanceof
name|EmbeddedAttribute
condition|)
block|{
continue|continue;
block|}
name|DbAttribute
name|dbAttribute
init|=
name|next
operator|.
name|getDbAttribute
argument_list|()
decl_stmt|;
if|if
condition|(
name|dbAttribute
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"ObjAttribute '%s"
operator|+
literal|"' does not have a corresponding DbAttribute"
argument_list|,
name|next
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
comment|// pk may still be generated
if|if
condition|(
name|dbAttribute
operator|.
name|isPrimaryKey
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|Object
name|value
init|=
name|this
operator|.
name|readPropertyDirectly
argument_list|(
name|next
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|dbAttribute
operator|.
name|isMandatory
argument_list|()
condition|)
block|{
name|ValidationFailure
name|failure
init|=
name|BeanValidationFailure
operator|.
name|validateNotNull
argument_list|(
name|this
argument_list|,
name|next
operator|.
name|getName
argument_list|()
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|failure
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|failedDbAttributes
operator|==
literal|null
condition|)
block|{
name|failedDbAttributes
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|failedDbAttributes
operator|.
name|put
argument_list|(
name|dbAttribute
operator|.
name|getName
argument_list|()
argument_list|,
name|failure
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|// validate length
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|dbAttribute
operator|.
name|getMaxLength
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|getClass
argument_list|()
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|int
name|len
init|=
name|Array
operator|.
name|getLength
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|dbAttribute
operator|.
name|getMaxLength
argument_list|()
condition|)
block|{
name|String
name|message
init|=
literal|"\""
operator|+
name|next
operator|.
name|getName
argument_list|()
operator|+
literal|"\" exceeds maximum allowed length ("
operator|+
name|dbAttribute
operator|.
name|getMaxLength
argument_list|()
operator|+
literal|" bytes): "
operator|+
name|len
decl_stmt|;
name|validationResult
operator|.
name|addFailure
argument_list|(
operator|new
name|BeanValidationFailure
argument_list|(
name|this
argument_list|,
name|next
operator|.
name|getName
argument_list|()
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|value
operator|instanceof
name|CharSequence
condition|)
block|{
name|int
name|len
init|=
operator|(
operator|(
name|CharSequence
operator|)
name|value
operator|)
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|dbAttribute
operator|.
name|getMaxLength
argument_list|()
condition|)
block|{
name|String
name|message
init|=
literal|"\""
operator|+
name|next
operator|.
name|getName
argument_list|()
operator|+
literal|"\" exceeds maximum allowed length ("
operator|+
name|dbAttribute
operator|.
name|getMaxLength
argument_list|()
operator|+
literal|" chars): "
operator|+
name|len
decl_stmt|;
name|validationResult
operator|.
name|addFailure
argument_list|(
operator|new
name|BeanValidationFailure
argument_list|(
name|this
argument_list|,
name|next
operator|.
name|getName
argument_list|()
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// validate mandatory relationships
for|for
control|(
specifier|final
name|ObjRelationship
name|relationship
range|:
name|objEntity
operator|.
name|getRelationships
argument_list|()
control|)
block|{
name|List
argument_list|<
name|DbRelationship
argument_list|>
name|dbRels
init|=
name|relationship
operator|.
name|getDbRelationships
argument_list|()
decl_stmt|;
if|if
condition|(
name|dbRels
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
comment|// skip db relationships that we can't validate or that can't be invalid here
comment|// can't handle paths longer than two db relationships
comment|// see ObjRelationship.recalculateReadOnlyValue() for more info
if|if
condition|(
name|relationship
operator|.
name|isSourceIndependentFromTargetChange
argument_list|()
condition|)
block|{
continue|continue;
block|}
comment|// if db relationship is not based on a PK and is based on mandatory
comment|// attributes, see if we have a target object set
comment|// relationship will be validated only if all db path has mandatory
comment|// db relationships
name|boolean
name|validate
init|=
literal|true
decl_stmt|;
for|for
control|(
name|DbRelationship
name|dbRelationship
range|:
name|dbRels
control|)
block|{
for|for
control|(
name|DbJoin
name|join
range|:
name|dbRelationship
operator|.
name|getJoins
argument_list|()
control|)
block|{
name|DbAttribute
name|source
init|=
name|join
operator|.
name|getSource
argument_list|()
decl_stmt|;
if|if
condition|(
name|source
operator|.
name|isMandatory
argument_list|()
condition|)
block|{
comment|// clear attribute failures...
if|if
condition|(
name|failedDbAttributes
operator|!=
literal|null
operator|&&
operator|!
name|failedDbAttributes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|failedDbAttributes
operator|.
name|remove
argument_list|(
name|source
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// do not validate if the relation is based on
comment|// multiple keys with some that can be nullable.
name|validate
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|validate
condition|)
block|{
name|Object
name|value
init|=
name|this
operator|.
name|readPropertyDirectly
argument_list|(
name|relationship
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|ValidationFailure
name|failure
init|=
name|BeanValidationFailure
operator|.
name|validateNotNull
argument_list|(
name|this
argument_list|,
name|relationship
operator|.
name|getName
argument_list|()
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|failure
operator|!=
literal|null
condition|)
block|{
name|validationResult
operator|.
name|addFailure
argument_list|(
name|failure
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// deal with previously found attribute failures...
if|if
condition|(
name|failedDbAttributes
operator|!=
literal|null
operator|&&
operator|!
name|failedDbAttributes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|ValidationFailure
name|failure
range|:
name|failedDbAttributes
operator|.
name|values
argument_list|()
control|)
block|{
name|validationResult
operator|.
name|addFailure
argument_list|(
name|failure
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Calls {@link #validateForSave(ValidationResult)}. CayenneDataObject      * subclasses may override it providing validation logic that should be      * executed for the newly created objects before saving them.      *      * @since 1.1      */
annotation|@
name|Override
specifier|public
name|void
name|validateForInsert
parameter_list|(
name|ValidationResult
name|validationResult
parameter_list|)
block|{
name|validateForSave
argument_list|(
name|validationResult
argument_list|)
expr_stmt|;
block|}
comment|/**      * Calls {@link #validateForSave(ValidationResult)}. CayenneDataObject      * subclasses may override it providing validation logic that should be      * executed for the modified objects before saving them.      *      * @since 1.1      */
annotation|@
name|Override
specifier|public
name|void
name|validateForUpdate
parameter_list|(
name|ValidationResult
name|validationResult
parameter_list|)
block|{
name|validateForSave
argument_list|(
name|validationResult
argument_list|)
expr_stmt|;
block|}
comment|/**      * This implementation does nothing. CayenneDataObject subclasses may      * override it providing validation logic that should be executed for the      * deleted objects before committing them.      *      * @since 1.1      */
annotation|@
name|Override
specifier|public
name|void
name|validateForDelete
parameter_list|(
name|ValidationResult
name|validationResult
parameter_list|)
block|{
comment|// does nothing
block|}
comment|/**      * @since 1.2      */
annotation|@
name|Override
specifier|public
name|void
name|setObjectContext
parameter_list|(
name|ObjectContext
name|objectContext
parameter_list|)
block|{
name|this
operator|.
name|objectContext
operator|=
name|objectContext
expr_stmt|;
if|if
condition|(
name|objectContext
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|persistenceState
operator|=
name|PersistenceState
operator|.
name|TRANSIENT
expr_stmt|;
block|}
block|}
comment|/**      * Serialization support.      * Will write down persistenceState and objectId, delegating data serialization down to sub-classes.      */
specifier|private
name|void
name|writeObject
parameter_list|(
name|ObjectOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|writeSerialized
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
comment|/**      * Serialization support.      * Will read persistenceState and objectId, delegating data serialization down to sub-classes.      */
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|readSerialized
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|writeSerialized
parameter_list|(
name|ObjectOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|persistenceState
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeObject
argument_list|(
name|objectId
argument_list|)
expr_stmt|;
if|if
condition|(
name|persistenceState
operator|==
name|PersistenceState
operator|.
name|COMMITTED
operator|||
name|persistenceState
operator|==
name|PersistenceState
operator|.
name|HOLLOW
condition|)
block|{
return|return;
block|}
name|writeState
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|readSerialized
parameter_list|(
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|this
operator|.
name|persistenceState
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|this
operator|.
name|objectId
operator|=
operator|(
name|ObjectId
operator|)
name|in
operator|.
name|readObject
argument_list|()
expr_stmt|;
if|if
condition|(
name|persistenceState
operator|==
name|PersistenceState
operator|.
name|COMMITTED
operator|||
name|persistenceState
operator|==
name|PersistenceState
operator|.
name|HOLLOW
condition|)
block|{
name|persistenceState
operator|=
name|PersistenceState
operator|.
name|HOLLOW
expr_stmt|;
return|return;
block|}
name|readState
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|writeState
parameter_list|(
name|ObjectOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
comment|// no additional info for base class
block|}
specifier|protected
name|void
name|readState
parameter_list|(
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
comment|// no additional info for base class
block|}
comment|/**      * A variation of "toString" method, that may be more efficient in some      * cases. For example when printing a list of objects into the same String.      */
specifier|public
name|StringBuffer
name|toStringBuffer
parameter_list|(
name|StringBuffer
name|buffer
parameter_list|,
name|boolean
name|fullDesc
parameter_list|)
block|{
name|String
name|id
init|=
operator|(
name|objectId
operator|!=
literal|null
operator|)
condition|?
name|objectId
operator|.
name|toString
argument_list|()
else|:
literal|"<no id>"
decl_stmt|;
name|String
name|state
init|=
name|PersistenceState
operator|.
name|persistenceStateName
argument_list|(
name|persistenceState
argument_list|)
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
operator|.
name|append
argument_list|(
name|id
argument_list|)
operator|.
name|append
argument_list|(
literal|"; "
argument_list|)
operator|.
name|append
argument_list|(
name|state
argument_list|)
operator|.
name|append
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullDesc
condition|)
block|{
name|appendProperties
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|buffer
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
specifier|protected
name|void
name|appendProperties
parameter_list|(
name|StringBuffer
name|buffer
parameter_list|)
block|{
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|toStringBuffer
argument_list|(
operator|new
name|StringBuffer
argument_list|()
argument_list|,
literal|true
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

