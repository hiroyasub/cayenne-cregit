begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************  *   Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing,  *  software distributed under the License is distributed on an  *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *  KIND, either express or implied.  See the License for the  *  specific language governing permissions and limitations  *  under the License.  ****************************************************************/
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|wocompat
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_comment
comment|/**  * Utility class to find resources (files, etc.), using a preconfigured strategy.  *   * @deprecated since 3.1 deprecated in favor of injectable  *             org.apache.cayenne.resource.ResourceLocator.  */
end_comment

begin_class
annotation|@
name|Deprecated
class|class
name|ResourceLocator
block|{
specifier|private
specifier|static
name|Log
name|logObj
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ResourceLocator
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// properties for enabling/disabling certain lookup strategies
specifier|protected
name|boolean
name|skipAbsolutePath
decl_stmt|;
specifier|protected
name|boolean
name|skipClasspath
decl_stmt|;
specifier|protected
name|boolean
name|skipCurrentDirectory
decl_stmt|;
comment|// ClassLoader used for resource loading
specifier|protected
name|ClassLoader
name|classLoader
decl_stmt|;
comment|/**      * Looks up a file in the current directory.      *       * @return file object matching the name, or<code>null</code> if<code>file</code>      *         can not be found is not readable.      */
specifier|public
specifier|static
name|File
name|findFileInCurrentDirectory
parameter_list|(
name|String
name|name
parameter_list|)
block|{
comment|// look in the current directory
name|String
name|currentDirPath
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"user.dir"
argument_list|)
operator|+
name|File
operator|.
name|separator
operator|+
name|name
decl_stmt|;
try|try
block|{
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|currentDirPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|exists
argument_list|()
operator|&&
name|file
operator|.
name|canRead
argument_list|()
condition|)
block|{
name|logObj
operator|.
name|debug
argument_list|(
literal|"file found in current directory: "
operator|+
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logObj
operator|.
name|debug
argument_list|(
literal|"file not found in current directory: "
operator|+
name|name
argument_list|)
expr_stmt|;
name|file
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|file
return|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|se
parameter_list|)
block|{
name|logObj
operator|.
name|debug
argument_list|(
literal|"permission denied reading file: "
operator|+
name|currentDirPath
argument_list|,
name|se
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Looks up the URL for the named resource using the specified ClassLoader.      */
specifier|public
specifier|static
name|URL
name|findURLInClassLoader
parameter_list|(
name|String
name|name
parameter_list|,
name|ClassLoader
name|loader
parameter_list|)
block|{
name|URL
name|url
init|=
name|loader
operator|.
name|getResource
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|url
operator|!=
literal|null
condition|)
block|{
name|logObj
operator|.
name|debug
argument_list|(
literal|"URL found with classloader: "
operator|+
name|url
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logObj
operator|.
name|debug
argument_list|(
literal|"URL not found with classloader: "
operator|+
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|url
return|;
block|}
comment|/**      * @since 3.0      */
specifier|public
name|URL
name|getResource
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|findResource
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**      * Returns a resource URL using the lookup strategy configured for this      * Resourcelocator or<code>null</code> if no readable resource can be found for the      * given name.      */
specifier|public
name|URL
name|findResource
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|willSkipAbsolutePath
argument_list|()
condition|)
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|isAbsolute
argument_list|()
operator|&&
name|f
operator|.
name|exists
argument_list|()
condition|)
block|{
name|logObj
operator|.
name|debug
argument_list|(
literal|"File found at absolute path: "
operator|+
name|name
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|f
operator|.
name|toURL
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|ex
parameter_list|)
block|{
comment|// ignoring
name|logObj
operator|.
name|debug
argument_list|(
literal|"Malformed url, ignoring."
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|logObj
operator|.
name|debug
argument_list|(
literal|"No file at absolute path: "
operator|+
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|willSkipCurrentDirectory
argument_list|()
condition|)
block|{
name|File
name|f
init|=
name|findFileInCurrentDirectory
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
block|{
try|try
block|{
return|return
name|f
operator|.
name|toURL
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|ex
parameter_list|)
block|{
comment|// ignoring
name|logObj
operator|.
name|debug
argument_list|(
literal|"Malformed url, ignoring"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|willSkipClasspath
argument_list|()
condition|)
block|{
name|URL
name|url
init|=
name|findURLInClassLoader
argument_list|(
name|name
argument_list|,
name|getClassLoader
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|url
operator|!=
literal|null
condition|)
block|{
return|return
name|url
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Returns a directory resource URL using the lookup strategy configured for this      * ResourceLocator or<code>null</code> if no readable resource can be found for the      * given name. The returned resource is assumed to be a directory, so the returned URL      * will be in a directory format (with "/" at the end).      */
specifier|public
name|URL
name|findDirectoryResource
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|URL
name|url
init|=
name|findResource
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|url
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
try|try
block|{
name|String
name|urlSt
init|=
name|url
operator|.
name|toExternalForm
argument_list|()
decl_stmt|;
return|return
operator|(
name|urlSt
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
operator|)
condition|?
name|url
else|:
operator|new
name|URL
argument_list|(
name|urlSt
operator|+
literal|"/"
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|ex
parameter_list|)
block|{
comment|// ignoring...
name|logObj
operator|.
name|debug
argument_list|(
literal|"Malformed URL, ignoring."
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Returns true if no lookups are performed in the current directory.      */
specifier|public
name|boolean
name|willSkipCurrentDirectory
parameter_list|()
block|{
return|return
name|skipCurrentDirectory
return|;
block|}
comment|/**      * Sets "skipCurrentDirectory" property.      */
specifier|public
name|void
name|setSkipCurrentDirectory
parameter_list|(
name|boolean
name|skipCurDir
parameter_list|)
block|{
name|this
operator|.
name|skipCurrentDirectory
operator|=
name|skipCurDir
expr_stmt|;
block|}
comment|/**      * Returns true if no lookups are performed in the classpath.      */
specifier|public
name|boolean
name|willSkipClasspath
parameter_list|()
block|{
return|return
name|skipClasspath
return|;
block|}
comment|/**      * Sets "skipClasspath" property.      */
specifier|public
name|void
name|setSkipClasspath
parameter_list|(
name|boolean
name|skipClasspath
parameter_list|)
block|{
name|this
operator|.
name|skipClasspath
operator|=
name|skipClasspath
expr_stmt|;
block|}
comment|/**      * Returns the ClassLoader associated with this ResourceLocator.      */
specifier|private
name|ClassLoader
name|getClassLoader
parameter_list|()
block|{
name|ClassLoader
name|loader
init|=
name|this
operator|.
name|classLoader
decl_stmt|;
if|if
condition|(
name|loader
operator|==
literal|null
condition|)
block|{
name|loader
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getContextClassLoader
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|loader
operator|==
literal|null
condition|)
block|{
name|loader
operator|=
name|getClass
argument_list|()
operator|.
name|getClassLoader
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|loader
operator|==
literal|null
condition|)
block|{
name|loader
operator|=
name|ClassLoader
operator|.
name|getSystemClassLoader
argument_list|()
expr_stmt|;
block|}
return|return
name|loader
return|;
block|}
comment|/**      * Returns true if no lookups are performed using path as absolute path.      */
specifier|public
name|boolean
name|willSkipAbsolutePath
parameter_list|()
block|{
return|return
name|skipAbsolutePath
return|;
block|}
comment|/**      * Sets "skipAbsolutePath" property.      */
specifier|public
name|void
name|setSkipAbsolutePath
parameter_list|(
name|boolean
name|skipAbsPath
parameter_list|)
block|{
name|this
operator|.
name|skipAbsolutePath
operator|=
name|skipAbsPath
expr_stmt|;
block|}
block|}
end_class

end_unit

