begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************  *   Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing,  *  software distributed under the License is distributed on an  *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *  KIND, either express or implied.  See the License for the  *  specific language governing permissions and limitations  *  under the License.  ****************************************************************/
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|access
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|DataObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|DataRow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|ObjectContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|ObjectId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|PersistenceState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|Persistent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|access
operator|.
name|ObjectDiff
operator|.
name|ArcOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|access
operator|.
name|event
operator|.
name|SnapshotEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|access
operator|.
name|event
operator|.
name|SnapshotEventListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|GraphChangeHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|GraphDiff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|GraphManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|NodeCreateOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|NodeDeleteOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|NodeDiff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|NodePropertyChangeOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|DataMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|DbEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|ObjEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|Procedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|query
operator|.
name|ObjectIdQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|query
operator|.
name|PrefetchTreeNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|query
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|query
operator|.
name|QueryMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|query
operator|.
name|RefreshQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|query
operator|.
name|SQLResultSetMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|AttributeProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|ClassDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|PropertyVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|ToManyProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|ToOneProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|collections
operator|.
name|map
operator|.
name|AbstractReferenceMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|collections
operator|.
name|map
operator|.
name|ReferenceMap
import|;
end_import

begin_comment
comment|/**  * ObjectStore stores objects using their ObjectId as a key. It works as a dedicated  * object cache for a DataContext. Users rarely need to access ObjectStore directly, as  * DataContext serves as a facade, providing cover methods for most ObjectStore  * operations.  *   * @since 1.0  * @author Andrus Adamchik  */
end_comment

begin_comment
comment|// Synchronization Note: There is often a need to do double synchronize on an ObjectStore
end_comment

begin_comment
comment|// and an underlying DataRowCache. To avoid deadlocks, Cayenne consistently follows the
end_comment

begin_comment
comment|// policy of locking an ObjectStore first, and then locking DataRowStore. This pattern
end_comment

begin_comment
comment|// must be followed in any new related developments.
end_comment

begin_class
specifier|public
class|class
name|ObjectStore
implements|implements
name|Serializable
implements|,
name|SnapshotEventListener
implements|,
name|GraphManager
block|{
comment|/**      * Factory method to create default Map for storing registered objects.      *       * @since 3.0      * @return a map with hard referenced keys and weak referenced values.      */
specifier|static
name|Map
argument_list|<
name|Object
argument_list|,
name|Persistent
argument_list|>
name|createObjectMap
parameter_list|()
block|{
return|return
operator|new
name|ReferenceMap
argument_list|(
name|AbstractReferenceMap
operator|.
name|HARD
argument_list|,
name|AbstractReferenceMap
operator|.
name|WEAK
argument_list|)
return|;
block|}
specifier|protected
name|Map
argument_list|<
name|Object
argument_list|,
name|Persistent
argument_list|>
name|objectMap
decl_stmt|;
specifier|protected
name|Map
argument_list|<
name|Object
argument_list|,
name|ObjectDiff
argument_list|>
name|changes
decl_stmt|;
comment|// a sequential id used to tag GraphDiffs so that they can later be sorted in the
comment|// original creation order
name|int
name|currentDiffId
decl_stmt|;
comment|/**      * Stores a reference to the DataRowStore.      *<p>      *<i>Serialization note:</i> It is up to the owner of this ObjectStore to initialize      * DataRowStore after deserialization of this object. ObjectStore will not know how to      * restore the DataRowStore by itself.      *</p>      */
specifier|protected
specifier|transient
name|DataRowStore
name|dataRowCache
decl_stmt|;
comment|// used to avoid incorrect on-demand DataRowStore initialization after deserialization
specifier|private
name|boolean
name|dataRowCacheSet
decl_stmt|;
specifier|private
name|Collection
argument_list|<
name|GraphDiff
argument_list|>
name|lifecycleEventInducedChanges
decl_stmt|;
comment|/**      * The DataContext that owns this ObjectStore.      */
specifier|protected
name|DataContext
name|context
decl_stmt|;
specifier|public
name|ObjectStore
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ObjectStore
parameter_list|(
name|DataRowStore
name|dataRowCache
parameter_list|)
block|{
name|this
argument_list|(
name|dataRowCache
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates an ObjectStore with {@link DataRowStore} and a map to use for storing      * registered objects. Passed map doesn't require any special synchronization      * behavior, as ObjectStore is synchronized itself.      *       * @since 3.0      */
specifier|public
name|ObjectStore
parameter_list|(
name|DataRowStore
name|dataRowCache
parameter_list|,
name|Map
argument_list|<
name|Object
argument_list|,
name|Persistent
argument_list|>
name|objectMap
parameter_list|)
block|{
name|setDataRowCache
argument_list|(
name|dataRowCache
argument_list|)
expr_stmt|;
name|this
operator|.
name|objectMap
operator|=
name|objectMap
operator|!=
literal|null
condition|?
name|objectMap
else|:
name|ObjectStore
operator|.
name|createObjectMap
argument_list|()
expr_stmt|;
name|this
operator|.
name|changes
operator|=
operator|new
name|HashMap
argument_list|<
name|Object
argument_list|,
name|ObjectDiff
argument_list|>
argument_list|()
expr_stmt|;
block|}
comment|/**      * @since 3.0      */
name|void
name|childContextSyncStarted
parameter_list|()
block|{
name|lifecycleEventInducedChanges
operator|=
operator|new
name|ArrayList
argument_list|<
name|GraphDiff
argument_list|>
argument_list|()
expr_stmt|;
block|}
comment|/**      * @since 3.0      */
name|void
name|childContextSyncStopped
parameter_list|()
block|{
name|lifecycleEventInducedChanges
operator|=
literal|null
expr_stmt|;
block|}
comment|/**      * @since 3.0      */
name|Collection
argument_list|<
name|GraphDiff
argument_list|>
name|getLifecycleEventInducedChanges
parameter_list|()
block|{
return|return
name|lifecycleEventInducedChanges
operator|!=
literal|null
condition|?
name|lifecycleEventInducedChanges
else|:
name|Collections
operator|.
name|EMPTY_LIST
return|;
block|}
name|void
name|registerLifecycleEventInducedChange
parameter_list|(
name|GraphDiff
name|diff
parameter_list|)
block|{
if|if
condition|(
name|ChildDiffLoader
operator|.
name|isProcessingChildDiff
argument_list|()
condition|)
block|{
comment|// reset so that subsequent event-induced changes could get registered...
name|ChildDiffLoader
operator|.
name|setExternalChange
argument_list|(
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lifecycleEventInducedChanges
operator|.
name|add
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Registers object change.      *       * @since 1.2      */
specifier|synchronized
name|ObjectDiff
name|registerDiff
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|NodeDiff
name|diff
parameter_list|)
block|{
if|if
condition|(
name|diff
operator|!=
literal|null
condition|)
block|{
name|diff
operator|.
name|setDiffId
argument_list|(
operator|++
name|currentDiffId
argument_list|)
expr_stmt|;
block|}
name|ObjectDiff
name|objectDiff
init|=
name|changes
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|objectDiff
operator|==
literal|null
condition|)
block|{
name|Persistent
name|object
init|=
name|objectMap
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|object
operator|.
name|getPersistenceState
argument_list|()
operator|==
name|PersistenceState
operator|.
name|COMMITTED
condition|)
block|{
name|object
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|MODIFIED
argument_list|)
expr_stmt|;
comment|// TODO: andrus 3/23/2006 snapshot versions are obsolete, but there is no
comment|// replacement yet, so we still need to handle them...
if|if
condition|(
name|object
operator|instanceof
name|DataObject
condition|)
block|{
name|DataObject
name|dataObject
init|=
operator|(
name|DataObject
operator|)
name|object
decl_stmt|;
name|DataRow
name|snapshot
init|=
name|getCachedSnapshot
argument_list|(
operator|(
name|ObjectId
operator|)
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|snapshot
operator|!=
literal|null
operator|&&
name|snapshot
operator|.
name|getVersion
argument_list|()
operator|!=
name|dataObject
operator|.
name|getSnapshotVersion
argument_list|()
condition|)
block|{
name|DataContextDelegate
name|delegate
init|=
name|context
operator|.
name|nonNullDelegate
argument_list|()
decl_stmt|;
if|if
condition|(
name|delegate
operator|.
name|shouldMergeChanges
argument_list|(
name|dataObject
argument_list|,
name|snapshot
argument_list|)
condition|)
block|{
name|ClassDescriptor
name|descriptor
init|=
name|context
operator|.
name|getEntityResolver
argument_list|()
operator|.
name|getClassDescriptor
argument_list|(
operator|(
operator|(
name|ObjectId
operator|)
name|nodeId
operator|)
operator|.
name|getEntityName
argument_list|()
argument_list|)
decl_stmt|;
name|DataRowUtils
operator|.
name|forceMergeWithSnapshot
argument_list|(
name|context
argument_list|,
name|descriptor
argument_list|,
name|dataObject
argument_list|,
name|snapshot
argument_list|)
expr_stmt|;
name|dataObject
operator|.
name|setSnapshotVersion
argument_list|(
name|snapshot
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
name|delegate
operator|.
name|finishedMergeChanges
argument_list|(
name|dataObject
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|objectDiff
operator|=
operator|new
name|ObjectDiff
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|objectDiff
operator|.
name|setDiffId
argument_list|(
operator|++
name|currentDiffId
argument_list|)
expr_stmt|;
name|changes
operator|.
name|put
argument_list|(
name|nodeId
argument_list|,
name|objectDiff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|diff
operator|!=
literal|null
condition|)
block|{
name|objectDiff
operator|.
name|addDiff
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
return|return
name|objectDiff
return|;
block|}
comment|/**      * Returns a number of objects currently registered with this ObjectStore.      *       * @since 1.2      */
specifier|public
name|int
name|registeredObjectsCount
parameter_list|()
block|{
return|return
name|objectMap
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Returns a number of query results cached by this object store. Note that each      * result is a list and can possibly contain a large number of entries.      *       * @since 1.2      * @deprecated since 3.0. See {@link DataContext#getQueryCache()}.      */
specifier|public
name|int
name|cachedQueriesCount
parameter_list|()
block|{
return|return
name|context
operator|!=
literal|null
operator|&&
name|context
operator|.
name|getQueryCache
argument_list|()
operator|!=
literal|null
condition|?
name|context
operator|.
name|getQueryCache
argument_list|()
operator|.
name|size
argument_list|()
else|:
literal|0
return|;
block|}
comment|/**      * Returns a DataRowStore associated with this ObjectStore.      */
specifier|public
name|DataRowStore
name|getDataRowCache
parameter_list|()
block|{
comment|// perform deferred initialization...
comment|// Andrus, 11/7/2005 - potential problem with on-demand deferred initialization is
comment|// that deserialized context won't receive any events... which maybe ok, since it
comment|// didn't while it was stored in serialized form.
if|if
condition|(
name|dataRowCache
operator|==
literal|null
operator|&&
name|context
operator|!=
literal|null
operator|&&
name|dataRowCacheSet
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|dataRowCache
operator|==
literal|null
condition|)
block|{
name|DataDomain
name|domain
init|=
name|context
operator|.
name|getParentDataDomain
argument_list|()
decl_stmt|;
if|if
condition|(
name|domain
operator|!=
literal|null
condition|)
block|{
name|setDataRowCache
argument_list|(
name|domain
operator|.
name|getSharedSnapshotCache
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|dataRowCache
return|;
block|}
comment|/**      * Sets parent DataRowStore. Registers to receive SnapshotEvents if the cache is      * configured to allow ObjectStores to receive such events.      */
comment|// note that as of 1.2, ObjectStore does not access DataRowStore directly when
comment|// retrieving snapshots. Instead it sends a query via the DataContext's channel so
comment|// that every element in the channel chain could intercept snapshot requests
specifier|public
name|void
name|setDataRowCache
parameter_list|(
name|DataRowStore
name|dataRowCache
parameter_list|)
block|{
if|if
condition|(
name|dataRowCache
operator|==
name|this
operator|.
name|dataRowCache
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|this
operator|.
name|dataRowCache
operator|!=
literal|null
operator|&&
name|dataRowCache
operator|.
name|getEventManager
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|dataRowCache
operator|.
name|getEventManager
argument_list|()
operator|.
name|removeListener
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|dataRowCache
operator|.
name|getSnapshotEventSubject
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|dataRowCache
operator|=
name|dataRowCache
expr_stmt|;
if|if
condition|(
name|dataRowCache
operator|!=
literal|null
operator|&&
name|dataRowCache
operator|.
name|getEventManager
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// setting itself as non-blocking listener,
comment|// since event sending thread will likely be locking sender's
comment|// ObjectStore and snapshot cache itself.
name|dataRowCache
operator|.
name|getEventManager
argument_list|()
operator|.
name|addNonBlockingListener
argument_list|(
name|this
argument_list|,
literal|"snapshotsChanged"
argument_list|,
name|SnapshotEvent
operator|.
name|class
argument_list|,
name|dataRowCache
operator|.
name|getSnapshotEventSubject
argument_list|()
argument_list|,
name|dataRowCache
argument_list|)
expr_stmt|;
block|}
name|dataRowCacheSet
operator|=
name|dataRowCache
operator|!=
literal|null
expr_stmt|;
block|}
comment|/**      * Invalidates a collection of DataObjects. Changes objects state to HOLLOW.      *       * @deprecated since 3.0, use {@link DataContext#invalidateObjects(Collection)} or      *             {@link RefreshQuery}.      */
specifier|public
specifier|synchronized
name|void
name|objectsInvalidated
parameter_list|(
name|Collection
name|objects
parameter_list|)
block|{
if|if
condition|(
name|context
operator|!=
literal|null
condition|)
block|{
name|context
operator|.
name|invalidateObjects
argument_list|(
name|objects
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Evicts a collection of DataObjects from the ObjectStore, invalidates the underlying      * cache snapshots. Changes objects state to TRANSIENT. This method can be used for      * manual cleanup of Cayenne cache.      *       * @see #objectsInvalidated(Collection)      */
comment|// this method is exactly the same as "objectsInvalidated", only additionally it
comment|// throws out registered objects
specifier|public
specifier|synchronized
name|void
name|objectsUnregistered
parameter_list|(
name|Collection
name|objects
parameter_list|)
block|{
if|if
condition|(
name|objects
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|Collection
argument_list|<
name|ObjectId
argument_list|>
name|ids
init|=
operator|new
name|ArrayList
argument_list|<
name|ObjectId
argument_list|>
argument_list|(
name|objects
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|Iterator
name|it
init|=
name|objects
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Persistent
name|object
init|=
operator|(
name|Persistent
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|ObjectId
name|id
init|=
name|object
operator|.
name|getObjectId
argument_list|()
decl_stmt|;
comment|// remove object but not snapshot
name|objectMap
operator|.
name|remove
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|changes
operator|.
name|remove
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|ids
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|object
operator|.
name|setObjectContext
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|object
operator|.
name|setObjectId
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|object
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|TRANSIENT
argument_list|)
expr_stmt|;
block|}
comment|// TODO, andrus 3/28/2006 - DRC is null in nested contexts... implement
comment|// propagation of unregister operation through the stack ... or do the opposite
comment|// and keep unregister local even for non-nested DC?
if|if
condition|(
name|getDataRowCache
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// send an event for removed snapshots
name|getDataRowCache
argument_list|()
operator|.
name|processSnapshotChanges
argument_list|(
name|this
argument_list|,
name|Collections
operator|.
name|EMPTY_MAP
argument_list|,
name|Collections
operator|.
name|EMPTY_LIST
argument_list|,
name|ids
argument_list|,
name|Collections
operator|.
name|EMPTY_LIST
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Reverts changes to all stored uncomitted objects.      *       * @since 1.1      */
specifier|public
specifier|synchronized
name|void
name|objectsRolledBack
parameter_list|()
block|{
name|Iterator
name|it
init|=
name|getObjectIterator
argument_list|()
decl_stmt|;
comment|// collect candidates
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Persistent
name|object
init|=
operator|(
name|Persistent
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|int
name|objectState
init|=
name|object
operator|.
name|getPersistenceState
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|objectState
condition|)
block|{
case|case
name|PersistenceState
operator|.
name|NEW
case|:
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|object
operator|.
name|setObjectContext
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|object
operator|.
name|setObjectId
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|object
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|TRANSIENT
argument_list|)
expr_stmt|;
break|break;
case|case
name|PersistenceState
operator|.
name|DELETED
case|:
comment|// Do the same as for modified... deleted is only a persistence state,
comment|// so
comment|// rolling the object back will set the state to committed
case|case
name|PersistenceState
operator|.
name|MODIFIED
case|:
comment|// this will clean any modifications and defer refresh from snapshot
comment|// till the next object accessor is called
name|object
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|HOLLOW
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// Transient, committed and hollow need no handling
break|break;
block|}
block|}
comment|// reset changes ... using new HashMap to allow event listeners to analyze the
comment|// original changes map after the rollback
name|this
operator|.
name|changes
operator|=
operator|new
name|HashMap
argument_list|<
name|Object
argument_list|,
name|ObjectDiff
argument_list|>
argument_list|()
expr_stmt|;
block|}
comment|/**      * Updates snapshots in the underlying DataRowStore. If<code>refresh</code> is      * true, all snapshots in<code>snapshots</code> will be loaded into DataRowStore,      * regardless of the existing cache state. If<code>refresh</code> is false, only      * missing snapshots are loaded. This method is normally called internally by the      * DataContext owning the ObjectStore to update the caches after a select query.      *       * @param objects a list of object whose snapshots need to be updated.      * @param snapshots a list of snapshots. Must be of the same length and use the same      *            order as<code>objects</code> list.      * @param refresh controls whether existing cached snapshots should be replaced with      *            the new ones.      * @since 1.1      */
comment|// TODO:, andrus 5/25/2006 - mark as deprecated after 1.2 - this method is no longer
comment|// used.
specifier|public
name|void
name|snapshotsUpdatedForObjects
parameter_list|(
name|List
name|objects
parameter_list|,
name|List
name|snapshots
parameter_list|,
name|boolean
name|refresh
parameter_list|)
block|{
name|DataRowStore
name|cache
init|=
name|getDataRowCache
argument_list|()
decl_stmt|;
if|if
condition|(
name|cache
operator|!=
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|cache
operator|.
name|snapshotsUpdatedForObjects
argument_list|(
name|objects
argument_list|,
name|snapshots
argument_list|,
name|refresh
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Builds and returns GraphDiff reflecting all uncommitted object changes.      *       * @since 1.2      */
name|ObjectStoreGraphDiff
name|getChanges
parameter_list|()
block|{
return|return
operator|new
name|ObjectStoreGraphDiff
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**      * Returns internal changes map.      *       * @since 1.2      */
name|Map
argument_list|<
name|Object
argument_list|,
name|ObjectDiff
argument_list|>
name|getChangesByObjectId
parameter_list|()
block|{
return|return
name|changes
return|;
block|}
comment|/**      * @since 1.2      */
name|void
name|postprocessAfterPhantomCommit
parameter_list|()
block|{
for|for
control|(
name|Object
name|id
range|:
name|changes
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Persistent
name|object
init|=
name|objectMap
operator|.
name|get
argument_list|(
name|id
argument_list|)
decl_stmt|;
comment|// assume that no new or deleted objects are present (as otherwise commit
comment|// wouldn't have been phantom).
name|object
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|COMMITTED
argument_list|)
expr_stmt|;
block|}
comment|// clear caches
name|this
operator|.
name|changes
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**      * Internal unsynchronized method to process objects state after commit.      *       * @since 1.2      */
name|void
name|postprocessAfterCommit
parameter_list|(
name|GraphDiff
name|parentChanges
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|Persistent
argument_list|>
argument_list|>
name|entries
init|=
name|objectMap
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
comment|// have to scan through all entries
while|while
condition|(
name|entries
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|Persistent
argument_list|>
name|entry
init|=
name|entries
operator|.
name|next
argument_list|()
decl_stmt|;
name|Persistent
name|object
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|object
operator|.
name|getPersistenceState
argument_list|()
condition|)
block|{
case|case
name|PersistenceState
operator|.
name|DELETED
case|:
name|entries
operator|.
name|remove
argument_list|()
expr_stmt|;
name|object
operator|.
name|setObjectContext
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|object
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|TRANSIENT
argument_list|)
expr_stmt|;
break|break;
case|case
name|PersistenceState
operator|.
name|NEW
case|:
case|case
name|PersistenceState
operator|.
name|MODIFIED
case|:
name|object
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|COMMITTED
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|// re-register changed object ids
if|if
condition|(
operator|!
name|parentChanges
operator|.
name|isNoop
argument_list|()
condition|)
block|{
name|parentChanges
operator|.
name|apply
argument_list|(
operator|new
name|GraphChangeHandler
argument_list|()
block|{
specifier|public
name|void
name|arcCreated
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|Object
name|targetNodeId
parameter_list|,
name|Object
name|arcId
parameter_list|)
block|{
block|}
specifier|public
name|void
name|arcDeleted
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|Object
name|targetNodeId
parameter_list|,
name|Object
name|arcId
parameter_list|)
block|{
block|}
specifier|public
name|void
name|nodeCreated
parameter_list|(
name|Object
name|nodeId
parameter_list|)
block|{
block|}
specifier|public
name|void
name|nodeIdChanged
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|Object
name|newId
parameter_list|)
block|{
name|processIdChange
argument_list|(
name|nodeId
argument_list|,
name|newId
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|nodePropertyChanged
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|String
name|property
parameter_list|,
name|Object
name|oldValue
parameter_list|,
name|Object
name|newValue
parameter_list|)
block|{
block|}
specifier|public
name|void
name|nodeRemoved
parameter_list|(
name|Object
name|nodeId
parameter_list|)
block|{
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|// create new instance of changes map so that event listeners who stored the
comment|// original diff don't get affected
name|this
operator|.
name|changes
operator|=
operator|new
name|HashMap
argument_list|<
name|Object
argument_list|,
name|ObjectDiff
argument_list|>
argument_list|()
expr_stmt|;
block|}
comment|/**      * Starts tracking the registration of new objects from this ObjectStore. Used in      * conjunction with unregisterNewObjects() to control garbage collection when an      * instance of ObjectStore is used over a longer time for batch processing.      *       * @deprecated since 3.0 as ObjectStore holds weak reference to unmodified objects and      *             this feature is useless.      */
specifier|public
specifier|synchronized
name|void
name|startTrackingNewObjects
parameter_list|()
block|{
comment|// noop
block|}
comment|/**      * Unregisters the newly registered DataObjects from this objectStore. Used in      * conjunction with startTrackingNewObjects() to control garbage collection when an      * instance of ObjectStore is used over a longer time for batch processing.      *       * @deprecated since 3.0 as ObjectStore holds weak reference to unmodified objects and      *             this feature is useless.      */
specifier|public
specifier|synchronized
name|void
name|unregisterNewObjects
parameter_list|()
block|{
comment|// noop
block|}
comment|/**      * Returns a snapshot for ObjectId from the underlying snapshot cache. If cache      * contains no snapshot, a null is returned.      *       * @since 1.1      */
specifier|public
name|DataRow
name|getCachedSnapshot
parameter_list|(
name|ObjectId
name|oid
parameter_list|)
block|{
if|if
condition|(
name|context
operator|!=
literal|null
operator|&&
name|context
operator|.
name|getChannel
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|ObjectIdQuery
name|query
init|=
operator|new
name|CachedSnapshotQuery
argument_list|(
name|oid
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|?
argument_list|>
name|results
init|=
name|context
operator|.
name|getChannel
argument_list|()
operator|.
name|onQuery
argument_list|(
name|context
argument_list|,
name|query
argument_list|)
operator|.
name|firstList
argument_list|()
decl_stmt|;
return|return
name|results
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
operator|(
name|DataRow
operator|)
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Returns cached query results for a given query, or null if no results are cached.      * Note that ObjectStore will only lookup results in its local cache, and not the      * shared cache associated with the underlying DataRowStore.      *       * @since 1.1      * @deprecated since 3.0. See {@link DataContext#getQueryCache()}.      */
specifier|public
specifier|synchronized
name|List
name|getCachedQueryResult
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|context
operator|!=
literal|null
operator|&&
name|context
operator|.
name|getQueryCache
argument_list|()
operator|!=
literal|null
condition|?
name|context
operator|.
name|getQueryCache
argument_list|()
operator|.
name|get
argument_list|(
operator|new
name|CacheQueryMetadata
argument_list|(
name|name
argument_list|)
argument_list|)
else|:
literal|null
return|;
block|}
comment|/**      * Caches a list of query results.      *       * @since 1.1      * @deprecated since 3.0. See {@link DataContext#getQueryCache()}.      */
specifier|public
specifier|synchronized
name|void
name|cacheQueryResult
parameter_list|(
name|String
name|name
parameter_list|,
name|List
name|results
parameter_list|)
block|{
if|if
condition|(
name|context
operator|!=
literal|null
condition|)
block|{
name|context
operator|.
name|getQueryCache
argument_list|()
operator|.
name|put
argument_list|(
operator|new
name|CacheQueryMetadata
argument_list|(
name|name
argument_list|)
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns a snapshot for ObjectId from the underlying snapshot cache. If cache      * contains no snapshot, it will attempt fetching it using provided QueryEngine. If      * fetch attempt fails or inconsistent data is returned, underlying cache will throw a      * CayenneRuntimeException.      *       * @since 1.2      */
specifier|public
specifier|synchronized
name|DataRow
name|getSnapshot
parameter_list|(
name|ObjectId
name|oid
parameter_list|)
block|{
if|if
condition|(
name|context
operator|!=
literal|null
operator|&&
name|context
operator|.
name|getChannel
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|ObjectIdQuery
name|query
init|=
operator|new
name|ObjectIdQuery
argument_list|(
name|oid
argument_list|,
literal|true
argument_list|,
name|ObjectIdQuery
operator|.
name|CACHE
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|?
argument_list|>
name|results
init|=
name|context
operator|.
name|getChannel
argument_list|()
operator|.
name|onQuery
argument_list|(
name|context
argument_list|,
name|query
argument_list|)
operator|.
name|firstList
argument_list|()
decl_stmt|;
return|return
name|results
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
operator|(
name|DataRow
operator|)
name|results
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Returns an iterator over the registered objects.      */
specifier|public
specifier|synchronized
name|Iterator
name|getObjectIterator
parameter_list|()
block|{
return|return
name|objectMap
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|/**      * Returns<code>true</code> if there are any modified, deleted or new objects      * registered with this ObjectStore,<code>false</code> otherwise. This method will      * treat "phantom" modifications are real ones. I.e. if you "change" an object      * property to an equivalent value, this method will still think such object is      * modified. Phantom modifications are only detected and discarded during commit.      */
specifier|public
specifier|synchronized
name|boolean
name|hasChanges
parameter_list|()
block|{
return|return
operator|!
name|changes
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**      * Return a subset of registered objects that are in a certain persistence state.      * Collection is returned by copy.      */
specifier|public
specifier|synchronized
name|List
argument_list|<
name|Persistent
argument_list|>
name|objectsInState
parameter_list|(
name|int
name|state
parameter_list|)
block|{
name|List
argument_list|<
name|Persistent
argument_list|>
name|filteredObjects
init|=
operator|new
name|ArrayList
argument_list|<
name|Persistent
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Persistent
name|object
range|:
name|objectMap
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|object
operator|.
name|getPersistenceState
argument_list|()
operator|==
name|state
condition|)
block|{
name|filteredObjects
operator|.
name|add
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|filteredObjects
return|;
block|}
comment|/**      * SnapshotEventListener implementation that processes snapshot change event, updating      * DataObjects that have the changes.      *<p>      *<i>Implementation note:</i> This method should not attempt to alter the underlying      * DataRowStore, since it is normally invoked *AFTER* the DataRowStore was modified as      * a result of some external interaction.      *</p>      *       * @since 1.1      */
specifier|public
name|void
name|snapshotsChanged
parameter_list|(
name|SnapshotEvent
name|event
parameter_list|)
block|{
comment|// filter events that we should not process
if|if
condition|(
name|event
operator|.
name|getPostedBy
argument_list|()
operator|!=
name|this
operator|&&
name|event
operator|.
name|getSource
argument_list|()
operator|==
name|this
operator|.
name|getDataRowCache
argument_list|()
condition|)
block|{
name|processSnapshotEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @since 1.2      */
specifier|synchronized
name|void
name|processSnapshotEvent
parameter_list|(
name|SnapshotEvent
name|event
parameter_list|)
block|{
name|Map
name|modifiedDiffs
init|=
name|event
operator|.
name|getModifiedDiffs
argument_list|()
decl_stmt|;
if|if
condition|(
name|modifiedDiffs
operator|!=
literal|null
operator|&&
operator|!
name|modifiedDiffs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Iterator
name|oids
init|=
name|modifiedDiffs
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|oids
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
name|entry
init|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|oids
operator|.
name|next
argument_list|()
decl_stmt|;
name|processUpdatedSnapshot
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
operator|(
name|DataRow
operator|)
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|Collection
name|deletedIDs
init|=
name|event
operator|.
name|getDeletedIds
argument_list|()
decl_stmt|;
if|if
condition|(
name|deletedIDs
operator|!=
literal|null
operator|&&
operator|!
name|deletedIDs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Iterator
name|it
init|=
name|deletedIDs
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|processDeletedID
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|processInvalidatedIDs
argument_list|(
name|event
operator|.
name|getInvalidatedIds
argument_list|()
argument_list|)
expr_stmt|;
name|processIndirectlyModifiedIDs
argument_list|(
name|event
operator|.
name|getIndirectlyModifiedIds
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO: andrus, 3/28/2006 - 'SnapshotEventDecorator' serves as a bridge (or
comment|// rather a noop wrapper) between old snapshot events and new GraphEvents. Once
comment|// SnapshotEvents are replaced with GraphEvents (in 2.0) we won't need it
name|GraphDiff
name|diff
init|=
operator|new
name|SnapshotEventDecorator
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|ObjectContext
name|originatingContext
init|=
operator|(
name|event
operator|.
name|getPostedBy
argument_list|()
operator|instanceof
name|ObjectContext
operator|)
condition|?
operator|(
name|ObjectContext
operator|)
name|event
operator|.
name|getPostedBy
argument_list|()
else|:
literal|null
decl_stmt|;
name|context
operator|.
name|fireDataChannelChanged
argument_list|(
name|originatingContext
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
comment|/**      * Initializes object with data from cache or from the database, if this object is not      * fully resolved.      *       * @since 1.1      * @deprecated since 3.0 use      *             {@link ObjectContext#prepareForAccess(Persistent, String, boolean)}.      */
specifier|public
name|void
name|resolveHollow
parameter_list|(
name|Persistent
name|object
parameter_list|)
block|{
name|context
operator|.
name|prepareForAccess
argument_list|(
name|object
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|void
name|processIdChange
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|Object
name|newId
parameter_list|)
block|{
name|Persistent
name|object
init|=
name|objectMap
operator|.
name|remove
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|object
operator|!=
literal|null
condition|)
block|{
name|object
operator|.
name|setObjectId
argument_list|(
operator|(
name|ObjectId
operator|)
name|newId
argument_list|)
expr_stmt|;
name|objectMap
operator|.
name|put
argument_list|(
name|newId
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|ObjectDiff
name|change
init|=
name|changes
operator|.
name|remove
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|change
operator|!=
literal|null
condition|)
block|{
name|changes
operator|.
name|put
argument_list|(
name|newId
argument_list|,
name|change
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Requires external synchronization.      *       * @since 1.2      */
name|void
name|processDeletedID
parameter_list|(
name|Object
name|nodeId
parameter_list|)
block|{
comment|// access object map directly - the method should be called in a synchronized
comment|// context...
name|Persistent
name|object
init|=
name|objectMap
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|object
operator|!=
literal|null
condition|)
block|{
name|DataObject
name|dataObject
init|=
operator|(
name|object
operator|instanceof
name|DataObject
operator|)
condition|?
operator|(
name|DataObject
operator|)
name|object
else|:
literal|null
decl_stmt|;
name|DataContextDelegate
name|delegate
decl_stmt|;
switch|switch
condition|(
name|object
operator|.
name|getPersistenceState
argument_list|()
condition|)
block|{
case|case
name|PersistenceState
operator|.
name|COMMITTED
case|:
case|case
name|PersistenceState
operator|.
name|HOLLOW
case|:
case|case
name|PersistenceState
operator|.
name|DELETED
case|:
comment|// consult delegate
name|delegate
operator|=
name|context
operator|.
name|nonNullDelegate
argument_list|()
expr_stmt|;
if|if
condition|(
name|dataObject
operator|==
literal|null
operator|||
name|delegate
operator|.
name|shouldProcessDelete
argument_list|(
name|dataObject
argument_list|)
condition|)
block|{
name|objectMap
operator|.
name|remove
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
name|changes
operator|.
name|remove
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
comment|// setting DataContext to null will also set
comment|// state to transient
name|object
operator|.
name|setObjectContext
argument_list|(
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|dataObject
operator|!=
literal|null
condition|)
block|{
name|delegate
operator|.
name|finishedProcessDelete
argument_list|(
name|dataObject
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PersistenceState
operator|.
name|MODIFIED
case|:
comment|// consult delegate
name|delegate
operator|=
name|context
operator|.
name|nonNullDelegate
argument_list|()
expr_stmt|;
if|if
condition|(
name|dataObject
operator|!=
literal|null
operator|&&
name|delegate
operator|.
name|shouldProcessDelete
argument_list|(
name|dataObject
argument_list|)
condition|)
block|{
name|object
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|NEW
argument_list|)
expr_stmt|;
name|changes
operator|.
name|remove
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
name|registerNode
argument_list|(
name|nodeId
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|nodeCreated
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
name|delegate
operator|.
name|finishedProcessDelete
argument_list|(
name|dataObject
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
comment|/**      * @since 1.1      */
name|void
name|processInvalidatedIDs
parameter_list|(
name|Collection
name|invalidatedIDs
parameter_list|)
block|{
if|if
condition|(
name|invalidatedIDs
operator|!=
literal|null
operator|&&
operator|!
name|invalidatedIDs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Iterator
name|it
init|=
name|invalidatedIDs
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|ObjectId
name|oid
init|=
operator|(
name|ObjectId
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|DataObject
name|object
init|=
operator|(
name|DataObject
operator|)
name|getNode
argument_list|(
name|oid
argument_list|)
decl_stmt|;
if|if
condition|(
name|object
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
comment|// TODO: refactor "switch" to avoid code duplication
switch|switch
condition|(
name|object
operator|.
name|getPersistenceState
argument_list|()
condition|)
block|{
case|case
name|PersistenceState
operator|.
name|COMMITTED
case|:
name|object
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|HOLLOW
argument_list|)
expr_stmt|;
break|break;
case|case
name|PersistenceState
operator|.
name|MODIFIED
case|:
name|DataContext
name|context
init|=
operator|(
name|DataContext
operator|)
name|object
operator|.
name|getObjectContext
argument_list|()
decl_stmt|;
name|DataRow
name|diff
init|=
name|getSnapshot
argument_list|(
name|oid
argument_list|)
decl_stmt|;
comment|// consult delegate if it exists
name|DataContextDelegate
name|delegate
init|=
name|context
operator|.
name|nonNullDelegate
argument_list|()
decl_stmt|;
if|if
condition|(
name|delegate
operator|.
name|shouldMergeChanges
argument_list|(
name|object
argument_list|,
name|diff
argument_list|)
condition|)
block|{
name|ClassDescriptor
name|descriptor
init|=
name|context
operator|.
name|getEntityResolver
argument_list|()
operator|.
name|getClassDescriptor
argument_list|(
name|oid
operator|.
name|getEntityName
argument_list|()
argument_list|)
decl_stmt|;
name|DataRowUtils
operator|.
name|forceMergeWithSnapshot
argument_list|(
name|context
argument_list|,
name|descriptor
argument_list|,
name|object
argument_list|,
name|diff
argument_list|)
expr_stmt|;
name|delegate
operator|.
name|finishedMergeChanges
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
case|case
name|PersistenceState
operator|.
name|HOLLOW
case|:
comment|// do nothing
break|break;
case|case
name|PersistenceState
operator|.
name|DELETED
case|:
comment|// TODO: Do nothing? Or treat as merged?
break|break;
block|}
block|}
block|}
block|}
comment|/**      * Requires external synchronization.      *       * @since 1.1      */
name|void
name|processIndirectlyModifiedIDs
parameter_list|(
name|Collection
name|indirectlyModifiedIDs
parameter_list|)
block|{
name|Iterator
name|indirectlyModifiedIt
init|=
name|indirectlyModifiedIDs
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|indirectlyModifiedIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|ObjectId
name|oid
init|=
operator|(
name|ObjectId
operator|)
name|indirectlyModifiedIt
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// access object map directly - the method should be called in a synchronized
comment|// context...
specifier|final
name|DataObject
name|object
init|=
operator|(
name|DataObject
operator|)
name|objectMap
operator|.
name|get
argument_list|(
name|oid
argument_list|)
decl_stmt|;
if|if
condition|(
name|object
operator|==
literal|null
operator|||
name|object
operator|.
name|getPersistenceState
argument_list|()
operator|!=
name|PersistenceState
operator|.
name|COMMITTED
condition|)
block|{
continue|continue;
block|}
comment|// for now break all "independent" object relationships...
comment|// in the future we may want to be more precise and go after modified
comment|// relationships only, or even process updated lists without invalidating...
name|DataContextDelegate
name|delegate
init|=
name|context
operator|.
name|nonNullDelegate
argument_list|()
decl_stmt|;
if|if
condition|(
name|delegate
operator|.
name|shouldMergeChanges
argument_list|(
name|object
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|ClassDescriptor
name|descriptor
init|=
name|context
operator|.
name|getEntityResolver
argument_list|()
operator|.
name|getClassDescriptor
argument_list|(
name|oid
operator|.
name|getEntityName
argument_list|()
argument_list|)
decl_stmt|;
name|descriptor
operator|.
name|visitProperties
argument_list|(
operator|new
name|PropertyVisitor
argument_list|()
block|{
specifier|public
name|boolean
name|visitToMany
parameter_list|(
name|ToManyProperty
name|property
parameter_list|)
block|{
name|property
operator|.
name|invalidate
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|visitToOne
parameter_list|(
name|ToOneProperty
name|property
parameter_list|)
block|{
if|if
condition|(
name|property
operator|.
name|getRelationship
argument_list|()
operator|.
name|isSourceIndependentFromTargetChange
argument_list|()
condition|)
block|{
name|property
operator|.
name|invalidate
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|visitAttribute
parameter_list|(
name|AttributeProperty
name|property
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|delegate
operator|.
name|finishedProcessDelete
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Requires external synchronization.      *       * @since 1.1      */
name|void
name|processUpdatedSnapshot
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|DataRow
name|diff
parameter_list|)
block|{
comment|// access object map directly - the method should be called in a synchronized
comment|// context...
name|DataObject
name|object
init|=
operator|(
name|DataObject
operator|)
name|objectMap
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
comment|// no object, or HOLLOW object require no processing
if|if
condition|(
name|object
operator|!=
literal|null
condition|)
block|{
name|int
name|state
init|=
name|object
operator|.
name|getPersistenceState
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|!=
name|PersistenceState
operator|.
name|HOLLOW
condition|)
block|{
comment|// perform same steps as resolveHollow()
if|if
condition|(
name|state
operator|==
name|PersistenceState
operator|.
name|COMMITTED
condition|)
block|{
comment|// consult delegate if it exists
name|DataContextDelegate
name|delegate
init|=
name|context
operator|.
name|nonNullDelegate
argument_list|()
decl_stmt|;
if|if
condition|(
name|delegate
operator|.
name|shouldMergeChanges
argument_list|(
name|object
argument_list|,
name|diff
argument_list|)
condition|)
block|{
name|ClassDescriptor
name|descriptor
init|=
name|context
operator|.
name|getEntityResolver
argument_list|()
operator|.
name|getClassDescriptor
argument_list|(
operator|(
operator|(
name|ObjectId
operator|)
name|nodeId
operator|)
operator|.
name|getEntityName
argument_list|()
argument_list|)
decl_stmt|;
comment|// TODO: andrus, 5/26/2006 - call to 'getSnapshot' is expensive,
comment|// however my attempts to merge the 'diff' instead of snapshot
comment|// via 'refreshObjectWithSnapshot' resulted in even worse
comment|// performance.
comment|// This sounds counterintuitive (Not sure if this is some HotSpot
comment|// related glitch)... still keeping the old algorithm here until
comment|// we
comment|// switch from snapshot events to GraphEvents and all this code
comment|// becomes obsolete.
name|DataRow
name|snapshot
init|=
name|getSnapshot
argument_list|(
name|object
operator|.
name|getObjectId
argument_list|()
argument_list|)
decl_stmt|;
name|DataRowUtils
operator|.
name|refreshObjectWithSnapshot
argument_list|(
name|descriptor
argument_list|,
name|object
argument_list|,
name|snapshot
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|delegate
operator|.
name|finishedMergeChanges
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
block|}
comment|// merge modified and deleted
if|else if
condition|(
name|state
operator|==
name|PersistenceState
operator|.
name|DELETED
operator|||
name|state
operator|==
name|PersistenceState
operator|.
name|MODIFIED
condition|)
block|{
comment|// consult delegate if it exists
name|DataContextDelegate
name|delegate
init|=
name|context
operator|.
name|nonNullDelegate
argument_list|()
decl_stmt|;
if|if
condition|(
name|delegate
operator|.
name|shouldMergeChanges
argument_list|(
name|object
argument_list|,
name|diff
argument_list|)
condition|)
block|{
name|ClassDescriptor
name|descriptor
init|=
name|context
operator|.
name|getEntityResolver
argument_list|()
operator|.
name|getClassDescriptor
argument_list|(
operator|(
operator|(
name|ObjectId
operator|)
name|nodeId
operator|)
operator|.
name|getEntityName
argument_list|()
argument_list|)
decl_stmt|;
name|DataRowUtils
operator|.
name|forceMergeWithSnapshot
argument_list|(
name|context
argument_list|,
name|descriptor
argument_list|,
name|object
argument_list|,
name|diff
argument_list|)
expr_stmt|;
name|delegate
operator|.
name|finishedMergeChanges
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * @since 1.2      */
specifier|public
name|DataContext
name|getContext
parameter_list|()
block|{
return|return
name|context
return|;
block|}
comment|/**      * @since 1.2      */
specifier|public
name|void
name|setContext
parameter_list|(
name|DataContext
name|context
parameter_list|)
block|{
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
block|}
comment|// *********** GraphManager Methods ********
comment|// =========================================
comment|/**      * Returns a registered DataObject or null of no object exists for the ObjectId.      *       * @since 1.2      */
specifier|public
specifier|synchronized
name|Object
name|getNode
parameter_list|(
name|Object
name|nodeId
parameter_list|)
block|{
return|return
name|objectMap
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
return|;
block|}
comment|// non-synchronized version of getNode for private use
specifier|final
name|Object
name|getNodeNoSync
parameter_list|(
name|Object
name|nodeId
parameter_list|)
block|{
return|return
name|objectMap
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
return|;
block|}
comment|/**      * Returns all registered DataObjects. List is returned by copy and can be modified by      * the caller.      *       * @since 1.2      */
specifier|public
specifier|synchronized
name|Collection
argument_list|<
name|Object
argument_list|>
name|registeredNodes
parameter_list|()
block|{
return|return
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|(
name|objectMap
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * @since 1.2      */
specifier|public
specifier|synchronized
name|void
name|registerNode
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|Object
name|nodeObject
parameter_list|)
block|{
name|objectMap
operator|.
name|put
argument_list|(
name|nodeId
argument_list|,
operator|(
name|Persistent
operator|)
name|nodeObject
argument_list|)
expr_stmt|;
block|}
comment|/**      * @since 1.2      */
specifier|public
specifier|synchronized
name|Object
name|unregisterNode
parameter_list|(
name|Object
name|nodeId
parameter_list|)
block|{
name|Object
name|object
init|=
name|getNode
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|object
operator|!=
literal|null
condition|)
block|{
name|objectsUnregistered
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|object
return|;
block|}
comment|/**      * Does nothing.      *       * @since 1.2      */
specifier|public
name|void
name|nodeIdChanged
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|Object
name|newId
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"nodeIdChanged"
argument_list|)
throw|;
block|}
comment|/**      * @since 1.2      */
specifier|public
name|void
name|nodeCreated
parameter_list|(
name|Object
name|nodeId
parameter_list|)
block|{
name|NodeDiff
name|diff
init|=
operator|new
name|NodeCreateOperation
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|lifecycleEventInducedChanges
operator|!=
literal|null
condition|)
block|{
name|registerLifecycleEventInducedChange
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
name|registerDiff
argument_list|(
name|nodeId
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
comment|/**      * @since 1.2      */
specifier|public
name|void
name|nodeRemoved
parameter_list|(
name|Object
name|nodeId
parameter_list|)
block|{
name|NodeDiff
name|diff
init|=
operator|new
name|NodeDeleteOperation
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|lifecycleEventInducedChanges
operator|!=
literal|null
condition|)
block|{
name|registerLifecycleEventInducedChange
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
name|registerDiff
argument_list|(
name|nodeId
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
comment|/**      * Records dirty object snapshot.      *       * @since 1.2      */
specifier|public
name|void
name|nodePropertyChanged
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|String
name|property
parameter_list|,
name|Object
name|oldValue
parameter_list|,
name|Object
name|newValue
parameter_list|)
block|{
if|if
condition|(
name|lifecycleEventInducedChanges
operator|!=
literal|null
condition|)
block|{
name|registerLifecycleEventInducedChange
argument_list|(
operator|new
name|NodePropertyChangeOperation
argument_list|(
name|nodeId
argument_list|,
name|property
argument_list|,
name|oldValue
argument_list|,
name|newValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|registerDiff
argument_list|(
name|nodeId
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * @since 1.2      */
specifier|public
name|void
name|arcCreated
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|Object
name|targetNodeId
parameter_list|,
name|Object
name|arcId
parameter_list|)
block|{
name|NodeDiff
name|diff
init|=
operator|new
name|ArcOperation
argument_list|(
name|nodeId
argument_list|,
name|targetNodeId
argument_list|,
name|arcId
operator|.
name|toString
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|lifecycleEventInducedChanges
operator|!=
literal|null
condition|)
block|{
name|registerLifecycleEventInducedChange
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
name|registerDiff
argument_list|(
name|nodeId
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
comment|/**      * @since 1.2      */
specifier|public
name|void
name|arcDeleted
parameter_list|(
name|Object
name|nodeId
parameter_list|,
name|Object
name|targetNodeId
parameter_list|,
name|Object
name|arcId
parameter_list|)
block|{
name|NodeDiff
name|diff
init|=
operator|new
name|ArcOperation
argument_list|(
name|nodeId
argument_list|,
name|targetNodeId
argument_list|,
name|arcId
operator|.
name|toString
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|lifecycleEventInducedChanges
operator|!=
literal|null
condition|)
block|{
name|registerLifecycleEventInducedChange
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
name|registerDiff
argument_list|(
name|nodeId
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
comment|// an ObjectIdQuery optimized for retrieval of multiple snapshots - it can be reset
comment|// with the new id
specifier|final
class|class
name|CachedSnapshotQuery
extends|extends
name|ObjectIdQuery
block|{
name|CachedSnapshotQuery
parameter_list|(
name|ObjectId
name|oid
parameter_list|)
block|{
name|super
argument_list|(
name|oid
argument_list|,
literal|true
argument_list|,
name|ObjectIdQuery
operator|.
name|CACHE_NOREFRESH
argument_list|)
expr_stmt|;
block|}
name|void
name|resetId
parameter_list|(
name|ObjectId
name|oid
parameter_list|)
block|{
name|this
operator|.
name|objectId
operator|=
name|oid
expr_stmt|;
name|this
operator|.
name|replacementQuery
operator|=
literal|null
expr_stmt|;
block|}
block|}
class|class
name|SnapshotEventDecorator
implements|implements
name|GraphDiff
block|{
name|SnapshotEvent
name|event
decl_stmt|;
name|SnapshotEventDecorator
parameter_list|(
name|SnapshotEvent
name|event
parameter_list|)
block|{
name|this
operator|.
name|event
operator|=
name|event
expr_stmt|;
block|}
name|SnapshotEvent
name|getEvent
parameter_list|()
block|{
return|return
name|event
return|;
block|}
specifier|public
name|void
name|apply
parameter_list|(
name|GraphChangeHandler
name|handler
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|boolean
name|isNoop
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|void
name|undo
parameter_list|(
name|GraphChangeHandler
name|handler
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
specifier|final
class|class
name|CacheQueryMetadata
implements|implements
name|QueryMetadata
block|{
specifier|private
name|String
name|cacheKey
decl_stmt|;
name|CacheQueryMetadata
parameter_list|(
name|String
name|cacheKey
parameter_list|)
block|{
name|this
operator|.
name|cacheKey
operator|=
name|cacheKey
expr_stmt|;
block|}
specifier|public
name|String
name|getCacheKey
parameter_list|()
block|{
return|return
name|cacheKey
return|;
block|}
specifier|public
name|SQLResultSetMapping
name|getResultSetMapping
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|Query
name|getOrginatingQuery
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|String
index|[]
name|getCacheGroups
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|String
name|getCachePolicy
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|DataMap
name|getDataMap
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|DbEntity
name|getDbEntity
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|int
name|getFetchLimit
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|public
name|int
name|getFetchStartIndex
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|public
name|ObjEntity
name|getObjEntity
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|ClassDescriptor
name|getClassDescriptor
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|int
name|getPageSize
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|public
name|PrefetchTreeNode
name|getPrefetchTree
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|Procedure
name|getProcedure
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|boolean
name|isFetchingDataRows
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|boolean
name|isRefreshingObjects
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|boolean
name|isResolvingInherited
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
end_class

end_unit

