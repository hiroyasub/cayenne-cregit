begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************  *   Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing,  *  software distributed under the License is distributed on an  *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *  KIND, either express or implied.  See the License for the  *  specific language governing permissions and limitations  *  under the License.  ****************************************************************/
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|access
package|;
end_package

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|DatabaseMetaData
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|CayenneException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|dba
operator|.
name|DbAdapter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|dba
operator|.
name|TypesMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|DataMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|DbAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|DbEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|DbJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|DbRelationship
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|DbRelationshipDetected
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|DetectedDbEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|Entity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|ObjEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|Procedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|ProcedureParameter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|naming
operator|.
name|BasicNamingStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|naming
operator|.
name|ExportedKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|naming
operator|.
name|NamingStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|util
operator|.
name|EntityMergeSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_comment
comment|/**  * Utility class that does reverse engineering of the database. It can create  * DataMaps using database meta data obtained via JDBC driver.  */
end_comment

begin_class
specifier|public
class|class
name|DbLoader
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|logger
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|DbLoader
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// TODO: remove this hardcoded stuff once delegate starts to support
comment|// procedure
comment|// loading...
specifier|private
specifier|static
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|EXCLUDED_PROCEDURES
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"auto_pk_for_table"
argument_list|,
literal|"auto_pk_for_table;1"
comment|/*                                                                 * the last name                                                                 * is some Mac OS                                                                 * X Sybase                                                                 * artifact                                                                 */
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|WILDCARD
init|=
literal|"%"
decl_stmt|;
comment|/** List of db entities to process. */
specifier|private
name|List
argument_list|<
name|DbEntity
argument_list|>
name|dbEntityList
init|=
operator|new
name|ArrayList
argument_list|<
name|DbEntity
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * CAY-479 - need to track which entities are skipped in the loader so that      * relationships to non-skipped entities can be loaded      */
specifier|private
name|Set
argument_list|<
name|DbEntity
argument_list|>
name|skippedEntities
init|=
operator|new
name|HashSet
argument_list|<
name|DbEntity
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Creates a unique name for loaded relationship on the given entity. */
specifier|private
specifier|static
name|String
name|uniqueRelName
parameter_list|(
name|Entity
name|entity
parameter_list|,
name|String
name|preferredName
parameter_list|)
block|{
name|int
name|currentSuffix
init|=
literal|1
decl_stmt|;
name|String
name|relName
init|=
name|preferredName
decl_stmt|;
while|while
condition|(
name|entity
operator|.
name|getRelationship
argument_list|(
name|relName
argument_list|)
operator|!=
literal|null
operator|||
name|entity
operator|.
name|getAttribute
argument_list|(
name|relName
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|relName
operator|=
name|preferredName
operator|+
name|currentSuffix
expr_stmt|;
name|currentSuffix
operator|++
expr_stmt|;
block|}
return|return
name|relName
return|;
block|}
specifier|protected
name|Connection
name|connection
decl_stmt|;
specifier|protected
name|DbAdapter
name|adapter
decl_stmt|;
specifier|protected
name|DatabaseMetaData
name|metaData
decl_stmt|;
specifier|protected
name|DbLoaderDelegate
name|delegate
decl_stmt|;
specifier|protected
name|String
name|genericClassName
decl_stmt|;
specifier|protected
name|boolean
name|creatingMeaningfulPK
decl_stmt|;
comment|/**      * Strategy for choosing names for entities, attributes and relationships      */
specifier|protected
name|NamingStrategy
name|namingStrategy
decl_stmt|;
comment|/**      * Creates new DbLoader.      */
specifier|public
name|DbLoader
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|DbAdapter
name|adapter
parameter_list|,
name|DbLoaderDelegate
name|delegate
parameter_list|)
block|{
name|this
argument_list|(
name|connection
argument_list|,
name|adapter
argument_list|,
name|delegate
argument_list|,
operator|new
name|BasicNamingStrategy
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates new DbLoader with specified naming strategy.      *       * @since 3.0      */
specifier|public
name|DbLoader
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|DbAdapter
name|adapter
parameter_list|,
name|DbLoaderDelegate
name|delegate
parameter_list|,
name|NamingStrategy
name|strategy
parameter_list|)
block|{
name|this
operator|.
name|adapter
operator|=
name|adapter
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|connection
expr_stmt|;
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
name|setNamingStrategy
argument_list|(
name|strategy
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns DatabaseMetaData object associated with this DbLoader.      */
specifier|public
name|DatabaseMetaData
name|getMetaData
parameter_list|()
throws|throws
name|SQLException
block|{
if|if
condition|(
literal|null
operator|==
name|metaData
condition|)
name|metaData
operator|=
name|connection
operator|.
name|getMetaData
argument_list|()
expr_stmt|;
return|return
name|metaData
return|;
block|}
specifier|public
name|void
name|setCreatingMeaningfulPK
parameter_list|(
name|boolean
name|check
parameter_list|)
block|{
name|this
operator|.
name|creatingMeaningfulPK
operator|=
name|check
expr_stmt|;
block|}
comment|/**      * Returns true if the generator should map all primary key columns as      * ObjAttributes.      *       * @since 3.0      */
specifier|public
name|boolean
name|isCreatingMeaningfulPK
parameter_list|()
block|{
return|return
name|creatingMeaningfulPK
return|;
block|}
comment|/**      * Returns database connection used by this DbLoader.      *       * @since 3.0      */
specifier|public
name|Connection
name|getConnection
parameter_list|()
block|{
return|return
name|connection
return|;
block|}
comment|/**      * Returns a name of a generic class that should be used for all      * ObjEntities. The most common generic class is      * {@link org.apache.cayenne.CayenneDataObject}. If generic class name is      * null (which is the default), DbLoader will assign each entity a unique      * class name derived from the table name.      *       * @since 1.2      */
specifier|public
name|String
name|getGenericClassName
parameter_list|()
block|{
return|return
name|genericClassName
return|;
block|}
comment|/**      * Sets a name of a generic class that should be used for all ObjEntities.      * The most common generic class is      * {@link org.apache.cayenne.CayenneDataObject}. If generic class name is      * set to null (which is the default), DbLoader will assign each entity a      * unique class name derived from the table name.      *       * @since 1.2      */
specifier|public
name|void
name|setGenericClassName
parameter_list|(
name|String
name|genericClassName
parameter_list|)
block|{
name|this
operator|.
name|genericClassName
operator|=
name|genericClassName
expr_stmt|;
block|}
comment|/**      * Returns DbAdapter associated with this DbLoader.      *       * @since 1.1      */
specifier|public
name|DbAdapter
name|getAdapter
parameter_list|()
block|{
return|return
name|adapter
return|;
block|}
comment|/**      * A method that return true if the given table name should be included. The      * default implementation include all tables.      */
specifier|public
name|boolean
name|includeTableName
parameter_list|(
name|String
name|tableName
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
comment|/**      * Retrieves catalogues for the database associated with this DbLoader.      *       * @return List with the catalog names, empty Array if none found.      */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getCatalogs
parameter_list|()
throws|throws
name|SQLException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|catalogs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ResultSet
name|rs
init|=
name|getMetaData
argument_list|()
operator|.
name|getCatalogs
argument_list|()
decl_stmt|;
try|try
block|{
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|String
name|catalog_name
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|catalogs
operator|.
name|add
argument_list|(
name|catalog_name
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|rs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|catalogs
return|;
block|}
comment|/**      * Retrieves the schemas for the database.      *       * @return List with the schema names, empty Array if none found.      */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getSchemas
parameter_list|()
throws|throws
name|SQLException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|schemas
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ResultSet
name|rs
init|=
name|getMetaData
argument_list|()
operator|.
name|getSchemas
argument_list|()
decl_stmt|;
try|try
block|{
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|String
name|schema_name
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|schemas
operator|.
name|add
argument_list|(
name|schema_name
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|rs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|schemas
return|;
block|}
comment|/**      * Returns all the table types for the given database. Types may be such as      * "TABLE", "VIEW", "SYSTEM TABLE", etc.      *       * @return List of Strings, empty array if nothing found.      */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getTableTypes
parameter_list|()
throws|throws
name|SQLException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|types
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ResultSet
name|rs
init|=
name|getMetaData
argument_list|()
operator|.
name|getTableTypes
argument_list|()
decl_stmt|;
try|try
block|{
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|types
operator|.
name|add
argument_list|(
name|rs
operator|.
name|getString
argument_list|(
literal|"TABLE_TYPE"
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|rs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|types
return|;
block|}
comment|/**      * Returns all tables for given combination of the criteria. Tables returned      * as DbEntities without any attributes or relationships.      *       * @param catalogPattern      *            The name of the catalog, may be null.      * @param schemaPattern      *            The pattern for schema name, use "%" for wildcard.      * @param tableNamePattern      *            The pattern for table names, % for wildcard, if null or ""      *            defaults to "%".      * @param types      *            The types of table names to retrieve, null returns all types.      * @return List of TableInfo objects, empty array if nothing found.      */
specifier|public
name|List
argument_list|<
name|DbEntity
argument_list|>
name|getTables
parameter_list|(
name|String
name|catalogPattern
parameter_list|,
name|String
name|schemaPattern
parameter_list|,
name|String
name|tableNamePattern
parameter_list|,
name|String
index|[]
name|types
parameter_list|)
throws|throws
name|SQLException
block|{
name|List
argument_list|<
name|DbEntity
argument_list|>
name|tables
init|=
operator|new
name|ArrayList
argument_list|<
name|DbEntity
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"Read tables: catalog="
operator|+
name|catalogPattern
operator|+
literal|", schema="
operator|+
name|schemaPattern
operator|+
literal|", tableNames="
operator|+
name|tableNamePattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|types
operator|!=
literal|null
operator|&&
name|types
operator|.
name|length
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|String
name|type
range|:
name|types
control|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"Read tables: table type="
operator|+
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ResultSet
name|rs
init|=
name|getMetaData
argument_list|()
operator|.
name|getTables
argument_list|(
name|catalogPattern
argument_list|,
name|schemaPattern
argument_list|,
name|tableNamePattern
argument_list|,
name|types
argument_list|)
decl_stmt|;
try|try
block|{
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|String
name|catalog
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"TABLE_CAT"
argument_list|)
decl_stmt|;
name|String
name|schema
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"TABLE_SCHEM"
argument_list|)
decl_stmt|;
name|String
name|name
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"TABLE_NAME"
argument_list|)
decl_stmt|;
comment|// Oracle 9i and newer has a nifty recycle bin feature... but we
comment|// don't
comment|// want dropped tables to be included here; in fact they may
comment|// even result
comment|// in errors on reverse engineering as their names have special
comment|// chars like
comment|// "/", etc. So skip them all together
comment|// TODO: Andrus, 10/29/2005 - this type of filtering should be
comment|// delegated
comment|// to adapter
if|if
condition|(
name|name
operator|==
literal|null
operator|||
name|name
operator|.
name|startsWith
argument_list|(
literal|"BIN$"
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|includeTableName
argument_list|(
name|name
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|DbEntity
name|table
init|=
operator|new
name|DetectedDbEntity
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|table
operator|.
name|setCatalog
argument_list|(
name|catalog
argument_list|)
expr_stmt|;
name|table
operator|.
name|setSchema
argument_list|(
name|schema
argument_list|)
expr_stmt|;
name|tables
operator|.
name|add
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|rs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|tables
return|;
block|}
comment|/**      * Loads dbEntities for the specified tables.      *       * @param map      *            DataMap to be populated with DbEntities.      * @param tables      *            The list of org.apache.cayenne.ashwood.dbutil.Table objects      *            for which DbEntities must be created.      * @return false if loading must be immediately aborted.      */
specifier|public
name|boolean
name|loadDbEntities
parameter_list|(
name|DataMap
name|map
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|DbEntity
argument_list|>
name|tables
parameter_list|)
throws|throws
name|SQLException
block|{
name|this
operator|.
name|dbEntityList
operator|=
operator|new
name|ArrayList
argument_list|<
name|DbEntity
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|DbEntity
name|dbEntity
range|:
name|tables
control|)
block|{
comment|// Check if there already is a DbEntity under such name
comment|// if so, consult the delegate what to do
name|DbEntity
name|oldEnt
init|=
name|map
operator|.
name|getDbEntity
argument_list|(
name|dbEntity
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldEnt
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|delegate
operator|==
literal|null
condition|)
block|{
comment|// no delegate, don't know what to do, cancel import
break|break;
block|}
try|try
block|{
if|if
condition|(
name|delegate
operator|.
name|overwriteDbEntity
argument_list|(
name|oldEnt
argument_list|)
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"Overwrite: "
operator|+
name|oldEnt
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|map
operator|.
name|removeDbEntity
argument_list|(
name|oldEnt
operator|.
name|getName
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|delegate
operator|.
name|dbEntityRemoved
argument_list|(
name|oldEnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"Keep old: "
operator|+
name|oldEnt
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// cay-479 - need to track entities that were not loaded
comment|// for
comment|// relationships exported to entities that were
name|skippedEntities
operator|.
name|add
argument_list|(
name|oldEnt
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
catch|catch
parameter_list|(
name|CayenneException
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"Load canceled."
argument_list|)
expr_stmt|;
comment|// cancel immediately
return|return
literal|false
return|;
block|}
block|}
comment|// Create DbAttributes from column information --
name|ResultSet
name|rs
init|=
name|getMetaData
argument_list|()
operator|.
name|getColumns
argument_list|(
name|dbEntity
operator|.
name|getCatalog
argument_list|()
argument_list|,
name|dbEntity
operator|.
name|getSchema
argument_list|()
argument_list|,
name|dbEntity
operator|.
name|getName
argument_list|()
argument_list|,
literal|"%"
argument_list|)
decl_stmt|;
try|try
block|{
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
comment|// for a reason not quiet apparent to me, Oracle sometimes
comment|// returns duplicate record sets for the same table, messing
comment|// up table
comment|// names. E.g. for the system table "WK$_ATTR_MAPPING"
comment|// columns are
comment|// returned twice - as "WK$_ATTR_MAPPING" and
comment|// "WK$$_ATTR_MAPPING"...
comment|// Go figure
name|String
name|tableName
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"TABLE_NAME"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dbEntity
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"Incorrectly returned columns for '"
operator|+
name|tableName
operator|+
literal|", skipping."
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// gets attribute's (column's) information
name|String
name|columnName
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"COLUMN_NAME"
argument_list|)
decl_stmt|;
name|boolean
name|allowNulls
init|=
name|rs
operator|.
name|getBoolean
argument_list|(
literal|"NULLABLE"
argument_list|)
decl_stmt|;
name|int
name|columnType
init|=
name|rs
operator|.
name|getInt
argument_list|(
literal|"DATA_TYPE"
argument_list|)
decl_stmt|;
name|int
name|columnSize
init|=
name|rs
operator|.
name|getInt
argument_list|(
literal|"COLUMN_SIZE"
argument_list|)
decl_stmt|;
name|String
name|typeName
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"TYPE_NAME"
argument_list|)
decl_stmt|;
comment|// ignore precision of non-decimal columns
name|int
name|decimalDigits
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|TypesMapping
operator|.
name|isDecimal
argument_list|(
name|columnType
argument_list|)
condition|)
block|{
name|decimalDigits
operator|=
name|rs
operator|.
name|getInt
argument_list|(
literal|"DECIMAL_DIGITS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|.
name|wasNull
argument_list|()
condition|)
block|{
name|decimalDigits
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|// create attribute delegating this task to adapter
name|DbAttribute
name|attr
init|=
name|adapter
operator|.
name|buildAttribute
argument_list|(
name|columnName
argument_list|,
name|typeName
argument_list|,
name|columnType
argument_list|,
name|columnSize
argument_list|,
name|decimalDigits
argument_list|,
name|allowNulls
argument_list|)
decl_stmt|;
if|if
condition|(
name|adapter
operator|.
name|supportsGeneratedKeys
argument_list|()
condition|)
block|{
comment|// TODO: this actually throws on some drivers... need to
comment|// ensure that 'supportsGeneratedKeys' check is enough
comment|// to prevent an exception here.
name|String
name|autoIncrement
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"IS_AUTOINCREMENT"
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"YES"
operator|.
name|equals
argument_list|(
name|autoIncrement
argument_list|)
condition|)
block|{
name|attr
operator|.
name|setGenerated
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
name|attr
operator|.
name|setEntity
argument_list|(
name|dbEntity
argument_list|)
expr_stmt|;
name|dbEntity
operator|.
name|addAttribute
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|rs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|map
operator|.
name|addDbEntity
argument_list|(
name|dbEntity
argument_list|)
expr_stmt|;
comment|// notify delegate
if|if
condition|(
name|delegate
operator|!=
literal|null
condition|)
block|{
name|delegate
operator|.
name|dbEntityAdded
argument_list|(
name|dbEntity
argument_list|)
expr_stmt|;
block|}
comment|// delegate might have thrown this entity out... so check if it is
comment|// still
comment|// around before continuing processing
if|if
condition|(
name|map
operator|.
name|getDbEntity
argument_list|(
name|dbEntity
operator|.
name|getName
argument_list|()
argument_list|)
operator|==
name|dbEntity
condition|)
block|{
name|this
operator|.
name|dbEntityList
operator|.
name|add
argument_list|(
name|dbEntity
argument_list|)
expr_stmt|;
block|}
block|}
comment|// get primary keys for each table and store it in dbEntity
for|for
control|(
specifier|final
name|DbEntity
name|dbEntity
range|:
name|map
operator|.
name|getDbEntities
argument_list|()
control|)
block|{
if|if
condition|(
name|tables
operator|.
name|contains
argument_list|(
name|dbEntity
argument_list|)
condition|)
block|{
name|String
name|tableName
init|=
name|dbEntity
operator|.
name|getName
argument_list|()
decl_stmt|;
name|ResultSet
name|rs
init|=
name|metaData
operator|.
name|getPrimaryKeys
argument_list|(
literal|null
argument_list|,
name|dbEntity
operator|.
name|getSchema
argument_list|()
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
try|try
block|{
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|String
name|columnName
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|DbAttribute
name|attribute
init|=
operator|(
name|DbAttribute
operator|)
name|dbEntity
operator|.
name|getAttribute
argument_list|(
name|columnName
argument_list|)
decl_stmt|;
if|if
condition|(
name|attribute
operator|!=
literal|null
condition|)
block|{
name|attribute
operator|.
name|setPrimaryKey
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// why an attribute might be null is not quiet clear
comment|// but there is a bug report 731406 indicating that
comment|// it is
comment|// possible
comment|// so just print the warning, and ignore
name|logger
operator|.
name|warn
argument_list|(
literal|"Can't locate attribute for primary key: "
operator|+
name|columnName
argument_list|)
expr_stmt|;
block|}
name|String
name|pkName
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|pkName
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|dbEntity
operator|instanceof
name|DetectedDbEntity
operator|)
condition|)
block|{
operator|(
operator|(
name|DetectedDbEntity
operator|)
name|dbEntity
operator|)
operator|.
name|setPrimaryKeyName
argument_list|(
name|pkName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|rs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// cay-479 - iterate skipped DbEntities to populate exported keys
for|for
control|(
specifier|final
name|DbEntity
name|skippedEntity
range|:
name|skippedEntities
control|)
block|{
name|loadDbRelationships
argument_list|(
name|skippedEntity
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Creates an ObjEntity for each DbEntity in the map. ObjEntities are      * created empty without      */
specifier|public
name|void
name|loadObjEntities
parameter_list|(
name|DataMap
name|map
parameter_list|)
block|{
name|Iterator
argument_list|<
name|DbEntity
argument_list|>
name|dbEntities
init|=
name|dbEntityList
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dbEntities
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|ObjEntity
argument_list|>
name|loadedEntities
init|=
operator|new
name|ArrayList
argument_list|<
name|ObjEntity
argument_list|>
argument_list|(
name|dbEntityList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|packageName
init|=
name|map
operator|.
name|getDefaultPackage
argument_list|()
decl_stmt|;
if|if
condition|(
name|Util
operator|.
name|isEmptyString
argument_list|(
name|packageName
argument_list|)
condition|)
block|{
name|packageName
operator|=
literal|""
expr_stmt|;
block|}
if|else if
condition|(
operator|!
name|packageName
operator|.
name|endsWith
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
name|packageName
operator|=
name|packageName
operator|+
literal|"."
expr_stmt|;
block|}
comment|// load empty ObjEntities for all the tables
while|while
condition|(
name|dbEntities
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|DbEntity
name|dbEntity
init|=
name|dbEntities
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// check if there are existing entities
name|Collection
argument_list|<
name|ObjEntity
argument_list|>
name|existing
init|=
name|map
operator|.
name|getMappedEntities
argument_list|(
name|dbEntity
argument_list|)
decl_stmt|;
if|if
condition|(
name|existing
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|loadedEntities
operator|.
name|addAll
argument_list|(
name|existing
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|String
name|objEntityName
init|=
name|namingStrategy
operator|.
name|createObjEntityName
argument_list|(
name|dbEntity
argument_list|)
decl_stmt|;
comment|// this loop will terminate even if no valid name is found
comment|// to prevent loader from looping forever (though such case is very
comment|// unlikely)
name|String
name|baseName
init|=
name|objEntityName
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
literal|1000
operator|&&
name|map
operator|.
name|getObjEntity
argument_list|(
name|objEntityName
argument_list|)
operator|!=
literal|null
condition|;
name|i
operator|++
control|)
block|{
name|objEntityName
operator|=
name|baseName
operator|+
name|i
expr_stmt|;
block|}
name|ObjEntity
name|objEntity
init|=
operator|new
name|ObjEntity
argument_list|(
name|objEntityName
argument_list|)
decl_stmt|;
name|objEntity
operator|.
name|setDbEntity
argument_list|(
name|dbEntity
argument_list|)
expr_stmt|;
name|objEntity
operator|.
name|setClassName
argument_list|(
name|getGenericClassName
argument_list|()
operator|!=
literal|null
condition|?
name|getGenericClassName
argument_list|()
else|:
name|packageName
operator|+
name|objEntity
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|map
operator|.
name|addObjEntity
argument_list|(
name|objEntity
argument_list|)
expr_stmt|;
name|loadedEntities
operator|.
name|add
argument_list|(
name|objEntity
argument_list|)
expr_stmt|;
comment|// added entity without attributes or relationships...
if|if
condition|(
name|delegate
operator|!=
literal|null
condition|)
block|{
name|delegate
operator|.
name|objEntityAdded
argument_list|(
name|objEntity
argument_list|)
expr_stmt|;
block|}
block|}
comment|// update ObjEntity attributes and relationships
operator|new
name|EntityMergeSupport
argument_list|(
name|map
argument_list|,
name|namingStrategy
argument_list|,
operator|!
name|creatingMeaningfulPK
argument_list|)
operator|.
name|synchronizeWithDbEntities
argument_list|(
name|loadedEntities
argument_list|)
expr_stmt|;
block|}
comment|/** Loads database relationships into a DataMap. */
specifier|public
name|void
name|loadDbRelationships
parameter_list|(
name|DataMap
name|map
parameter_list|)
throws|throws
name|SQLException
block|{
for|for
control|(
specifier|final
name|DbEntity
name|pkEntity
range|:
name|dbEntityList
control|)
block|{
name|loadDbRelationships
argument_list|(
name|pkEntity
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|loadDbRelationships
parameter_list|(
name|DbEntity
name|pkEntity
parameter_list|,
name|DataMap
name|map
parameter_list|)
throws|throws
name|SQLException
block|{
name|DatabaseMetaData
name|md
init|=
name|getMetaData
argument_list|()
decl_stmt|;
name|String
name|pkEntName
init|=
name|pkEntity
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// Get all the foreign keys referencing this table
name|ResultSet
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|rs
operator|=
name|md
operator|.
name|getExportedKeys
argument_list|(
name|pkEntity
operator|.
name|getCatalog
argument_list|()
argument_list|,
name|pkEntity
operator|.
name|getSchema
argument_list|()
argument_list|,
name|pkEntity
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|cay182Ex
parameter_list|)
block|{
comment|// Sybase-specific - the line above blows on VIEWS, see CAY-182.
name|logger
operator|.
name|info
argument_list|(
literal|"Error getting relationships for '"
operator|+
name|pkEntName
operator|+
literal|"', ignoring."
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
if|if
condition|(
operator|!
name|rs
operator|.
name|next
argument_list|()
condition|)
return|return;
comment|// these will be initailzed every time a new target entity
comment|// is found in the result set (which should be ordered by table name
comment|// among
comment|// other things)
name|DbRelationship
name|forwardRelationship
init|=
literal|null
decl_stmt|;
name|DbRelationshipDetected
name|reverseRelationship
init|=
literal|null
decl_stmt|;
name|DbEntity
name|fkEntity
init|=
literal|null
decl_stmt|;
name|ExportedKey
name|key
init|=
literal|null
decl_stmt|;
do|do
block|{
comment|// extract data from resultset
name|key
operator|=
name|ExportedKey
operator|.
name|extractData
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|short
name|keySeq
init|=
name|rs
operator|.
name|getShort
argument_list|(
literal|"KEY_SEQ"
argument_list|)
decl_stmt|;
if|if
condition|(
name|keySeq
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|forwardRelationship
operator|!=
literal|null
condition|)
block|{
name|postprocessMasterDbRelationship
argument_list|(
name|forwardRelationship
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|forwardRelationship
operator|=
literal|null
expr_stmt|;
block|}
comment|// start new entity
name|String
name|fkEntityName
init|=
name|key
operator|.
name|getFKTableName
argument_list|()
decl_stmt|;
name|String
name|fkName
init|=
name|key
operator|.
name|getFKName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|includeTableName
argument_list|(
name|fkEntityName
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|fkEntity
operator|=
name|map
operator|.
name|getDbEntity
argument_list|(
name|fkEntityName
argument_list|)
expr_stmt|;
if|if
condition|(
name|fkEntity
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"FK warning: no entity found for name '"
operator|+
name|fkEntityName
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|skippedEntities
operator|.
name|contains
argument_list|(
name|pkEntity
argument_list|)
operator|&&
name|skippedEntities
operator|.
name|contains
argument_list|(
name|fkEntity
argument_list|)
condition|)
block|{
comment|// cay-479 - don't load relationships between two
comment|// skipped entities.
continue|continue;
block|}
else|else
block|{
comment|// init relationship
name|String
name|forwardPreferredName
init|=
name|namingStrategy
operator|.
name|createDbRelationshipName
argument_list|(
name|key
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|forwardRelationship
operator|=
operator|new
name|DbRelationship
argument_list|(
name|uniqueRelName
argument_list|(
name|pkEntity
argument_list|,
name|forwardPreferredName
argument_list|)
argument_list|)
expr_stmt|;
name|forwardRelationship
operator|.
name|setSourceEntity
argument_list|(
name|pkEntity
argument_list|)
expr_stmt|;
name|forwardRelationship
operator|.
name|setTargetEntity
argument_list|(
name|fkEntity
argument_list|)
expr_stmt|;
name|pkEntity
operator|.
name|addRelationship
argument_list|(
name|forwardRelationship
argument_list|)
expr_stmt|;
name|String
name|reversePreferredName
init|=
name|namingStrategy
operator|.
name|createDbRelationshipName
argument_list|(
name|key
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reverseRelationship
operator|=
operator|new
name|DbRelationshipDetected
argument_list|(
name|uniqueRelName
argument_list|(
name|fkEntity
argument_list|,
name|reversePreferredName
argument_list|)
argument_list|)
expr_stmt|;
name|reverseRelationship
operator|.
name|setFkName
argument_list|(
name|fkName
argument_list|)
expr_stmt|;
name|reverseRelationship
operator|.
name|setToMany
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|reverseRelationship
operator|.
name|setSourceEntity
argument_list|(
name|fkEntity
argument_list|)
expr_stmt|;
name|reverseRelationship
operator|.
name|setTargetEntity
argument_list|(
name|pkEntity
argument_list|)
expr_stmt|;
name|fkEntity
operator|.
name|addRelationship
argument_list|(
name|reverseRelationship
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fkEntity
operator|!=
literal|null
condition|)
block|{
comment|// Create and append joins
name|String
name|pkName
init|=
name|key
operator|.
name|getPKColumnName
argument_list|()
decl_stmt|;
name|String
name|fkName
init|=
name|key
operator|.
name|getFKColumnName
argument_list|()
decl_stmt|;
comment|// skip invalid joins...
name|DbAttribute
name|pkAtt
init|=
operator|(
name|DbAttribute
operator|)
name|pkEntity
operator|.
name|getAttribute
argument_list|(
name|pkName
argument_list|)
decl_stmt|;
if|if
condition|(
name|pkAtt
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"no attribute for declared primary key: "
operator|+
name|pkName
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|DbAttribute
name|fkAtt
init|=
operator|(
name|DbAttribute
operator|)
name|fkEntity
operator|.
name|getAttribute
argument_list|(
name|fkName
argument_list|)
decl_stmt|;
if|if
condition|(
name|fkAtt
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"no attribute for declared foreign key: "
operator|+
name|fkName
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|forwardRelationship
operator|!=
literal|null
condition|)
block|{
name|forwardRelationship
operator|.
name|addJoin
argument_list|(
operator|new
name|DbJoin
argument_list|(
name|forwardRelationship
argument_list|,
name|pkName
argument_list|,
name|fkName
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reverseRelationship
operator|!=
literal|null
condition|)
block|{
name|reverseRelationship
operator|.
name|addJoin
argument_list|(
operator|new
name|DbJoin
argument_list|(
name|reverseRelationship
argument_list|,
name|fkName
argument_list|,
name|pkName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
do|;
if|if
condition|(
name|forwardRelationship
operator|!=
literal|null
condition|)
block|{
name|postprocessMasterDbRelationship
argument_list|(
name|forwardRelationship
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|forwardRelationship
operator|=
literal|null
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|rs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Detects correct relationship multiplicity and "to dep pk" flag. Only      * called on relationships from PK to FK, not the reverse ones.      */
specifier|protected
name|void
name|postprocessMasterDbRelationship
parameter_list|(
name|DbRelationship
name|relationship
parameter_list|,
name|ExportedKey
name|key
parameter_list|)
block|{
name|boolean
name|toPK
init|=
literal|true
decl_stmt|;
name|List
argument_list|<
name|DbJoin
argument_list|>
name|joins
init|=
name|relationship
operator|.
name|getJoins
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|DbJoin
name|join
range|:
name|joins
control|)
block|{
if|if
condition|(
operator|!
name|join
operator|.
name|getTarget
argument_list|()
operator|.
name|isPrimaryKey
argument_list|()
condition|)
block|{
name|toPK
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
name|boolean
name|toDependentPK
init|=
literal|false
decl_stmt|;
name|boolean
name|toMany
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|toPK
condition|)
block|{
name|toDependentPK
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|DbEntity
operator|)
name|relationship
operator|.
name|getTargetEntity
argument_list|()
operator|)
operator|.
name|getPrimaryKeys
argument_list|()
operator|.
name|size
argument_list|()
operator|==
name|joins
operator|.
name|size
argument_list|()
condition|)
block|{
name|toMany
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|// if this is really to-one we need to rename the relationship
if|if
condition|(
operator|!
name|toMany
condition|)
block|{
name|Entity
name|source
init|=
name|relationship
operator|.
name|getSourceEntity
argument_list|()
decl_stmt|;
name|source
operator|.
name|removeRelationship
argument_list|(
name|relationship
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|relationship
operator|.
name|setName
argument_list|(
name|DbLoader
operator|.
name|uniqueRelName
argument_list|(
name|source
argument_list|,
name|namingStrategy
operator|.
name|createDbRelationshipName
argument_list|(
name|key
argument_list|,
literal|false
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|source
operator|.
name|addRelationship
argument_list|(
name|relationship
argument_list|)
expr_stmt|;
block|}
name|relationship
operator|.
name|setToDependentPK
argument_list|(
name|toDependentPK
argument_list|)
expr_stmt|;
name|relationship
operator|.
name|setToMany
argument_list|(
name|toMany
argument_list|)
expr_stmt|;
block|}
comment|/**      * @since 3.2      */
specifier|public
name|String
index|[]
name|getDefaultTableTypes
parameter_list|()
block|{
name|String
name|viewType
init|=
name|adapter
operator|.
name|tableTypeForView
argument_list|()
decl_stmt|;
name|String
name|tableType
init|=
name|adapter
operator|.
name|tableTypeForTable
argument_list|()
decl_stmt|;
comment|// use types that are not null
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|viewType
operator|!=
literal|null
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|viewType
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tableType
operator|!=
literal|null
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|tableType
argument_list|)
expr_stmt|;
block|}
name|String
index|[]
name|types
init|=
operator|new
name|String
index|[
name|list
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|list
operator|.
name|toArray
argument_list|(
name|types
argument_list|)
expr_stmt|;
return|return
name|types
return|;
block|}
comment|/**      * Performs database reverse engineering and generates DataMap that contains      * default mapping of the tables and views. By default will include regular      * tables and views.      *       * @since 1.0.7      * @deprecated since 3.2 use      *             {@link #load(DataMap, String, String, String, String...)}      *             method that supports catalogs.      */
specifier|public
name|DataMap
name|loadDataMapFromDB
parameter_list|(
name|String
name|schemaPattern
parameter_list|,
name|String
name|tablePattern
parameter_list|,
name|DataMap
name|dataMap
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
index|[]
name|types
init|=
name|getDefaultTableTypes
argument_list|()
decl_stmt|;
if|if
condition|(
name|types
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SQLException
argument_list|(
literal|"No supported table types found."
argument_list|)
throw|;
block|}
name|load
argument_list|(
name|dataMap
argument_list|,
literal|null
argument_list|,
name|schemaPattern
argument_list|,
name|tablePattern
argument_list|,
name|types
argument_list|)
expr_stmt|;
return|return
name|dataMap
return|;
block|}
comment|/**      * Performs database reverse engineering and generates DataMap object that      * contains default mapping of the tables and views. Allows to limit types      * of tables to read.      *       * @deprecated since 3.2 use      *             {@link #load(DataMap, String, String, String, String...)}      *             method that supports catalogs.      */
specifier|public
name|DataMap
name|loadDataMapFromDB
parameter_list|(
name|String
name|schemaPattern
parameter_list|,
name|String
name|tablePattern
parameter_list|,
name|String
index|[]
name|tableTypes
parameter_list|,
name|DataMap
name|dataMap
parameter_list|)
throws|throws
name|SQLException
block|{
name|load
argument_list|(
name|dataMap
argument_list|,
literal|null
argument_list|,
name|schemaPattern
argument_list|,
name|tablePattern
argument_list|,
name|tableTypes
argument_list|)
expr_stmt|;
return|return
name|dataMap
return|;
block|}
comment|/**      * Performs database reverse engineering to match the specified catalog,      * schema, table name and table type patterns and fills the specified      * DataMap object with DB and object mapping info.      *       * @since 3.2      */
specifier|public
name|void
name|load
parameter_list|(
name|DataMap
name|dataMap
parameter_list|,
name|String
name|catalogPattern
parameter_list|,
name|String
name|schemaPattern
parameter_list|,
name|String
name|tablePattern
parameter_list|,
name|String
modifier|...
name|tableTypes
parameter_list|)
throws|throws
name|SQLException
block|{
if|if
condition|(
name|tablePattern
operator|==
literal|null
condition|)
block|{
name|tablePattern
operator|=
name|WILDCARD
expr_stmt|;
block|}
name|List
argument_list|<
name|DbEntity
argument_list|>
name|tables
init|=
name|getTables
argument_list|(
name|catalogPattern
argument_list|,
name|schemaPattern
argument_list|,
name|tablePattern
argument_list|,
name|tableTypes
argument_list|)
decl_stmt|;
if|if
condition|(
name|loadDbEntities
argument_list|(
name|dataMap
argument_list|,
name|tables
argument_list|)
condition|)
block|{
name|loadDbRelationships
argument_list|(
name|dataMap
argument_list|)
expr_stmt|;
name|loadObjEntities
argument_list|(
name|dataMap
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Loads database stored procedures into the DataMap.      *<p>      *<i>As of 1.1 there is no boolean property or delegate method to make      * procedure loading optional or to implement custom merging logic, so      * currently this method is NOT CALLED from "loadDataMapFromDB" and should      * be invoked explicitly by the user.</i>      *</p>      *       * @since 1.1      * @deprecated since 3.2 use      *             {@link #loadProcedures(DataMap, String, String, String)} that      *             supports "catalog" pattern.      */
specifier|public
name|void
name|loadProceduresFromDB
parameter_list|(
name|String
name|schemaPattern
parameter_list|,
name|String
name|namePattern
parameter_list|,
name|DataMap
name|dataMap
parameter_list|)
throws|throws
name|SQLException
block|{
name|loadProcedures
argument_list|(
name|dataMap
argument_list|,
literal|null
argument_list|,
name|schemaPattern
argument_list|,
name|namePattern
argument_list|)
expr_stmt|;
block|}
comment|/**      * Loads database stored procedures into the DataMap.      *<p>      *<i>As of 1.1 there is no boolean property or delegate method to make      * procedure loading optional or to implement custom merging logic, so      * currently this method is NOT CALLED from "loadDataMapFromDB" and should      * be invoked explicitly by the user.</i>      *</p>      *       * @since 3.2      */
specifier|public
name|void
name|loadProcedures
parameter_list|(
name|DataMap
name|dataMap
parameter_list|,
name|String
name|catalogPattern
parameter_list|,
name|String
name|schemaPattern
parameter_list|,
name|String
name|namePattern
parameter_list|)
throws|throws
name|SQLException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Procedure
argument_list|>
name|procedures
init|=
literal|null
decl_stmt|;
comment|// get procedures
name|ResultSet
name|rs
init|=
name|getMetaData
argument_list|()
operator|.
name|getProcedures
argument_list|(
name|catalogPattern
argument_list|,
name|schemaPattern
argument_list|,
name|namePattern
argument_list|)
decl_stmt|;
try|try
block|{
while|while
condition|(
name|rs
operator|.
name|next
argument_list|()
condition|)
block|{
name|String
name|name
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"PROCEDURE_NAME"
argument_list|)
decl_stmt|;
comment|// TODO: this will be moved to Delegate...
if|if
condition|(
name|EXCLUDED_PROCEDURES
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"skipping Cayenne PK procedure: "
operator|+
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|String
name|catalog
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"PROCEDURE_CAT"
argument_list|)
decl_stmt|;
name|String
name|schema
init|=
name|rs
operator|.
name|getString
argument_list|(
literal|"PROCEDURE_SCHEM"
argument_list|)
decl_stmt|;
name|short
name|type
init|=
name|rs
operator|.
name|getShort
argument_list|(
literal|"PROCEDURE_TYPE"
argument_list|)
decl_stmt|;
name|Procedure
name|procedure
init|=
operator|new
name|Procedure
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|procedure
operator|.
name|setCatalog
argument_list|(
name|catalog
argument_list|)
expr_stmt|;
name|procedure
operator|.
name|setSchema
argument_list|(
name|schema
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DatabaseMetaData
operator|.
name|procedureNoResult
case|:
case|case
name|DatabaseMetaData
operator|.
name|procedureResultUnknown
case|:
name|procedure
operator|.
name|setReturningValue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|DatabaseMetaData
operator|.
name|procedureReturnsResult
case|:
name|procedure
operator|.
name|setReturningValue
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|procedures
operator|==
literal|null
condition|)
block|{
name|procedures
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Procedure
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|procedures
operator|.
name|put
argument_list|(
name|procedure
operator|.
name|getFullyQualifiedName
argument_list|()
argument_list|,
name|procedure
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|rs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// if nothing found, return
if|if
condition|(
name|procedures
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// get columns
name|ResultSet
name|columnsRS
init|=
name|getMetaData
argument_list|()
operator|.
name|getProcedureColumns
argument_list|(
literal|null
argument_list|,
name|schemaPattern
argument_list|,
name|namePattern
argument_list|,
literal|null
argument_list|)
decl_stmt|;
try|try
block|{
while|while
condition|(
name|columnsRS
operator|.
name|next
argument_list|()
condition|)
block|{
name|String
name|schema
init|=
name|columnsRS
operator|.
name|getString
argument_list|(
literal|"PROCEDURE_SCHEM"
argument_list|)
decl_stmt|;
name|String
name|name
init|=
name|columnsRS
operator|.
name|getString
argument_list|(
literal|"PROCEDURE_NAME"
argument_list|)
decl_stmt|;
comment|// TODO: this will be moved to Delegate...
if|if
condition|(
name|EXCLUDED_PROCEDURES
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|String
name|columnName
init|=
name|columnsRS
operator|.
name|getString
argument_list|(
literal|"COLUMN_NAME"
argument_list|)
decl_stmt|;
name|short
name|type
init|=
name|columnsRS
operator|.
name|getShort
argument_list|(
literal|"COLUMN_TYPE"
argument_list|)
decl_stmt|;
name|String
name|key
init|=
operator|(
name|schema
operator|!=
literal|null
operator|)
condition|?
name|schema
operator|+
literal|'.'
operator|+
name|name
else|:
name|name
decl_stmt|;
comment|// skip ResultSet columns, as they are not described in Cayenne
comment|// procedures
comment|// yet...
if|if
condition|(
name|type
operator|==
name|DatabaseMetaData
operator|.
name|procedureColumnResult
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"skipping ResultSet column: "
operator|+
name|key
operator|+
literal|"."
operator|+
name|columnName
argument_list|)
expr_stmt|;
block|}
name|Procedure
name|procedure
init|=
name|procedures
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|procedure
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"invalid procedure column, no procedure found: "
operator|+
name|key
operator|+
literal|"."
operator|+
name|columnName
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ProcedureParameter
name|column
init|=
operator|new
name|ProcedureParameter
argument_list|(
name|columnName
argument_list|)
decl_stmt|;
if|if
condition|(
name|columnName
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|DatabaseMetaData
operator|.
name|procedureColumnReturn
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"null column name, assuming result column: "
operator|+
name|key
argument_list|)
expr_stmt|;
name|column
operator|.
name|setName
argument_list|(
literal|"_return_value"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"invalid null column name, skipping column : "
operator|+
name|key
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|int
name|columnType
init|=
name|columnsRS
operator|.
name|getInt
argument_list|(
literal|"DATA_TYPE"
argument_list|)
decl_stmt|;
name|int
name|columnSize
init|=
name|columnsRS
operator|.
name|getInt
argument_list|(
literal|"LENGTH"
argument_list|)
decl_stmt|;
comment|// ignore precision of non-decimal columns
name|int
name|decimalDigits
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|TypesMapping
operator|.
name|isDecimal
argument_list|(
name|columnType
argument_list|)
condition|)
block|{
name|decimalDigits
operator|=
name|columnsRS
operator|.
name|getShort
argument_list|(
literal|"SCALE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|columnsRS
operator|.
name|wasNull
argument_list|()
condition|)
block|{
name|decimalDigits
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DatabaseMetaData
operator|.
name|procedureColumnIn
case|:
name|column
operator|.
name|setDirection
argument_list|(
name|ProcedureParameter
operator|.
name|IN_PARAMETER
argument_list|)
expr_stmt|;
break|break;
case|case
name|DatabaseMetaData
operator|.
name|procedureColumnInOut
case|:
name|column
operator|.
name|setDirection
argument_list|(
name|ProcedureParameter
operator|.
name|IN_OUT_PARAMETER
argument_list|)
expr_stmt|;
break|break;
case|case
name|DatabaseMetaData
operator|.
name|procedureColumnOut
case|:
name|column
operator|.
name|setDirection
argument_list|(
name|ProcedureParameter
operator|.
name|OUT_PARAMETER
argument_list|)
expr_stmt|;
break|break;
case|case
name|DatabaseMetaData
operator|.
name|procedureColumnReturn
case|:
name|procedure
operator|.
name|setReturningValue
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
name|column
operator|.
name|setMaxLength
argument_list|(
name|columnSize
argument_list|)
expr_stmt|;
name|column
operator|.
name|setPrecision
argument_list|(
name|decimalDigits
argument_list|)
expr_stmt|;
name|column
operator|.
name|setProcedure
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
name|column
operator|.
name|setType
argument_list|(
name|columnType
argument_list|)
expr_stmt|;
name|procedure
operator|.
name|addCallParameter
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|columnsRS
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|Procedure
name|procedure
range|:
name|procedures
operator|.
name|values
argument_list|()
control|)
block|{
comment|// overwrite existing procedures...
name|dataMap
operator|.
name|addProcedure
argument_list|(
name|procedure
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Sets new naming strategy for reverse engineering      *       * @since 3.0      */
specifier|public
name|void
name|setNamingStrategy
parameter_list|(
name|NamingStrategy
name|strategy
parameter_list|)
block|{
comment|// null values are not allowed
if|if
condition|(
name|strategy
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Null strategy not allowed"
argument_list|)
throw|;
block|}
name|this
operator|.
name|namingStrategy
operator|=
name|strategy
expr_stmt|;
block|}
comment|/**      * @return naming strategy for reverse engineering      * @since 3.0      */
specifier|public
name|NamingStrategy
name|getNamingStrategy
parameter_list|()
block|{
return|return
name|namingStrategy
return|;
block|}
block|}
end_class

end_unit

