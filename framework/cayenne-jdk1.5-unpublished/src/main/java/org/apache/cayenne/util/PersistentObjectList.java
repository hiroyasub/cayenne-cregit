begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************  *   Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing,  *  software distributed under the License is distributed on an  *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *  KIND, either express or implied.  See the License for the  *  specific language governing permissions and limitations  *  under the License.  ****************************************************************/
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|CayenneRuntimeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|PersistenceState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|Persistent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|ValueHolder
import|;
end_import

begin_comment
comment|/**  * A list of persistent objects lazily resolved on the first access.  *   * @since 1.2  */
end_comment

begin_class
specifier|public
class|class
name|PersistentObjectList
extends|extends
name|RelationshipFault
implements|implements
name|List
implements|,
name|ValueHolder
block|{
comment|// wrapped objects list
specifier|protected
name|List
name|objectList
decl_stmt|;
comment|// track additions/removals in unresolved...
specifier|protected
name|LinkedList
name|addedToUnresolved
decl_stmt|;
specifier|protected
name|LinkedList
argument_list|<
name|Object
argument_list|>
name|removedFromUnresolved
decl_stmt|;
comment|// exists for the benefit of manual serialization schemes such as the one in Hessian.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|private
name|PersistentObjectList
parameter_list|()
block|{
block|}
comment|/**      * Creates PersistentObjectList initializing it with list owner persistent object and      * relationship name that this list maps to.      *       * @param relationshipOwner persistent object that owns this list.      * @param relationshipName a query used to resolve the list      */
specifier|public
name|PersistentObjectList
parameter_list|(
name|Persistent
name|relationshipOwner
parameter_list|,
name|String
name|relationshipName
parameter_list|)
block|{
name|super
argument_list|(
name|relationshipOwner
argument_list|,
name|relationshipName
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns whether this list is not yet resolved and requires a fetch.      */
specifier|public
name|boolean
name|isFault
parameter_list|()
block|{
if|if
condition|(
name|objectList
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// resolve on the fly if owner is transient... Can't do it in constructor, as
comment|// object may be in an inconsistent state during construction time
comment|// synchronize??
if|else if
condition|(
name|isTransientParent
argument_list|()
condition|)
block|{
name|objectList
operator|=
operator|new
name|LinkedList
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/**      * Turns itself into a fault, thus forcing a refresh on the next access.      */
specifier|public
name|void
name|invalidate
parameter_list|()
block|{
name|setObjectList
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Object
name|setValueDirectly
parameter_list|(
name|Object
name|value
parameter_list|)
throws|throws
name|CayenneRuntimeException
block|{
if|if
condition|(
name|value
operator|==
literal|null
operator|||
name|value
operator|instanceof
name|List
condition|)
block|{
name|Object
name|old
init|=
name|this
operator|.
name|objectList
decl_stmt|;
name|setObjectList
argument_list|(
operator|(
name|List
operator|)
name|value
argument_list|)
expr_stmt|;
return|return
name|old
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Value must be a list, got: "
operator|+
name|value
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|public
name|Object
name|getValue
parameter_list|()
throws|throws
name|CayenneRuntimeException
block|{
return|return
name|resolvedObjectList
argument_list|()
return|;
block|}
specifier|public
name|Object
name|getValueDirectly
parameter_list|()
throws|throws
name|CayenneRuntimeException
block|{
return|return
name|objectList
return|;
block|}
specifier|public
name|Object
name|setValue
parameter_list|(
name|Object
name|value
parameter_list|)
throws|throws
name|CayenneRuntimeException
block|{
name|resolvedObjectList
argument_list|()
expr_stmt|;
return|return
name|setValueDirectly
argument_list|(
name|objectList
argument_list|)
return|;
block|}
specifier|public
name|void
name|setObjectList
parameter_list|(
name|List
name|objectList
parameter_list|)
block|{
name|this
operator|.
name|objectList
operator|=
name|objectList
expr_stmt|;
block|}
comment|// ====================================================
comment|// Standard List Methods.
comment|// ====================================================
specifier|public
name|boolean
name|add
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|(
name|isFault
argument_list|()
operator|)
condition|?
name|addLocal
argument_list|(
name|o
argument_list|)
else|:
name|objectList
operator|.
name|add
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|postprocessAdd
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|void
name|add
parameter_list|(
name|int
name|index
parameter_list|,
name|Object
name|o
parameter_list|)
block|{
name|resolvedObjectList
argument_list|()
operator|.
name|add
argument_list|(
name|index
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|postprocessAdd
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|addAll
parameter_list|(
name|Collection
name|c
parameter_list|)
block|{
if|if
condition|(
name|resolvedObjectList
argument_list|()
operator|.
name|addAll
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|// TODO: here we assume that all objects were added, while addAll may
comment|// technically return true and add only some objects... need a smarter
comment|// approach (maybe use "contains" in postprocessAdd"?)
name|postprocessAdd
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|boolean
name|addAll
parameter_list|(
name|int
name|index
parameter_list|,
name|Collection
name|c
parameter_list|)
block|{
if|if
condition|(
name|resolvedObjectList
argument_list|()
operator|.
name|addAll
argument_list|(
name|index
argument_list|,
name|c
argument_list|)
condition|)
block|{
comment|// TODO: here we assume that all objects were added, while addAll may
comment|// technically return true and add only some objects... need a smarter
comment|// approach (maybe use "contains" in postprocessAdd"?)
name|postprocessAdd
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|List
name|resolved
init|=
name|resolvedObjectList
argument_list|()
decl_stmt|;
name|postprocessRemove
argument_list|(
name|resolved
argument_list|)
expr_stmt|;
name|resolved
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|resolvedObjectList
argument_list|()
operator|.
name|contains
argument_list|(
name|o
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|containsAll
parameter_list|(
name|Collection
name|c
parameter_list|)
block|{
return|return
name|resolvedObjectList
argument_list|()
operator|.
name|containsAll
argument_list|(
name|c
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|PersistentObjectList
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|resolvedObjectList
argument_list|()
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|PersistentObjectList
operator|)
name|o
operator|)
operator|.
name|resolvedObjectList
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
literal|37
operator|+
name|resolvedObjectList
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
specifier|public
name|Object
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|resolvedObjectList
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
specifier|public
name|int
name|indexOf
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|resolvedObjectList
argument_list|()
operator|.
name|indexOf
argument_list|(
name|o
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|resolvedObjectList
argument_list|()
operator|.
name|isEmpty
argument_list|()
return|;
block|}
specifier|public
name|Iterator
name|iterator
parameter_list|()
block|{
return|return
name|resolvedObjectList
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
specifier|public
name|int
name|lastIndexOf
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|resolvedObjectList
argument_list|()
operator|.
name|lastIndexOf
argument_list|(
name|o
argument_list|)
return|;
block|}
specifier|public
name|ListIterator
name|listIterator
parameter_list|()
block|{
return|return
name|resolvedObjectList
argument_list|()
operator|.
name|listIterator
argument_list|()
return|;
block|}
specifier|public
name|ListIterator
name|listIterator
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|resolvedObjectList
argument_list|()
operator|.
name|listIterator
argument_list|(
name|index
argument_list|)
return|;
block|}
specifier|public
name|Object
name|remove
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|Object
name|removed
init|=
name|resolvedObjectList
argument_list|()
operator|.
name|remove
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|postprocessRemove
argument_list|(
name|removed
argument_list|)
expr_stmt|;
return|return
name|removed
return|;
block|}
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|(
name|isFault
argument_list|()
operator|)
condition|?
name|removeLocal
argument_list|(
name|o
argument_list|)
else|:
name|objectList
operator|.
name|remove
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|postprocessRemove
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
name|c
parameter_list|)
block|{
if|if
condition|(
name|resolvedObjectList
argument_list|()
operator|.
name|removeAll
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|// TODO: here we assume that all objects were removed, while removeAll may
comment|// technically return true and remove only some objects... need a smarter
comment|// approach
name|postprocessRemove
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
name|c
parameter_list|)
block|{
comment|// TODO: handle object graoh change notifications on object removals...
return|return
name|resolvedObjectList
argument_list|()
operator|.
name|retainAll
argument_list|(
name|c
argument_list|)
return|;
block|}
specifier|public
name|Object
name|set
parameter_list|(
name|int
name|index
parameter_list|,
name|Object
name|o
parameter_list|)
block|{
name|Object
name|oldValue
init|=
name|resolvedObjectList
argument_list|()
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|o
argument_list|)
decl_stmt|;
name|postprocessAdd
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|postprocessRemove
argument_list|(
name|oldValue
argument_list|)
expr_stmt|;
return|return
name|oldValue
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|resolvedObjectList
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
specifier|public
name|List
name|subList
parameter_list|(
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|)
block|{
comment|// TODO: should we wrap a sublist into a list that does notifications on
comment|// additions/removals?
return|return
name|resolvedObjectList
argument_list|()
operator|.
name|subList
argument_list|(
name|fromIndex
argument_list|,
name|toIndex
argument_list|)
return|;
block|}
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
return|return
name|resolvedObjectList
argument_list|()
operator|.
name|toArray
argument_list|()
return|;
block|}
specifier|public
name|Object
index|[]
name|toArray
parameter_list|(
name|Object
index|[]
name|a
parameter_list|)
block|{
return|return
name|resolvedObjectList
argument_list|()
operator|.
name|toArray
argument_list|(
name|a
argument_list|)
return|;
block|}
comment|// ====================================================
comment|// Tracking list modifications, and resolving it
comment|// on demand
comment|// ====================================================
comment|/**      * Returns internal objects list resolving it if needed.      */
specifier|protected
name|List
name|resolvedObjectList
parameter_list|()
block|{
if|if
condition|(
name|isFault
argument_list|()
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// now that we obtained the lock, check
comment|// if another thread just resolved the list
if|if
condition|(
name|isFault
argument_list|()
condition|)
block|{
name|List
name|localList
init|=
name|resolveFromDB
argument_list|()
decl_stmt|;
name|mergeLocalChanges
argument_list|(
name|localList
argument_list|)
expr_stmt|;
name|this
operator|.
name|objectList
operator|=
name|localList
expr_stmt|;
block|}
block|}
block|}
return|return
name|objectList
return|;
block|}
specifier|protected
name|void
name|clearLocalChanges
parameter_list|()
block|{
name|addedToUnresolved
operator|=
literal|null
expr_stmt|;
name|removedFromUnresolved
operator|=
literal|null
expr_stmt|;
block|}
specifier|protected
name|void
name|mergeLocalChanges
parameter_list|(
name|List
name|fetchedList
parameter_list|)
block|{
comment|// only merge if an object is in an uncommitted state
comment|// any other state means that our local tracking
comment|// is invalid...
if|if
condition|(
name|isUncommittedParent
argument_list|()
condition|)
block|{
if|if
condition|(
name|removedFromUnresolved
operator|!=
literal|null
condition|)
block|{
name|fetchedList
operator|.
name|removeAll
argument_list|(
name|removedFromUnresolved
argument_list|)
expr_stmt|;
block|}
comment|// add only those that are not already on the list
comment|// do not include transient objects...
if|if
condition|(
name|addedToUnresolved
operator|!=
literal|null
operator|&&
operator|!
name|addedToUnresolved
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Iterator
name|it
init|=
name|addedToUnresolved
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Object
name|next
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|next
operator|instanceof
name|Persistent
condition|)
block|{
name|Persistent
name|dataObject
init|=
operator|(
name|Persistent
operator|)
name|next
decl_stmt|;
if|if
condition|(
name|dataObject
operator|.
name|getPersistenceState
argument_list|()
operator|==
name|PersistenceState
operator|.
name|TRANSIENT
condition|)
block|{
continue|continue;
block|}
block|}
if|if
condition|(
operator|!
name|fetchedList
operator|.
name|contains
argument_list|(
name|next
argument_list|)
condition|)
block|{
name|fetchedList
operator|.
name|add
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// clear local information in any event
name|clearLocalChanges
argument_list|()
expr_stmt|;
block|}
specifier|protected
name|boolean
name|addLocal
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|removedFromUnresolved
operator|!=
literal|null
condition|)
block|{
name|removedFromUnresolved
operator|.
name|remove
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addedToUnresolved
operator|==
literal|null
condition|)
block|{
name|addedToUnresolved
operator|=
operator|new
name|LinkedList
argument_list|()
expr_stmt|;
block|}
name|addedToUnresolved
operator|.
name|addLast
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|// this is really meaningless, since we don't know
comment|// if an object was present in the list
return|return
literal|true
return|;
block|}
specifier|protected
name|boolean
name|removeLocal
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|addedToUnresolved
operator|!=
literal|null
condition|)
block|{
name|addedToUnresolved
operator|.
name|remove
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|removedFromUnresolved
operator|==
literal|null
condition|)
block|{
name|removedFromUnresolved
operator|=
operator|new
name|LinkedList
argument_list|<
name|Object
argument_list|>
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|shouldAddToRemovedFromUnresolvedList
argument_list|(
name|object
argument_list|)
condition|)
block|{
name|removedFromUnresolved
operator|.
name|addLast
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
comment|// this is really meaningless, since we don't know
comment|// if an object was present in the list
return|return
literal|true
return|;
block|}
comment|/**      * @return whether object should be added to {@link #removedFromUnresolved} during removal      */
specifier|protected
name|boolean
name|shouldAddToRemovedFromUnresolvedList
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
specifier|protected
name|void
name|postprocessAdd
parameter_list|(
name|Collection
name|collection
parameter_list|)
block|{
name|Iterator
name|it
init|=
name|collection
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|postprocessAdd
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|postprocessRemove
parameter_list|(
name|Collection
name|collection
parameter_list|)
block|{
name|Iterator
name|it
init|=
name|collection
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|postprocessRemove
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|postprocessAdd
parameter_list|(
name|Object
name|addedObject
parameter_list|)
block|{
comment|// notify ObjectContext
if|if
condition|(
name|relationshipOwner
operator|.
name|getObjectContext
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|relationshipOwner
operator|.
name|getObjectContext
argument_list|()
operator|.
name|propertyChanged
argument_list|(
name|relationshipOwner
argument_list|,
name|relationshipName
argument_list|,
literal|null
argument_list|,
name|addedObject
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|postprocessRemove
parameter_list|(
name|Object
name|removedObject
parameter_list|)
block|{
comment|// notify ObjectContext
if|if
condition|(
name|relationshipOwner
operator|.
name|getObjectContext
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|relationshipOwner
operator|.
name|getObjectContext
argument_list|()
operator|.
name|propertyChanged
argument_list|(
name|relationshipOwner
argument_list|,
name|relationshipName
argument_list|,
name|removedObject
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
operator|(
name|objectList
operator|!=
literal|null
operator|)
condition|?
name|objectList
operator|.
name|toString
argument_list|()
else|:
literal|"[<unresolved>]"
return|;
block|}
block|}
end_class

end_unit

