begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************  *   Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing,  *  software distributed under the License is distributed on an  *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *  KIND, either express or implied.  See the License for the  *  specific language governing permissions and limitations  *  under the License.  ****************************************************************/
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cayenne
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|DbAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|DbJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|DbRelationship
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|EmbeddedAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|EntityResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|ObjAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|ObjEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|ObjRelationship
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|PropertyUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|validation
operator|.
name|BeanValidationFailure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|validation
operator|.
name|ValidationFailure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|validation
operator|.
name|ValidationResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|xml
operator|.
name|XMLDecoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|xml
operator|.
name|XMLEncoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|xml
operator|.
name|XMLSerializable
import|;
end_import

begin_comment
comment|/**  * A default implementation of DataObject interface. It is normally used as a superclass  * of Cayenne persistent objects.  */
end_comment

begin_class
specifier|public
class|class
name|CayenneDataObject
extends|extends
name|PersistentObject
implements|implements
name|DataObject
implements|,
name|Validating
implements|,
name|XMLSerializable
block|{
specifier|protected
name|long
name|snapshotVersion
init|=
name|DEFAULT_VERSION
decl_stmt|;
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|values
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|setPersistenceState
parameter_list|(
name|int
name|persistenceState
parameter_list|)
block|{
name|this
operator|.
name|persistenceState
operator|=
name|persistenceState
expr_stmt|;
if|if
condition|(
name|persistenceState
operator|==
name|PersistenceState
operator|.
name|HOLLOW
condition|)
block|{
name|values
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Returns a value of the property identified by a property path. Supports reading      * both mapped and unmapped properties. Unmapped properties are accessed in a manner      * consistent with JavaBeans specification.      *<p>      * Property path (or nested property) is a dot-separated path used to traverse object      * relationships until the final object is found. If a null object found while      * traversing path, null is returned. If a list is encountered in the middle of the      * path, CayenneRuntimeException is thrown. Unlike      * {@link #readPropertyDirectly(String)}, this method will resolve an object if it is      * HOLLOW.      *<p>      * Examples:      *</p>      *<ul>      *<li>Read this object property:<br>      *<code>String name = (String)artist.readNestedProperty("name");</code><br>      *<br>      *</li>      *<li>Read an object related to this object:<br>      *<code>Gallery g = (Gallery)paintingInfo.readNestedProperty("toPainting.toGallery");</code>      *<br>      *<br>      *</li>      *<li>Read a property of an object related to this object:<br>      *<code>String name = (String)painting.readNestedProperty("toArtist.artistName");</code>      *<br>      *<br>      *</li>      *<li>Read to-many relationship list:<br>      *<code>List exhibits = (List)painting.readNestedProperty("toGallery.exhibitArray");</code>      *<br>      *<br>      *</li>      *<li>Read to-many relationship in the middle of the path:<br>      *<code>List<String> names = (List<String>)artist.readNestedProperty("paintingArray.paintingName");</code>      *<br>      *<br>      *</li>      *</ul>      *       * @since 1.0.5      */
specifier|public
name|Object
name|readNestedProperty
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
operator|(
literal|null
operator|==
name|path
operator|)
operator|||
operator|(
literal|0
operator|==
name|path
operator|.
name|length
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"the path must be supplied in order to lookup a nested property"
argument_list|)
throw|;
block|}
name|int
name|dotIndex
init|=
name|path
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|dotIndex
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"the path is invalid because it starts with a period character"
argument_list|)
throw|;
block|}
if|if
condition|(
name|dotIndex
operator|==
name|path
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"the path is invalid because it ends with a period character"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|-
literal|1
operator|==
name|dotIndex
condition|)
block|{
return|return
name|readSimpleProperty
argument_list|(
name|path
argument_list|)
return|;
block|}
name|String
name|path0
init|=
name|path
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|dotIndex
argument_list|)
decl_stmt|;
name|String
name|pathRemainder
init|=
name|path
operator|.
name|substring
argument_list|(
name|dotIndex
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|// this is copied from the old code where the placement of a plus
comment|// character at the end of a segment of a property path would
comment|// simply strip out the plus. I am not entirely sure why this is
comment|// done. See unit test 'testReadNestedPropertyToManyInMiddle1'.
if|if
condition|(
literal|'+'
operator|==
name|path0
operator|.
name|charAt
argument_list|(
name|path0
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
condition|)
block|{
name|path0
operator|=
name|path0
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|path0
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|Object
name|property
init|=
name|readSimpleProperty
argument_list|(
name|path0
argument_list|)
decl_stmt|;
if|if
condition|(
name|property
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|else if
condition|(
name|property
operator|instanceof
name|DataObject
condition|)
block|{
return|return
operator|(
operator|(
name|DataObject
operator|)
name|property
operator|)
operator|.
name|readNestedProperty
argument_list|(
name|pathRemainder
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Cayenne
operator|.
name|readNestedProperty
argument_list|(
name|property
argument_list|,
name|pathRemainder
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|final
name|Object
name|readSimpleProperty
parameter_list|(
name|String
name|property
parameter_list|)
block|{
comment|// side effect - resolves HOLLOW object
name|Object
name|object
init|=
name|readProperty
argument_list|(
name|property
argument_list|)
decl_stmt|;
comment|// if a null value is returned, there is still a chance to
comment|// find a non-persistent property via reflection
if|if
condition|(
name|object
operator|==
literal|null
operator|&&
operator|!
name|values
operator|.
name|containsKey
argument_list|(
name|property
argument_list|)
condition|)
block|{
name|object
operator|=
name|PropertyUtils
operator|.
name|getProperty
argument_list|(
name|this
argument_list|,
name|property
argument_list|)
expr_stmt|;
block|}
return|return
name|object
return|;
block|}
specifier|public
name|Object
name|readProperty
parameter_list|(
name|String
name|propertyName
parameter_list|)
block|{
if|if
condition|(
name|objectContext
operator|!=
literal|null
condition|)
block|{
comment|// will resolve faults ourselves below as checking class descriptors for the
comment|// "lazyFaulting" flag is inefficient. Passing "false" here to suppress fault
comment|// processing
name|objectContext
operator|.
name|prepareForAccess
argument_list|(
name|this
argument_list|,
name|propertyName
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|Object
name|object
init|=
name|readPropertyDirectly
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
if|if
condition|(
name|object
operator|instanceof
name|Fault
condition|)
block|{
name|object
operator|=
operator|(
operator|(
name|Fault
operator|)
name|object
operator|)
operator|.
name|resolveFault
argument_list|(
name|this
argument_list|,
name|propertyName
argument_list|)
expr_stmt|;
name|writePropertyDirectly
argument_list|(
name|propertyName
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
return|return
name|object
return|;
block|}
specifier|public
name|Object
name|readPropertyDirectly
parameter_list|(
name|String
name|propName
parameter_list|)
block|{
return|return
name|values
operator|.
name|get
argument_list|(
name|propName
argument_list|)
return|;
block|}
specifier|public
name|void
name|writeProperty
parameter_list|(
name|String
name|propName
parameter_list|,
name|Object
name|val
parameter_list|)
block|{
if|if
condition|(
name|objectContext
operator|!=
literal|null
condition|)
block|{
comment|// pass "false" to avoid unneeded fault processing
name|objectContext
operator|.
name|prepareForAccess
argument_list|(
name|this
argument_list|,
name|propName
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// note how we notify ObjectContext of change BEFORE the object is actually
comment|// changed... this is needed to take a valid current snapshot
name|Object
name|oldValue
init|=
name|readPropertyDirectly
argument_list|(
name|propName
argument_list|)
decl_stmt|;
name|objectContext
operator|.
name|propertyChanged
argument_list|(
name|this
argument_list|,
name|propName
argument_list|,
name|oldValue
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|writePropertyDirectly
argument_list|(
name|propName
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|writePropertyDirectly
parameter_list|(
name|String
name|propName
parameter_list|,
name|Object
name|val
parameter_list|)
block|{
name|values
operator|.
name|put
argument_list|(
name|propName
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|removeToManyTarget
parameter_list|(
name|String
name|relName
parameter_list|,
name|DataObject
name|value
parameter_list|,
name|boolean
name|setReverse
parameter_list|)
block|{
comment|// Now do the rest of the normal handling (regardless of whether it was
comment|// flattened or not)
name|Object
name|holder
init|=
name|readProperty
argument_list|(
name|relName
argument_list|)
decl_stmt|;
comment|// call 'propertyChanged' AFTER readProperty as readProperty ensures that this
comment|// object fault is resolved
name|getObjectContext
argument_list|()
operator|.
name|propertyChanged
argument_list|(
name|this
argument_list|,
name|relName
argument_list|,
name|value
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// TODO: andrus 8/20/2007 - can we optimize this somehow, avoiding type checking??
if|if
condition|(
name|holder
operator|instanceof
name|Collection
condition|)
block|{
operator|(
operator|(
name|Collection
argument_list|<
name|Object
argument_list|>
operator|)
name|holder
operator|)
operator|.
name|remove
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|holder
operator|instanceof
name|Map
condition|)
block|{
operator|(
operator|(
name|Map
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
operator|)
name|holder
operator|)
operator|.
name|remove
argument_list|(
name|getMapKey
argument_list|(
name|relName
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|setReverse
condition|)
block|{
name|unsetReverseRelationship
argument_list|(
name|relName
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|addToManyTarget
parameter_list|(
name|String
name|relName
parameter_list|,
name|DataObject
name|value
parameter_list|,
name|boolean
name|setReverse
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Attempt to add null target DataObject."
argument_list|)
throw|;
block|}
name|willConnect
argument_list|(
name|relName
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|// Now do the rest of the normal handling (regardless of whether it was
comment|// flattened or not)
name|Object
name|holder
init|=
name|readProperty
argument_list|(
name|relName
argument_list|)
decl_stmt|;
comment|// call 'propertyChanged' AFTER readProperty as readProperty ensures that this
comment|// object fault is resolved
name|getObjectContext
argument_list|()
operator|.
name|propertyChanged
argument_list|(
name|this
argument_list|,
name|relName
argument_list|,
literal|null
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|// TODO: andrus 8/20/2007 - can we optimize this somehow, avoiding type checking??
if|if
condition|(
name|holder
operator|instanceof
name|Collection
condition|)
block|{
operator|(
operator|(
name|Collection
argument_list|<
name|Object
argument_list|>
operator|)
name|holder
operator|)
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|holder
operator|instanceof
name|Map
condition|)
block|{
operator|(
operator|(
name|Map
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
operator|)
name|holder
operator|)
operator|.
name|put
argument_list|(
name|getMapKey
argument_list|(
name|relName
argument_list|,
name|value
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setReverse
condition|)
block|{
name|setReverseRelationship
argument_list|(
name|relName
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|setToOneTarget
parameter_list|(
name|String
name|relationshipName
parameter_list|,
name|DataObject
name|value
parameter_list|,
name|boolean
name|setReverse
parameter_list|)
block|{
name|willConnect
argument_list|(
name|relationshipName
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|Object
name|oldTarget
init|=
name|readProperty
argument_list|(
name|relationshipName
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldTarget
operator|==
name|value
condition|)
block|{
return|return;
block|}
name|getObjectContext
argument_list|()
operator|.
name|propertyChanged
argument_list|(
name|this
argument_list|,
name|relationshipName
argument_list|,
name|oldTarget
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|setReverse
condition|)
block|{
comment|// unset old reverse relationship
if|if
condition|(
name|oldTarget
operator|instanceof
name|DataObject
condition|)
block|{
name|unsetReverseRelationship
argument_list|(
name|relationshipName
argument_list|,
operator|(
name|DataObject
operator|)
name|oldTarget
argument_list|)
expr_stmt|;
block|}
comment|// set new reverse relationship
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|setReverseRelationship
argument_list|(
name|relationshipName
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|objectContext
operator|.
name|prepareForAccess
argument_list|(
name|this
argument_list|,
name|relationshipName
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|writePropertyDirectly
argument_list|(
name|relationshipName
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**      * Called before establishing a relationship with another object. Applies "persistence      * by reachability" logic, pulling one of the two objects to a DataConext of another      * object in case one of the objects is transient. If both objects are persistent, and      * they don't have the same DataContext, CayenneRuntimeException is thrown.      *       * @since 1.2      */
specifier|protected
name|void
name|willConnect
parameter_list|(
name|String
name|relationshipName
parameter_list|,
name|Persistent
name|object
parameter_list|)
block|{
comment|// first handle most common case - both objects are in the same
comment|// ObjectContext or target is null
if|if
condition|(
name|object
operator|==
literal|null
operator|||
name|this
operator|.
name|getObjectContext
argument_list|()
operator|==
name|object
operator|.
name|getObjectContext
argument_list|()
condition|)
block|{
return|return;
block|}
if|else if
condition|(
name|this
operator|.
name|getObjectContext
argument_list|()
operator|==
literal|null
operator|&&
name|object
operator|.
name|getObjectContext
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|object
operator|.
name|getObjectContext
argument_list|()
operator|.
name|registerNewObject
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|this
operator|.
name|getObjectContext
argument_list|()
operator|!=
literal|null
operator|&&
name|object
operator|.
name|getObjectContext
argument_list|()
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|getObjectContext
argument_list|()
operator|.
name|registerNewObject
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Cannot set object as destination of relationship "
operator|+
name|relationshipName
operator|+
literal|" because it is in a different ObjectContext"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Initializes reverse relationship from object<code>val</code> to this object.      *       * @param relName name of relationship from this object to<code>val</code>.      */
specifier|protected
name|void
name|setReverseRelationship
parameter_list|(
name|String
name|relName
parameter_list|,
name|DataObject
name|val
parameter_list|)
block|{
name|ObjRelationship
name|rel
init|=
operator|(
name|ObjRelationship
operator|)
name|objectContext
operator|.
name|getEntityResolver
argument_list|()
operator|.
name|getObjEntity
argument_list|(
name|objectId
operator|.
name|getEntityName
argument_list|()
argument_list|)
operator|.
name|getRelationship
argument_list|(
name|relName
argument_list|)
decl_stmt|;
name|ObjRelationship
name|revRel
init|=
name|rel
operator|.
name|getReverseRelationship
argument_list|()
decl_stmt|;
if|if
condition|(
name|revRel
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|revRel
operator|.
name|isToMany
argument_list|()
condition|)
name|val
operator|.
name|addToManyTarget
argument_list|(
name|revRel
operator|.
name|getName
argument_list|()
argument_list|,
name|this
argument_list|,
literal|false
argument_list|)
expr_stmt|;
else|else
name|val
operator|.
name|setToOneTarget
argument_list|(
name|revRel
operator|.
name|getName
argument_list|()
argument_list|,
name|this
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Removes current object from reverse relationship of object<code>val</code> to this      * object.      */
specifier|protected
name|void
name|unsetReverseRelationship
parameter_list|(
name|String
name|relName
parameter_list|,
name|DataObject
name|val
parameter_list|)
block|{
name|EntityResolver
name|resolver
init|=
name|objectContext
operator|.
name|getEntityResolver
argument_list|()
decl_stmt|;
name|ObjEntity
name|entity
init|=
name|resolver
operator|.
name|getObjEntity
argument_list|(
name|objectId
operator|.
name|getEntityName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|entity
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"DataObject's entity is unmapped, objectId: "
operator|+
name|objectId
argument_list|)
throw|;
block|}
name|ObjRelationship
name|rel
init|=
operator|(
name|ObjRelationship
operator|)
name|entity
operator|.
name|getRelationship
argument_list|(
name|relName
argument_list|)
decl_stmt|;
name|ObjRelationship
name|revRel
init|=
name|rel
operator|.
name|getReverseRelationship
argument_list|()
decl_stmt|;
if|if
condition|(
name|revRel
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|revRel
operator|.
name|isToMany
argument_list|()
condition|)
name|val
operator|.
name|removeToManyTarget
argument_list|(
name|revRel
operator|.
name|getName
argument_list|()
argument_list|,
name|this
argument_list|,
literal|false
argument_list|)
expr_stmt|;
else|else
name|val
operator|.
name|setToOneTarget
argument_list|(
name|revRel
operator|.
name|getName
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * A variation of "toString" method, that may be more efficient in some cases. For      * example when printing a list of objects into the same String.      */
specifier|public
name|StringBuffer
name|toStringBuffer
parameter_list|(
name|StringBuffer
name|buffer
parameter_list|,
name|boolean
name|fullDesc
parameter_list|)
block|{
name|String
name|id
init|=
operator|(
name|objectId
operator|!=
literal|null
operator|)
condition|?
name|objectId
operator|.
name|toString
argument_list|()
else|:
literal|"<no id>"
decl_stmt|;
name|String
name|state
init|=
name|PersistenceState
operator|.
name|persistenceStateName
argument_list|(
name|persistenceState
argument_list|)
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
operator|.
name|append
argument_list|(
name|id
argument_list|)
operator|.
name|append
argument_list|(
literal|"; "
argument_list|)
operator|.
name|append
argument_list|(
name|state
argument_list|)
operator|.
name|append
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullDesc
condition|)
block|{
name|appendProperties
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|buffer
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
specifier|protected
name|void
name|appendProperties
parameter_list|(
name|StringBuffer
name|buffer
parameter_list|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|it
init|=
name|values
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|entry
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"=>"
argument_list|)
expr_stmt|;
name|Object
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Persistent
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
operator|.
name|append
argument_list|(
operator|(
operator|(
name|Persistent
operator|)
name|value
operator|)
operator|.
name|getObjectId
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|value
operator|instanceof
name|Collection
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|"(..)"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|value
operator|instanceof
name|Fault
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buffer
operator|.
name|append
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
block|}
block|}
name|buffer
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|toStringBuffer
argument_list|(
operator|new
name|StringBuffer
argument_list|()
argument_list|,
literal|true
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|void
name|writeObject
parameter_list|(
name|ObjectOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|persistenceState
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|persistenceState
condition|)
block|{
comment|// New, modified or transient or deleted - write the whole shebang
comment|// The other states (committed, hollow) all need just ObjectId
case|case
name|PersistenceState
operator|.
name|TRANSIENT
case|:
case|case
name|PersistenceState
operator|.
name|NEW
case|:
case|case
name|PersistenceState
operator|.
name|MODIFIED
case|:
case|case
name|PersistenceState
operator|.
name|DELETED
case|:
name|out
operator|.
name|writeObject
argument_list|(
name|values
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
operator|.
name|writeObject
argument_list|(
name|objectId
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|this
operator|.
name|persistenceState
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|persistenceState
condition|)
block|{
case|case
name|PersistenceState
operator|.
name|TRANSIENT
case|:
case|case
name|PersistenceState
operator|.
name|NEW
case|:
case|case
name|PersistenceState
operator|.
name|MODIFIED
case|:
case|case
name|PersistenceState
operator|.
name|DELETED
case|:
name|values
operator|=
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
operator|)
name|in
operator|.
name|readObject
argument_list|()
expr_stmt|;
break|break;
case|case
name|PersistenceState
operator|.
name|COMMITTED
case|:
case|case
name|PersistenceState
operator|.
name|HOLLOW
case|:
name|this
operator|.
name|persistenceState
operator|=
name|PersistenceState
operator|.
name|HOLLOW
expr_stmt|;
comment|// props will be populated when required (readProperty called)
name|values
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
expr_stmt|;
break|break;
block|}
name|this
operator|.
name|objectId
operator|=
operator|(
name|ObjectId
operator|)
name|in
operator|.
name|readObject
argument_list|()
expr_stmt|;
comment|// DataContext will be set *IF* the DataContext it came from is also
comment|// deserialized. Setting of DataContext is handled by the DataContext
comment|// itself
block|}
comment|/**      * Returns a version of a DataRow snapshot that was used to create this object.      *       * @since 1.1      */
specifier|public
name|long
name|getSnapshotVersion
parameter_list|()
block|{
return|return
name|snapshotVersion
return|;
block|}
comment|/**      * @since 1.1      */
specifier|public
name|void
name|setSnapshotVersion
parameter_list|(
name|long
name|snapshotVersion
parameter_list|)
block|{
name|this
operator|.
name|snapshotVersion
operator|=
name|snapshotVersion
expr_stmt|;
block|}
comment|/**      * Performs property validation of the object, appending any validation failures to      * the provided validationResult object. This method is invoked from "validateFor.."      * before committing a NEW or MODIFIED object to the database. Validation includes      * checking for null values and value sizes. CayenneDataObject subclasses may override      * this method, calling super.      *       * @since 1.1      */
specifier|protected
name|void
name|validateForSave
parameter_list|(
name|ValidationResult
name|validationResult
parameter_list|)
block|{
name|ObjEntity
name|objEntity
init|=
name|getObjectContext
argument_list|()
operator|.
name|getEntityResolver
argument_list|()
operator|.
name|lookupObjEntity
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|objEntity
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"No ObjEntity mapping found for DataObject "
operator|+
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
comment|// validate mandatory attributes
comment|// handling a special case - meaningful mandatory FK... defer failures until
comment|// relationship validation is done... This is just a temporary solution, as
comment|// handling meaningful keys within the object lifecycle requires something more,
comment|// namely read/write methods for relationships and direct values should be
comment|// synchronous with each other..
name|Map
argument_list|<
name|String
argument_list|,
name|ValidationFailure
argument_list|>
name|failedDbAttributes
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Object
name|next
range|:
name|objEntity
operator|.
name|getAttributes
argument_list|()
control|)
block|{
comment|// TODO: andrus, 2/20/2007 - handle embedded attribute
if|if
condition|(
name|next
operator|instanceof
name|EmbeddedAttribute
condition|)
block|{
continue|continue;
block|}
name|ObjAttribute
name|objAttribute
init|=
operator|(
name|ObjAttribute
operator|)
name|next
decl_stmt|;
name|DbAttribute
name|dbAttribute
init|=
name|objAttribute
operator|.
name|getDbAttribute
argument_list|()
decl_stmt|;
if|if
condition|(
name|dbAttribute
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"ObjAttribute '"
operator|+
name|objAttribute
operator|.
name|getName
argument_list|()
operator|+
literal|"' does not have a corresponding DbAttribute"
argument_list|)
throw|;
block|}
comment|// pk may still be generated
if|if
condition|(
name|dbAttribute
operator|.
name|isPrimaryKey
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|Object
name|value
init|=
name|this
operator|.
name|readPropertyDirectly
argument_list|(
name|objAttribute
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|dbAttribute
operator|.
name|isMandatory
argument_list|()
condition|)
block|{
name|ValidationFailure
name|failure
init|=
name|BeanValidationFailure
operator|.
name|validateNotNull
argument_list|(
name|this
argument_list|,
name|objAttribute
operator|.
name|getName
argument_list|()
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|failure
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|failedDbAttributes
operator|==
literal|null
condition|)
block|{
name|failedDbAttributes
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ValidationFailure
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|failedDbAttributes
operator|.
name|put
argument_list|(
name|dbAttribute
operator|.
name|getName
argument_list|()
argument_list|,
name|failure
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|// validate length
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|dbAttribute
operator|.
name|getMaxLength
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|getClass
argument_list|()
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|int
name|len
init|=
name|Array
operator|.
name|getLength
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|dbAttribute
operator|.
name|getMaxLength
argument_list|()
condition|)
block|{
name|String
name|message
init|=
literal|"\""
operator|+
name|objAttribute
operator|.
name|getName
argument_list|()
operator|+
literal|"\" exceeds maximum allowed length ("
operator|+
name|dbAttribute
operator|.
name|getMaxLength
argument_list|()
operator|+
literal|" bytes): "
operator|+
name|len
decl_stmt|;
name|validationResult
operator|.
name|addFailure
argument_list|(
operator|new
name|BeanValidationFailure
argument_list|(
name|this
argument_list|,
name|objAttribute
operator|.
name|getName
argument_list|()
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|value
operator|instanceof
name|CharSequence
condition|)
block|{
name|int
name|len
init|=
operator|(
operator|(
name|CharSequence
operator|)
name|value
operator|)
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|dbAttribute
operator|.
name|getMaxLength
argument_list|()
condition|)
block|{
name|String
name|message
init|=
literal|"\""
operator|+
name|objAttribute
operator|.
name|getName
argument_list|()
operator|+
literal|"\" exceeds maximum allowed length ("
operator|+
name|dbAttribute
operator|.
name|getMaxLength
argument_list|()
operator|+
literal|" chars): "
operator|+
name|len
decl_stmt|;
name|validationResult
operator|.
name|addFailure
argument_list|(
operator|new
name|BeanValidationFailure
argument_list|(
name|this
argument_list|,
name|objAttribute
operator|.
name|getName
argument_list|()
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// validate mandatory relationships
for|for
control|(
specifier|final
name|ObjRelationship
name|relationship
range|:
name|objEntity
operator|.
name|getRelationships
argument_list|()
control|)
block|{
if|if
condition|(
name|relationship
operator|.
name|isSourceIndependentFromTargetChange
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|List
argument_list|<
name|DbRelationship
argument_list|>
name|dbRels
init|=
name|relationship
operator|.
name|getDbRelationships
argument_list|()
decl_stmt|;
if|if
condition|(
name|dbRels
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
comment|// if db relationship is not based on a PK and is based on mandatory
comment|// attributes, see if we have a target object set
name|boolean
name|validate
init|=
literal|true
decl_stmt|;
name|DbRelationship
name|dbRelationship
init|=
name|dbRels
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|DbJoin
name|join
range|:
name|dbRelationship
operator|.
name|getJoins
argument_list|()
control|)
block|{
name|DbAttribute
name|source
init|=
name|join
operator|.
name|getSource
argument_list|()
decl_stmt|;
if|if
condition|(
name|source
operator|.
name|isMandatory
argument_list|()
condition|)
block|{
comment|// clear attribute failures...
if|if
condition|(
name|failedDbAttributes
operator|!=
literal|null
operator|&&
operator|!
name|failedDbAttributes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|failedDbAttributes
operator|.
name|remove
argument_list|(
name|source
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// loop through all joins if there were previous mandatory
comment|// attribute failures....
if|if
condition|(
operator|!
name|failedDbAttributes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
block|}
block|}
else|else
block|{
comment|// do not validate if the relation is based on
comment|// multiple keys with some that can be nullable.
name|validate
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|validate
condition|)
block|{
name|Object
name|value
init|=
name|this
operator|.
name|readPropertyDirectly
argument_list|(
name|relationship
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|ValidationFailure
name|failure
init|=
name|BeanValidationFailure
operator|.
name|validateNotNull
argument_list|(
name|this
argument_list|,
name|relationship
operator|.
name|getName
argument_list|()
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|failure
operator|!=
literal|null
condition|)
block|{
name|validationResult
operator|.
name|addFailure
argument_list|(
name|failure
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// deal with previously found attribute failures...
if|if
condition|(
name|failedDbAttributes
operator|!=
literal|null
operator|&&
operator|!
name|failedDbAttributes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|ValidationFailure
name|failure
range|:
name|failedDbAttributes
operator|.
name|values
argument_list|()
control|)
block|{
name|validationResult
operator|.
name|addFailure
argument_list|(
name|failure
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Calls {@link #validateForSave(ValidationResult)}. CayenneDataObject subclasses may      * override it providing validation logic that should be executed for the newly      * created objects before saving them.      *       * @since 1.1      */
specifier|public
name|void
name|validateForInsert
parameter_list|(
name|ValidationResult
name|validationResult
parameter_list|)
block|{
name|validateForSave
argument_list|(
name|validationResult
argument_list|)
expr_stmt|;
block|}
comment|/**      * Calls {@link #validateForSave(ValidationResult)}. CayenneDataObject subclasses may      * override it providing validation logic that should be executed for the modified      * objects before saving them.      *       * @since 1.1      */
specifier|public
name|void
name|validateForUpdate
parameter_list|(
name|ValidationResult
name|validationResult
parameter_list|)
block|{
name|validateForSave
argument_list|(
name|validationResult
argument_list|)
expr_stmt|;
block|}
comment|/**      * This implementation does nothing. CayenneDataObject subclasses may override it      * providing validation logic that should be executed for the deleted objects before      * committing them.      *       * @since 1.1      */
specifier|public
name|void
name|validateForDelete
parameter_list|(
name|ValidationResult
name|validationResult
parameter_list|)
block|{
comment|// does nothing
block|}
comment|/**      * Encodes object to XML using provided encoder.      *       * @since 1.2      * @deprecated since 3.1 this XML serialization package is deprecated and will be      *             removed in the following releases. It has a number of functional and      *             performance limitations that make it impossible to evolve further. A      *             replacement may be provided in an undefined future. For now we      *             recommend the users to implement XML serialization of persistent      *             objects based JAXB, XStream or other similar frameworks.      */
specifier|public
name|void
name|encodeAsXML
parameter_list|(
name|XMLEncoder
name|encoder
parameter_list|)
block|{
name|EntityResolver
name|er
init|=
name|getObjectContext
argument_list|()
operator|.
name|getEntityResolver
argument_list|()
decl_stmt|;
name|ObjEntity
name|objectEntity
init|=
name|er
operator|.
name|lookupObjEntity
argument_list|(
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
name|String
index|[]
name|fields
init|=
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|split
argument_list|(
literal|"\\."
argument_list|)
decl_stmt|;
name|encoder
operator|.
name|setRoot
argument_list|(
name|fields
index|[
name|fields
operator|.
name|length
operator|-
literal|1
index|]
argument_list|,
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|ObjAttribute
name|att
range|:
name|objectEntity
operator|.
name|getDeclaredAttributes
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|att
operator|.
name|getName
argument_list|()
decl_stmt|;
name|encoder
operator|.
name|encodeProperty
argument_list|(
name|name
argument_list|,
name|readNestedProperty
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @deprecated since 3.1 this XML serialization package is deprecated and will be      *             removed in the following releases. It has a number of functional and      *             performance limitations that make it impossible to evolve further. A      *             replacement may be provided in an undefined future. For now we      *             recommend the users to implement XML serialization of persistent      *             objects based JAXB, XStream or other similar frameworks.      */
specifier|public
name|void
name|decodeFromXML
parameter_list|(
name|XMLDecoder
name|decoder
parameter_list|)
block|{
name|DataChannel
name|channel
init|=
name|BaseContext
operator|.
name|getThreadDeserializationChannel
argument_list|()
decl_stmt|;
if|if
condition|(
name|channel
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Can't perform deserialization - no DataChannel bound to the current thread."
argument_list|)
throw|;
block|}
name|EntityResolver
name|resolver
init|=
name|channel
operator|.
name|getEntityResolver
argument_list|()
decl_stmt|;
name|ObjEntity
name|objectEntity
init|=
name|resolver
operator|.
name|lookupObjEntity
argument_list|(
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|ObjAttribute
name|att
range|:
name|objectEntity
operator|.
name|getDeclaredAttributes
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|att
operator|.
name|getName
argument_list|()
decl_stmt|;
name|writeProperty
argument_list|(
name|name
argument_list|,
name|decoder
operator|.
name|decodeObject
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @since 1.2      */
annotation|@
name|Override
specifier|public
name|void
name|setObjectContext
parameter_list|(
name|ObjectContext
name|objectContext
parameter_list|)
block|{
name|this
operator|.
name|objectContext
operator|=
name|objectContext
expr_stmt|;
if|if
condition|(
name|objectContext
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|persistenceState
operator|=
name|PersistenceState
operator|.
name|TRANSIENT
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

