begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************  *   Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing,  *  software distributed under the License is distributed on an  *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *  KIND, either express or implied.  See the License for the  *  specific language governing permissions and limitations  *  under the License.  ****************************************************************/
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|xml
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|DocumentBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|CayenneRuntimeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|Persistent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|ObjectContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|access
operator|.
name|DataContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|PropertyUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Element
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|InputSource
import|;
end_import

begin_comment
comment|/**  * XMLDecoder is used to decode XML into objects.  *   * @author Kevin J. Menard, Jr.  * @since 1.2  */
end_comment

begin_class
specifier|public
class|class
name|XMLDecoder
block|{
specifier|static
specifier|final
name|Map
name|classMapping
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
static|static
block|{
name|classMapping
operator|.
name|put
argument_list|(
literal|"boolean"
argument_list|,
name|Boolean
operator|.
name|class
argument_list|)
expr_stmt|;
name|classMapping
operator|.
name|put
argument_list|(
literal|"int"
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
expr_stmt|;
name|classMapping
operator|.
name|put
argument_list|(
literal|"char"
argument_list|,
name|Character
operator|.
name|class
argument_list|)
expr_stmt|;
name|classMapping
operator|.
name|put
argument_list|(
literal|"float"
argument_list|,
name|Float
operator|.
name|class
argument_list|)
expr_stmt|;
name|classMapping
operator|.
name|put
argument_list|(
literal|"byte"
argument_list|,
name|Byte
operator|.
name|class
argument_list|)
expr_stmt|;
name|classMapping
operator|.
name|put
argument_list|(
literal|"short"
argument_list|,
name|Short
operator|.
name|class
argument_list|)
expr_stmt|;
name|classMapping
operator|.
name|put
argument_list|(
literal|"long"
argument_list|,
name|Long
operator|.
name|class
argument_list|)
expr_stmt|;
name|classMapping
operator|.
name|put
argument_list|(
literal|"double"
argument_list|,
name|Double
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|/** The root of the XML document being decoded. */
specifier|private
name|Element
name|root
decl_stmt|;
comment|/** The context to register decoded DataObjects with. */
specifier|private
name|ObjectContext
name|objectContext
decl_stmt|;
comment|// TODO: H to the A to the C to the K
specifier|private
name|List
argument_list|<
name|Element
argument_list|>
name|decodedCollections
init|=
operator|new
name|ArrayList
argument_list|<
name|Element
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Default constructor. This will create an XMLDecoder instance that will decode      * objects from XML, but will not register them with any context.      *       * @see XMLDecoder#XMLDecoder(ObjectContext)      */
specifier|public
name|XMLDecoder
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates an XMLDecoder that will register decoded DataObjects with the specified      * context.      *       * @param objectContext The context to register decoded DataObjects with.      */
specifier|public
name|XMLDecoder
parameter_list|(
name|ObjectContext
name|objectContext
parameter_list|)
block|{
name|this
operator|.
name|objectContext
operator|=
name|objectContext
expr_stmt|;
block|}
comment|/**      * Decodes an XML element to a Boolean.      *       * @param xmlTag The tag identifying the element.      * @return The tag's value.      */
specifier|public
name|Boolean
name|decodeBoolean
parameter_list|(
name|String
name|xmlTag
parameter_list|)
block|{
name|String
name|val
init|=
name|decodeString
argument_list|(
name|xmlTag
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|val
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/**      * Decodes an XML element to a Double.      *       * @param xmlTag The tag identifying the element.      * @return The tag's value.      */
specifier|public
name|Double
name|decodeDouble
parameter_list|(
name|String
name|xmlTag
parameter_list|)
block|{
name|String
name|val
init|=
name|decodeString
argument_list|(
name|xmlTag
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|val
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|Double
operator|.
name|valueOf
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/**      * Decodes an XML element to a Float.      *       * @param xmlTag The tag identifying the element.      * @return The tag's value.      */
specifier|public
name|Float
name|decodeFloat
parameter_list|(
name|String
name|xmlTag
parameter_list|)
block|{
name|String
name|val
init|=
name|decodeString
argument_list|(
name|xmlTag
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|val
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|Float
operator|.
name|valueOf
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/**      * Decodes an XML element to an Integer.      *       * @param xmlTag The tag identifying the element.      * @return The tag's value.      */
specifier|public
name|Integer
name|decodeInteger
parameter_list|(
name|String
name|xmlTag
parameter_list|)
block|{
name|String
name|val
init|=
name|decodeString
argument_list|(
name|xmlTag
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|val
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|Integer
operator|.
name|valueOf
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/**      * Decodes an object from XML.      *       * @param xmlTag The XML tag corresponding to the root of the encoded object.      * @return The decoded object.      */
specifier|public
name|Object
name|decodeObject
parameter_list|(
name|String
name|xmlTag
parameter_list|)
block|{
comment|// Find the XML element corresponding to the supplied tag.
name|Element
name|child
init|=
name|XMLUtil
operator|.
name|getChild
argument_list|(
name|root
argument_list|,
name|xmlTag
argument_list|)
decl_stmt|;
return|return
name|decodeObject
argument_list|(
name|child
argument_list|)
return|;
block|}
comment|/**      * Decodes an XML element to an Object.      *       * @param child The XML element.      * @return The tag's value.      */
specifier|private
name|Object
name|decodeObject
parameter_list|(
name|Element
name|child
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|child
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|type
init|=
name|child
operator|.
name|getAttribute
argument_list|(
literal|"type"
argument_list|)
decl_stmt|;
if|if
condition|(
name|Util
operator|.
name|isEmptyString
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|// TODO should we use String by default? Or guess from the property type?
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"No type specified for tag '"
operator|+
name|child
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"'."
argument_list|)
throw|;
block|}
comment|// temp hack to support primitives...
name|Class
name|objectClass
init|=
operator|(
name|Class
operator|)
name|classMapping
operator|.
name|get
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|objectClass
condition|)
block|{
try|try
block|{
name|objectClass
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Unrecognized class '"
operator|+
name|objectClass
operator|+
literal|"'"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
try|try
block|{
comment|// This crazy conditional checks if we're decoding a collection. There are two
comment|// ways to enter into this body:
comment|// 1) If there are two elements at the same level with the same name, then
comment|// they should be part of a collection.
comment|// 2) If a single occurring element has the "forceList" attribute set to
comment|// "YES", then it too should be treated as a collection.
comment|//
comment|// The final part checks that we have not previously attempted to decode this
comment|// collection, which is necessary to prevent infinite loops .
if|if
condition|(
operator|(
operator|(
operator|(
literal|null
operator|!=
name|child
operator|.
name|getParentNode
argument_list|()
operator|)
operator|&&
operator|(
name|XMLUtil
operator|.
name|getChildren
argument_list|(
name|child
operator|.
name|getParentNode
argument_list|()
argument_list|,
name|child
operator|.
name|getNodeName
argument_list|()
argument_list|)
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|)
operator|)
operator|||
operator|(
name|child
operator|.
name|getAttribute
argument_list|(
literal|"forceList"
argument_list|)
operator|.
name|toUpperCase
argument_list|()
operator|.
name|equals
argument_list|(
literal|"YES"
argument_list|)
operator|)
operator|)
operator|&&
operator|(
operator|!
name|decodedCollections
operator|.
name|contains
argument_list|(
name|child
argument_list|)
operator|)
condition|)
block|{
return|return
name|decodeCollection
argument_list|(
name|child
argument_list|)
return|;
block|}
comment|// If the object implements XMLSerializable, delegate decoding to the class's
comment|// implementation of decodeFromXML().
if|if
condition|(
name|XMLSerializable
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|objectClass
argument_list|)
condition|)
block|{
comment|// Fix for decoding 1-to-1 relationships between the same class type, per CAY-597.
comment|// If we don't re-root the tree, the decoder goes into an infinite loop.  In particular,
comment|// if R1 -> R2, when it decodes R1, it will attempt to decode R2, but without re-rooting,
comment|// the decoder tries to decode R1 again, think it's decoding R2, because R1 is the first
comment|// element of that type found in the XML doc with the true root of the doc.
name|Element
name|oldRoot
init|=
name|root
decl_stmt|;
name|root
operator|=
name|child
expr_stmt|;
name|XMLSerializable
name|ret
init|=
operator|(
name|XMLSerializable
operator|)
name|objectClass
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|ret
operator|.
name|decodeFromXML
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Restore the root when we're done decoding the child.
name|root
operator|=
name|oldRoot
expr_stmt|;
return|return
name|ret
return|;
block|}
name|String
name|text
init|=
name|XMLUtil
operator|.
name|getText
argument_list|(
name|child
argument_list|)
decl_stmt|;
comment|// handle dates using hardcoded format....
if|if
condition|(
name|Date
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|objectClass
argument_list|)
condition|)
block|{
try|try
block|{
return|return
operator|new
name|SimpleDateFormat
argument_list|(
name|XMLUtil
operator|.
name|DEFAULT_DATE_FORMAT
argument_list|)
operator|.
name|parse
argument_list|(
name|text
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
comment|// handle pre-3.0 default data format for backwards compatibilty
try|try
block|{
return|return
operator|new
name|SimpleDateFormat
argument_list|(
literal|"E MMM dd hh:mm:ss z yyyy"
argument_list|)
operator|.
name|parse
argument_list|(
name|text
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|eOld
parameter_list|)
block|{
comment|// rethrow the original exception
throw|throw
name|e
throw|;
block|}
block|}
block|}
comment|// handle all other primitive types...
name|Constructor
name|c
init|=
name|objectClass
operator|.
name|getConstructor
argument_list|(
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|c
operator|.
name|newInstance
argument_list|(
name|text
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Error decoding tag '"
operator|+
name|child
operator|.
name|getNodeName
argument_list|()
operator|+
literal|"'"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Decodes an XML element to a String.      *       * @param xmlTag The tag identifying the element.      * @return The tag's value.      */
specifier|public
name|String
name|decodeString
parameter_list|(
name|String
name|xmlTag
parameter_list|)
block|{
comment|// Find the XML element corresponding to the supplied tag, and simply
comment|// return its text.
name|Element
name|child
init|=
name|XMLUtil
operator|.
name|getChild
argument_list|(
name|root
argument_list|,
name|xmlTag
argument_list|)
decl_stmt|;
return|return
name|child
operator|!=
literal|null
condition|?
name|XMLUtil
operator|.
name|getText
argument_list|(
name|child
argument_list|)
else|:
literal|null
return|;
block|}
comment|/**      * Decodes XML wrapped by a Reader into an object.      *       * @param xml Wrapped XML.      * @return A new instance of the object represented by the XML.      * @throws CayenneRuntimeException      */
specifier|public
name|Object
name|decode
parameter_list|(
name|Reader
name|xml
parameter_list|)
throws|throws
name|CayenneRuntimeException
block|{
comment|// Parse the XML into a JDOM representation.
name|Document
name|data
init|=
name|parse
argument_list|(
name|xml
argument_list|)
decl_stmt|;
comment|// Delegate to the decode() method that works on JDOM elements.
return|return
name|decodeElement
argument_list|(
name|data
operator|.
name|getDocumentElement
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Decodes XML wrapped by a Reader into an object, using the supplied mapping file to      * guide the decoding process.      *       * @param xml Wrapped XML.      * @param mappingUrl Mapping file describing how the XML elements and object      *            properties correlate.      * @return A new instance of the object represented by the XML.      * @throws CayenneRuntimeException      */
specifier|public
name|Object
name|decode
parameter_list|(
name|Reader
name|xml
parameter_list|,
name|String
name|mappingUrl
parameter_list|)
throws|throws
name|CayenneRuntimeException
block|{
comment|// Parse the XML document into a JDOM representation.
name|Document
name|data
init|=
name|parse
argument_list|(
name|xml
argument_list|)
decl_stmt|;
comment|// MappingUtils will really do all the work.
name|XMLMappingDescriptor
name|mu
init|=
operator|new
name|XMLMappingDescriptor
argument_list|(
name|mappingUrl
argument_list|)
decl_stmt|;
name|Object
name|ret
init|=
name|mu
operator|.
name|decode
argument_list|(
name|data
operator|.
name|getDocumentElement
argument_list|()
argument_list|,
name|objectContext
argument_list|)
decl_stmt|;
return|return
name|ret
return|;
block|}
comment|/**      * Decodes the XML element to an object. If the supplied context is not null, the      * object will be registered with it and committed to the database.      *       * @param element The XML element.      * @return The decoded object.      * @throws CayenneRuntimeException      */
specifier|private
name|Object
name|decodeElement
parameter_list|(
name|Element
name|element
parameter_list|)
throws|throws
name|CayenneRuntimeException
block|{
comment|// Update root to be the supplied xml element. This is necessary as
comment|// root is used for decoding properties.
name|Element
name|oldRoot
init|=
name|root
decl_stmt|;
name|root
operator|=
name|element
expr_stmt|;
comment|// Create the object we're ultimately returning. It is represented
comment|// by the root element of the XML.
name|Object
name|object
decl_stmt|;
try|try
block|{
name|object
operator|=
name|decodeObject
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|th
parameter_list|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Error instantiating object"
argument_list|,
name|th
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
literal|null
operator|!=
name|objectContext
operator|)
operator|&&
operator|(
name|object
operator|instanceof
name|Persistent
operator|)
condition|)
block|{
name|objectContext
operator|.
name|registerNewObject
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
name|root
operator|=
name|oldRoot
expr_stmt|;
name|decodedCollections
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|object
return|;
block|}
comment|/**      * Decodes a Collection represented by XML wrapped by a Reader into a List of objects.      * Each object will be registered with the supplied context.      *       * @param xml The XML element representing the elements in the collection to decode.      * @return A List of all the decoded objects.      * @throws CayenneRuntimeException      */
specifier|private
name|Collection
name|decodeCollection
parameter_list|(
name|Element
name|xml
parameter_list|)
throws|throws
name|CayenneRuntimeException
block|{
name|Collection
name|ret
decl_stmt|;
try|try
block|{
name|String
name|parentClass
init|=
operator|(
operator|(
name|Element
operator|)
name|xml
operator|.
name|getParentNode
argument_list|()
operator|)
operator|.
name|getAttribute
argument_list|(
literal|"type"
argument_list|)
decl_stmt|;
name|Object
name|property
init|=
name|Class
operator|.
name|forName
argument_list|(
name|parentClass
argument_list|)
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|Collection
name|c
init|=
operator|(
name|Collection
operator|)
name|PropertyUtils
operator|.
name|getProperty
argument_list|(
name|property
argument_list|,
name|xml
operator|.
name|getNodeName
argument_list|()
argument_list|)
decl_stmt|;
name|ret
operator|=
name|c
operator|.
name|getClass
argument_list|()
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Could not create collection with no-arg constructor."
argument_list|,
name|ex
argument_list|)
throw|;
block|}
comment|// Each child of the root corresponds to an XML representation of
comment|// the object. The idea is decode each of those into an object and add them to the
comment|// list to be returned.
name|Iterator
name|it
init|=
name|XMLUtil
operator|.
name|getChildren
argument_list|(
name|xml
operator|.
name|getParentNode
argument_list|()
argument_list|,
name|xml
operator|.
name|getNodeName
argument_list|()
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// Decode the object.
name|Element
name|e
init|=
operator|(
name|Element
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|decodedCollections
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|Object
name|o
init|=
name|decodeElement
argument_list|(
name|e
argument_list|)
decl_stmt|;
comment|// Add it to the output list.
name|ret
operator|.
name|add
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**      * Decodes a list of DataObjects.      *       * @param xml The wrapped XML encoding of the list of DataObjects.      * @return The list of decoded DataObjects.      * @throws CayenneRuntimeException      */
specifier|public
specifier|static
name|List
name|decodeList
parameter_list|(
name|Reader
name|xml
parameter_list|)
throws|throws
name|CayenneRuntimeException
block|{
return|return
name|decodeList
argument_list|(
name|xml
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Decodes a list of DataObjects, registering them the supplied context.      *       * @param xml The wrapped XML encoding of the list of DataObjects.      * @param objectContext The context to register the decode DataObjects with.      * @return The list of decoded DataObjects.      * @throws CayenneRuntimeException      */
specifier|public
specifier|static
name|List
name|decodeList
parameter_list|(
name|Reader
name|xml
parameter_list|,
name|ObjectContext
name|objectContext
parameter_list|)
throws|throws
name|CayenneRuntimeException
block|{
return|return
name|decodeList
argument_list|(
name|xml
argument_list|,
literal|null
argument_list|,
name|objectContext
argument_list|)
return|;
block|}
comment|/**      * Decodes a list of DataObjects using the supplied mapping file to guide the decoding      * process.      *       * @param xml The wrapped XML encoding of the list of DataObjects.      * @param mappingUrl Mapping file describing how the XML elements and object      *            properties correlate.      * @return The list of decoded DataObjects.      * @throws CayenneRuntimeException      */
specifier|public
specifier|static
name|List
name|decodeList
parameter_list|(
name|Reader
name|xml
parameter_list|,
name|String
name|mappingUrl
parameter_list|)
throws|throws
name|CayenneRuntimeException
block|{
return|return
name|decodeList
argument_list|(
name|xml
argument_list|,
name|mappingUrl
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Decodes a list of DataObjects using the supplied mapping file to guide the decoding      * process, registering them the supplied context.      *       * @param xml The wrapped XML encoding of the list of objects.      * @param mappingUrl Mapping file describing how the XML elements and object      *            properties correlate.      * @param objectContext The context to register the decode DataObjects with.      * @return The list of decoded DataObjects.      * @throws CayenneRuntimeException      */
specifier|public
specifier|static
name|List
name|decodeList
parameter_list|(
name|Reader
name|xml
parameter_list|,
name|String
name|mappingUrl
parameter_list|,
name|ObjectContext
name|objectContext
parameter_list|)
throws|throws
name|CayenneRuntimeException
block|{
name|XMLDecoder
name|decoder
init|=
operator|new
name|XMLDecoder
argument_list|(
name|objectContext
argument_list|)
decl_stmt|;
name|Element
name|listRoot
init|=
name|parse
argument_list|(
name|xml
argument_list|)
operator|.
name|getDocumentElement
argument_list|()
decl_stmt|;
name|List
name|ret
decl_stmt|;
try|try
block|{
name|String
name|parentClass
init|=
name|listRoot
operator|.
name|getAttribute
argument_list|(
literal|"type"
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|(
name|List
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|parentClass
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Could not create collection with no-arg constructor."
argument_list|,
name|ex
argument_list|)
throw|;
block|}
name|XMLMappingDescriptor
name|mu
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|mappingUrl
operator|!=
literal|null
condition|)
block|{
name|mu
operator|=
operator|new
name|XMLMappingDescriptor
argument_list|(
name|mappingUrl
argument_list|)
expr_stmt|;
block|}
comment|// Each child of the root corresponds to an XML representation of
comment|// the object. The idea is decode each of those into an object and add them to the
comment|// list to be returned.
name|Iterator
name|it
init|=
name|XMLUtil
operator|.
name|getChildren
argument_list|(
name|listRoot
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// Decode the object.
name|Element
name|e
init|=
operator|(
name|Element
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|decoder
operator|.
name|decodedCollections
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|// Decode the item using the appropriate decoding method.
name|Object
name|o
decl_stmt|;
if|if
condition|(
name|mu
operator|!=
literal|null
condition|)
block|{
name|o
operator|=
name|mu
operator|.
name|decode
argument_list|(
name|e
argument_list|,
name|objectContext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The decoder will do context registration if needed.
name|o
operator|=
name|decoder
operator|.
name|decodeElement
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|ret
operator|.
name|add
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**      * Takes the XML wrapped in a Reader and returns a JDOM Document representation of it.      *       * @param in Wrapped XML.      * @return DOM Document wrapping the XML for use throughout the rest of the decoder.      * @throws CayenneRuntimeException      */
specifier|private
specifier|static
name|Document
name|parse
parameter_list|(
name|Reader
name|in
parameter_list|)
throws|throws
name|CayenneRuntimeException
block|{
name|DocumentBuilder
name|builder
init|=
name|XMLUtil
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|builder
operator|.
name|parse
argument_list|(
operator|new
name|InputSource
argument_list|(
name|in
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Error parsing XML"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

