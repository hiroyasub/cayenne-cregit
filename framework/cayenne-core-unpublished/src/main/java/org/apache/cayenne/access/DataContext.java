begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************  *   Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing,  *  software distributed under the License is distributed on an  *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *  KIND, either express or implied.  See the License for the  *  specific language governing permissions and limitations  *  under the License.  ****************************************************************/
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|access
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|BaseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|CayenneRuntimeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|DataChannel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|DataObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|DataRow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|Fault
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|ObjectContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|ObjectId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|PersistenceState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|Persistent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|QueryResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|ResultIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|access
operator|.
name|util
operator|.
name|IteratedSelectObserver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|event
operator|.
name|EventManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|ChildDiffLoader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|CompoundDiff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|GraphDiff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|GraphManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|DbJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|DbRelationship
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|ObjAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|ObjEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|ObjRelationship
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|query
operator|.
name|NamedQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|query
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|query
operator|.
name|QueryMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|query
operator|.
name|Select
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|AttributeProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|ClassDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|PropertyVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|ToManyProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|ToOneProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|util
operator|.
name|EventUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|util
operator|.
name|GenericResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|util
operator|.
name|ResultIteratorIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_comment
comment|/**  * The most common implementation of {@link ObjectContext}. DataContext is an  * isolated container of an object graph, in a sense that any uncommitted  * changes to persistent objects that are registered with the context, are not  * visible to the users of other contexts.  */
end_comment

begin_class
specifier|public
class|class
name|DataContext
extends|extends
name|BaseContext
block|{
specifier|private
name|DataContextDelegate
name|delegate
decl_stmt|;
specifier|protected
name|boolean
name|usingSharedSnaphsotCache
decl_stmt|;
specifier|protected
name|ObjectStore
name|objectStore
decl_stmt|;
specifier|protected
specifier|transient
name|DataContextMergeHandler
name|mergeHandler
decl_stmt|;
comment|/**      * Creates a new DataContext that is not attached to the Cayenne stack.      */
specifier|public
name|DataContext
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new DataContext with parent DataChannel and ObjectStore.      *       * @since 1.2      */
specifier|public
name|DataContext
parameter_list|(
name|DataChannel
name|channel
parameter_list|,
name|ObjectStore
name|objectStore
parameter_list|)
block|{
comment|// inject self as parent context
if|if
condition|(
name|objectStore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|objectStore
operator|=
name|objectStore
expr_stmt|;
name|objectStore
operator|.
name|setContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|channel
operator|!=
literal|null
condition|)
block|{
name|attachToChannel
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objectStore
operator|!=
literal|null
condition|)
block|{
name|DataDomain
name|domain
init|=
name|getParentDataDomain
argument_list|()
decl_stmt|;
name|this
operator|.
name|usingSharedSnaphsotCache
operator|=
name|domain
operator|!=
literal|null
operator|&&
name|objectStore
operator|.
name|getDataRowCache
argument_list|()
operator|==
name|domain
operator|.
name|getSharedSnapshotCache
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * @since 3.1      */
annotation|@
name|Override
specifier|protected
name|void
name|attachToChannel
parameter_list|(
name|DataChannel
name|channel
parameter_list|)
block|{
name|super
operator|.
name|attachToChannel
argument_list|(
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|mergeHandler
operator|!=
literal|null
condition|)
block|{
name|mergeHandler
operator|.
name|setActive
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|mergeHandler
operator|=
literal|null
expr_stmt|;
block|}
name|EventManager
name|eventManager
init|=
name|channel
operator|.
name|getEventManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|eventManager
operator|!=
literal|null
condition|)
block|{
name|mergeHandler
operator|=
operator|new
name|DataContextMergeHandler
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// listen to our channel events...
comment|// note that we must reset listener on channel switch, as there is
comment|// no
comment|// guarantee that a new channel uses the same EventManager.
name|EventUtil
operator|.
name|listenForChannelEvents
argument_list|(
name|channel
argument_list|,
name|mergeHandler
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|usingSharedSnaphsotCache
operator|&&
name|getObjectStore
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|DataRowStore
name|cache
init|=
name|getObjectStore
argument_list|()
operator|.
name|getDataRowCache
argument_list|()
decl_stmt|;
if|if
condition|(
name|cache
operator|!=
literal|null
condition|)
block|{
name|cache
operator|.
name|setEventManager
argument_list|(
name|eventManager
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Returns a DataDomain used by this DataContext. DataDomain is looked up in      * the DataChannel hierarchy. If a channel is not a DataDomain or a      * DataContext, null is returned.      *       * @return DataDomain that is a direct or indirect parent of this      *         DataContext in the DataChannel hierarchy.      * @since 1.1      */
specifier|public
name|DataDomain
name|getParentDataDomain
parameter_list|()
block|{
name|attachToRuntimeIfNeeded
argument_list|()
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|channel
operator|instanceof
name|DataDomain
condition|)
block|{
return|return
operator|(
name|DataDomain
operator|)
name|channel
return|;
block|}
name|List
name|response
init|=
name|channel
operator|.
name|onQuery
argument_list|(
name|this
argument_list|,
operator|new
name|DataDomainQuery
argument_list|()
argument_list|)
operator|.
name|firstList
argument_list|()
decl_stmt|;
if|if
condition|(
name|response
operator|!=
literal|null
operator|&&
name|response
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|response
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|DataDomain
condition|)
block|{
return|return
operator|(
name|DataDomain
operator|)
name|response
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Sets a DataContextDelegate for this context. Delegate is notified of      * certain events in the DataContext lifecycle and can customize DataContext      * behavior.      *       * @since 1.1      */
specifier|public
name|void
name|setDelegate
parameter_list|(
name|DataContextDelegate
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
block|}
comment|/**      * Returns a delegate currently associated with this DataContext.      *       * @since 1.1      */
specifier|public
name|DataContextDelegate
name|getDelegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
comment|/**      * @return a delegate instance if it is initialized, or a shared noop      *         implementation the context has no delegate. Useful to prevent      *         extra null checks and conditional logic in the code.      * @since 1.1      */
name|DataContextDelegate
name|nonNullDelegate
parameter_list|()
block|{
return|return
operator|(
name|delegate
operator|!=
literal|null
operator|)
condition|?
name|delegate
else|:
name|NoopDelegate
operator|.
name|noopDelegate
return|;
block|}
comment|/**      * Returns ObjectStore associated with this DataContext.      */
specifier|public
name|ObjectStore
name|getObjectStore
parameter_list|()
block|{
return|return
name|objectStore
return|;
block|}
comment|/**      * Returns<code>true</code> if there are any modified, deleted or new      * objects registered with this DataContext,<code>false</code> otherwise.      */
specifier|public
name|boolean
name|hasChanges
parameter_list|()
block|{
return|return
name|getObjectStore
argument_list|()
operator|.
name|hasChanges
argument_list|()
return|;
block|}
comment|/**      * Returns a list of objects that are registered with this DataContext and      * have a state PersistenceState.NEW      */
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|?
argument_list|>
name|newObjects
parameter_list|()
block|{
return|return
name|getObjectStore
argument_list|()
operator|.
name|objectsInState
argument_list|(
name|PersistenceState
operator|.
name|NEW
argument_list|)
return|;
block|}
comment|/**      * Returns a list of objects that are registered with this DataContext and      * have a state PersistenceState.DELETED      */
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|?
argument_list|>
name|deletedObjects
parameter_list|()
block|{
return|return
name|getObjectStore
argument_list|()
operator|.
name|objectsInState
argument_list|(
name|PersistenceState
operator|.
name|DELETED
argument_list|)
return|;
block|}
comment|/**      * Returns a list of objects that are registered with this DataContext and      * have a state PersistenceState.MODIFIED      */
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|?
argument_list|>
name|modifiedObjects
parameter_list|()
block|{
return|return
name|getObjectStore
argument_list|()
operator|.
name|objectsInState
argument_list|(
name|PersistenceState
operator|.
name|MODIFIED
argument_list|)
return|;
block|}
comment|/**      * Returns a collection of all uncommitted registered objects.      *       * @since 1.2      */
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|?
argument_list|>
name|uncommittedObjects
parameter_list|()
block|{
name|int
name|len
init|=
name|getObjectStore
argument_list|()
operator|.
name|registeredObjectsCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return
name|Collections
operator|.
name|EMPTY_LIST
return|;
block|}
comment|// guess target collection size
name|Collection
argument_list|<
name|Object
argument_list|>
name|objects
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|(
name|len
operator|>
literal|100
condition|?
name|len
operator|/
literal|2
else|:
name|len
argument_list|)
decl_stmt|;
name|Iterator
name|it
init|=
name|getObjectStore
argument_list|()
operator|.
name|getObjectIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Persistent
name|object
init|=
operator|(
name|Persistent
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|int
name|state
init|=
name|object
operator|.
name|getPersistenceState
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|PersistenceState
operator|.
name|MODIFIED
operator|||
name|state
operator|==
name|PersistenceState
operator|.
name|NEW
operator|||
name|state
operator|==
name|PersistenceState
operator|.
name|DELETED
condition|)
block|{
name|objects
operator|.
name|add
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|objects
return|;
block|}
comment|/**      * Returns a DataRow reflecting current, possibly uncommitted, object state.      *<p>      *<strong>Warning:</strong> This method will return a partial snapshot if      * an object or one of its related objects that propagate their keys to this      * object have temporary ids. DO NOT USE this method if you expect a DataRow      * to represent a complete object state.      *</p>      *       * @since 1.1      */
specifier|public
name|DataRow
name|currentSnapshot
parameter_list|(
specifier|final
name|Persistent
name|object
parameter_list|)
block|{
comment|// for a HOLLOW object return snapshot from cache
if|if
condition|(
name|object
operator|.
name|getPersistenceState
argument_list|()
operator|==
name|PersistenceState
operator|.
name|HOLLOW
operator|&&
name|object
operator|.
name|getObjectContext
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|getObjectStore
argument_list|()
operator|.
name|getSnapshot
argument_list|(
name|object
operator|.
name|getObjectId
argument_list|()
argument_list|)
return|;
block|}
name|ObjEntity
name|entity
init|=
name|getEntityResolver
argument_list|()
operator|.
name|getObjEntity
argument_list|(
name|object
argument_list|)
decl_stmt|;
specifier|final
name|ClassDescriptor
name|descriptor
init|=
name|getEntityResolver
argument_list|()
operator|.
name|getClassDescriptor
argument_list|(
name|entity
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|DataRow
name|snapshot
init|=
operator|new
name|DataRow
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|descriptor
operator|.
name|visitProperties
argument_list|(
operator|new
name|PropertyVisitor
argument_list|()
block|{
specifier|public
name|boolean
name|visitAttribute
parameter_list|(
name|AttributeProperty
name|property
parameter_list|)
block|{
name|ObjAttribute
name|objAttr
init|=
name|property
operator|.
name|getAttribute
argument_list|()
decl_stmt|;
comment|// processing compound attributes correctly
name|snapshot
operator|.
name|put
argument_list|(
name|objAttr
operator|.
name|getDbAttributePath
argument_list|()
argument_list|,
name|property
operator|.
name|readPropertyDirectly
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|visitToMany
parameter_list|(
name|ToManyProperty
name|property
parameter_list|)
block|{
comment|// do nothing
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|visitToOne
parameter_list|(
name|ToOneProperty
name|property
parameter_list|)
block|{
name|ObjRelationship
name|rel
init|=
name|property
operator|.
name|getRelationship
argument_list|()
decl_stmt|;
comment|// if target doesn't propagates its key value, skip it
if|if
condition|(
name|rel
operator|.
name|isSourceIndependentFromTargetChange
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|Object
name|targetObject
init|=
name|property
operator|.
name|readPropertyDirectly
argument_list|(
name|object
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetObject
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// if target is Fault, get id attributes from stored snapshot
comment|// to avoid unneeded fault triggering
if|if
condition|(
name|targetObject
operator|instanceof
name|Fault
condition|)
block|{
name|DataRow
name|storedSnapshot
init|=
name|getObjectStore
argument_list|()
operator|.
name|getSnapshot
argument_list|(
name|object
operator|.
name|getObjectId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedSnapshot
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"No matching objects found for ObjectId "
operator|+
name|object
operator|.
name|getObjectId
argument_list|()
operator|+
literal|". Object may have been deleted externally."
argument_list|)
throw|;
block|}
name|DbRelationship
name|dbRel
init|=
name|rel
operator|.
name|getDbRelationships
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|DbJoin
name|join
range|:
name|dbRel
operator|.
name|getJoins
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|join
operator|.
name|getSourceName
argument_list|()
decl_stmt|;
name|snapshot
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|storedSnapshot
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|// target is resolved and we have an FK->PK to it,
comment|// so extract it from target...
name|Persistent
name|target
init|=
operator|(
name|Persistent
operator|)
name|targetObject
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|idParts
init|=
name|target
operator|.
name|getObjectId
argument_list|()
operator|.
name|getIdSnapshot
argument_list|()
decl_stmt|;
comment|// this may happen in uncommitted objects - see the warning in
comment|// the JavaDoc
comment|// of
comment|// this method.
if|if
condition|(
name|idParts
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|DbRelationship
name|dbRel
init|=
name|rel
operator|.
name|getDbRelationships
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|fk
init|=
name|dbRel
operator|.
name|srcFkSnapshotWithTargetSnapshot
argument_list|(
name|idParts
argument_list|)
decl_stmt|;
name|snapshot
operator|.
name|putAll
argument_list|(
name|fk
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// process object id map
comment|// we should ignore any object id values if a corresponding attribute
comment|// is a part of relationship "toMasterPK", since those values have been
comment|// set above when db relationships where processed.
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|thisIdParts
init|=
name|object
operator|.
name|getObjectId
argument_list|()
operator|.
name|getIdSnapshot
argument_list|()
decl_stmt|;
if|if
condition|(
name|thisIdParts
operator|!=
literal|null
condition|)
block|{
comment|// put only those that do not exist in the map
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|thisIdParts
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|nextKey
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|snapshot
operator|.
name|containsKey
argument_list|(
name|nextKey
argument_list|)
condition|)
block|{
name|snapshot
operator|.
name|put
argument_list|(
name|nextKey
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|snapshot
return|;
block|}
comment|/**      * Converts a list of DataRows to a List of DataObject registered with this      * DataContext.      *       * @since 3.0      */
specifier|public
name|List
name|objectsFromDataRows
parameter_list|(
name|ClassDescriptor
name|descriptor
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|DataRow
argument_list|>
name|dataRows
parameter_list|)
block|{
comment|// TODO: If data row cache is not available it means that current data
comment|// context is
comment|// child. We need to redirect this method call to parent data context as
comment|// an
comment|// internal query. It is not obvious and has some overhead. Redesign for
comment|// nested
comment|// contexts should be done.
if|if
condition|(
name|getObjectStore
argument_list|()
operator|.
name|getDataRowCache
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
name|objectsFromDataRowsFromParentContext
argument_list|(
name|descriptor
argument_list|,
name|dataRows
argument_list|)
return|;
block|}
return|return
operator|new
name|ObjectResolver
argument_list|(
name|this
argument_list|,
name|descriptor
argument_list|,
literal|true
argument_list|)
operator|.
name|synchronizedObjectsFromDataRows
argument_list|(
name|dataRows
argument_list|)
return|;
block|}
specifier|private
name|List
name|objectsFromDataRowsFromParentContext
parameter_list|(
name|ClassDescriptor
name|descriptor
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|DataRow
argument_list|>
name|dataRows
parameter_list|)
block|{
return|return
name|getChannel
argument_list|()
operator|.
name|onQuery
argument_list|(
name|this
argument_list|,
operator|new
name|ObjectsFromDataRowsQuery
argument_list|(
name|descriptor
argument_list|,
name|dataRows
argument_list|)
argument_list|)
operator|.
name|firstList
argument_list|()
return|;
block|}
comment|/**      * Creates a DataObject from DataRow.      *       * @see DataRow      * @since 3.1      */
specifier|public
parameter_list|<
name|T
extends|extends
name|Persistent
parameter_list|>
name|T
name|objectFromDataRow
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|objectClass
parameter_list|,
name|DataRow
name|dataRow
parameter_list|)
block|{
name|ObjEntity
name|entity
init|=
name|this
operator|.
name|getEntityResolver
argument_list|()
operator|.
name|getObjEntity
argument_list|(
name|objectClass
argument_list|)
decl_stmt|;
if|if
condition|(
name|entity
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Unmapped Java class: "
operator|+
name|objectClass
argument_list|)
throw|;
block|}
name|ClassDescriptor
name|descriptor
init|=
name|getEntityResolver
argument_list|()
operator|.
name|getClassDescriptor
argument_list|(
name|entity
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
name|objectsFromDataRows
argument_list|(
name|descriptor
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|dataRow
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**      * Creates a DataObject from DataRow. This variety of the      * 'objectFromDataRow' method is normally used for generic classes.      *       * @see DataRow      * @since 3.1      */
specifier|public
name|DataObject
name|objectFromDataRow
parameter_list|(
name|String
name|entityName
parameter_list|,
name|DataRow
name|dataRow
parameter_list|)
block|{
name|ClassDescriptor
name|descriptor
init|=
name|getEntityResolver
argument_list|()
operator|.
name|getClassDescriptor
argument_list|(
name|entityName
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|?
argument_list|>
name|list
init|=
name|objectsFromDataRows
argument_list|(
name|descriptor
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|dataRow
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
name|DataObject
operator|)
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**      * Creates and registers a new persistent object.      *       * @since 1.2      */
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|newObject
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|persistentClass
parameter_list|)
block|{
if|if
condition|(
name|persistentClass
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Null 'persistentClass'"
argument_list|)
throw|;
block|}
name|ObjEntity
name|entity
init|=
name|getEntityResolver
argument_list|()
operator|.
name|getObjEntity
argument_list|(
name|persistentClass
argument_list|)
decl_stmt|;
if|if
condition|(
name|entity
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Class is not mapped with Cayenne: "
operator|+
name|persistentClass
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
return|return
operator|(
name|T
operator|)
name|newObject
argument_list|(
name|entity
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Instantiates a new object and registers it with this context. Object      * class is determined from the mapped entity. Object class must have a      * default constructor.      *<p/>      *<i>Note: in most cases {@link #newObject(Class)} method should be used,      * however this method is helpful when generic persistent classes are      * used.</i>      *       * @since 3.0      */
specifier|public
name|Persistent
name|newObject
parameter_list|(
name|String
name|entityName
parameter_list|)
block|{
name|ClassDescriptor
name|descriptor
init|=
name|getEntityResolver
argument_list|()
operator|.
name|getClassDescriptor
argument_list|(
name|entityName
argument_list|)
decl_stmt|;
if|if
condition|(
name|descriptor
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid entity name: "
operator|+
name|entityName
argument_list|)
throw|;
block|}
name|Persistent
name|object
decl_stmt|;
try|try
block|{
name|object
operator|=
operator|(
name|Persistent
operator|)
name|descriptor
operator|.
name|createObject
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Error instantiating object."
argument_list|,
name|ex
argument_list|)
throw|;
block|}
comment|// this will initialize to-many lists
name|descriptor
operator|.
name|injectValueHolders
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|ObjectId
name|id
init|=
operator|new
name|ObjectId
argument_list|(
name|entityName
argument_list|)
decl_stmt|;
comment|// note that the order of initialization of persistence artifacts below
comment|// is
comment|// important - do not change it lightly
name|object
operator|.
name|setObjectId
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|injectInitialValue
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
name|object
return|;
block|}
comment|/**      * Registers a transient object with the context, recursively registering      * all transient persistent objects attached to this object via      * relationships.      *<p/>      *<i>Note that since 3.0 this method takes Object as an argument instead of      * a {@link DataObject}.</i>      *       * @param object      *            new object that needs to be made persistent.      */
annotation|@
name|Override
specifier|public
name|void
name|registerNewObject
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|object
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Can't register null object."
argument_list|)
throw|;
block|}
name|ObjEntity
name|entity
init|=
name|getEntityResolver
argument_list|()
operator|.
name|getObjEntity
argument_list|(
operator|(
name|Persistent
operator|)
name|object
argument_list|)
decl_stmt|;
if|if
condition|(
name|entity
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Can't find ObjEntity for Persistent class: "
operator|+
name|object
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|", class is likely not mapped."
argument_list|)
throw|;
block|}
specifier|final
name|Persistent
name|persistent
init|=
operator|(
name|Persistent
operator|)
name|object
decl_stmt|;
comment|// sanity check - maybe already registered
if|if
condition|(
name|persistent
operator|.
name|getObjectId
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|persistent
operator|.
name|getObjectContext
argument_list|()
operator|==
name|this
condition|)
block|{
comment|// already registered, just ignore
return|return;
block|}
if|else if
condition|(
name|persistent
operator|.
name|getObjectContext
argument_list|()
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Persistent is already registered with another DataContext. "
operator|+
literal|"Try using 'localObjects()' instead."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|persistent
operator|.
name|setObjectId
argument_list|(
operator|new
name|ObjectId
argument_list|(
name|entity
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ClassDescriptor
name|descriptor
init|=
name|getEntityResolver
argument_list|()
operator|.
name|getClassDescriptor
argument_list|(
name|entity
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|descriptor
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid entity name: "
operator|+
name|entity
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
name|injectInitialValue
argument_list|(
name|object
argument_list|)
expr_stmt|;
comment|// now we need to find all arc changes, inject missing value holders and
comment|// pull in
comment|// all transient connected objects
name|descriptor
operator|.
name|visitProperties
argument_list|(
operator|new
name|PropertyVisitor
argument_list|()
block|{
specifier|public
name|boolean
name|visitToMany
parameter_list|(
name|ToManyProperty
name|property
parameter_list|)
block|{
name|property
operator|.
name|injectValueHolder
argument_list|(
name|persistent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|property
operator|.
name|isFault
argument_list|(
name|persistent
argument_list|)
condition|)
block|{
name|Object
name|value
init|=
name|property
operator|.
name|readProperty
argument_list|(
name|persistent
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|Map
operator|.
name|Entry
argument_list|>
name|collection
init|=
operator|(
name|value
operator|instanceof
name|Map
operator|)
condition|?
operator|(
operator|(
name|Map
operator|)
name|value
operator|)
operator|.
name|entrySet
argument_list|()
else|:
operator|(
name|Collection
operator|)
name|value
decl_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|>
name|it
init|=
name|collection
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Object
name|target
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|target
operator|instanceof
name|Persistent
condition|)
block|{
name|Persistent
name|targetDO
init|=
operator|(
name|Persistent
operator|)
name|target
decl_stmt|;
comment|// make sure it is registered
name|registerNewObject
argument_list|(
name|targetDO
argument_list|)
expr_stmt|;
name|getObjectStore
argument_list|()
operator|.
name|arcCreated
argument_list|(
name|persistent
operator|.
name|getObjectId
argument_list|()
argument_list|,
name|targetDO
operator|.
name|getObjectId
argument_list|()
argument_list|,
name|property
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|visitToOne
parameter_list|(
name|ToOneProperty
name|property
parameter_list|)
block|{
name|Object
name|target
init|=
name|property
operator|.
name|readPropertyDirectly
argument_list|(
name|persistent
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|instanceof
name|Persistent
condition|)
block|{
name|Persistent
name|targetDO
init|=
operator|(
name|Persistent
operator|)
name|target
decl_stmt|;
comment|// make sure it is registered
name|registerNewObject
argument_list|(
name|targetDO
argument_list|)
expr_stmt|;
name|getObjectStore
argument_list|()
operator|.
name|arcCreated
argument_list|(
name|persistent
operator|.
name|getObjectId
argument_list|()
argument_list|,
name|targetDO
operator|.
name|getObjectId
argument_list|()
argument_list|,
name|property
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|visitAttribute
parameter_list|(
name|AttributeProperty
name|property
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**      * Unregisters a Collection of DataObjects from the DataContext and the      * underlying ObjectStore. This operation also unsets DataContext and      * ObjectId for each object and changes its state to TRANSIENT.      *       * @see #invalidateObjects(Collection)      */
specifier|public
name|void
name|unregisterObjects
parameter_list|(
name|Collection
name|dataObjects
parameter_list|)
block|{
name|getObjectStore
argument_list|()
operator|.
name|objectsUnregistered
argument_list|(
name|dataObjects
argument_list|)
expr_stmt|;
block|}
comment|/**      * If the parent channel is a DataContext, reverts local changes to make      * this context look like the parent, if the parent channel is a DataDomain,      * reverts all changes.      *       * @since 1.2      */
annotation|@
name|Override
specifier|public
name|void
name|rollbackChangesLocally
parameter_list|()
block|{
if|if
condition|(
name|objectStore
operator|.
name|hasChanges
argument_list|()
condition|)
block|{
name|GraphDiff
name|diff
init|=
name|getObjectStore
argument_list|()
operator|.
name|getChanges
argument_list|()
decl_stmt|;
name|getObjectStore
argument_list|()
operator|.
name|objectsRolledBack
argument_list|()
expr_stmt|;
name|fireDataChannelRolledback
argument_list|(
name|this
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Reverts any changes that have occurred to objects registered with      * DataContext; also performs cascading rollback of all parent DataContexts.      */
annotation|@
name|Override
specifier|public
name|void
name|rollbackChanges
parameter_list|()
block|{
if|if
condition|(
name|objectStore
operator|.
name|hasChanges
argument_list|()
condition|)
block|{
name|GraphDiff
name|diff
init|=
name|getObjectStore
argument_list|()
operator|.
name|getChanges
argument_list|()
decl_stmt|;
comment|// call channel with changes BEFORE reverting them, so that any
comment|// interceptors
comment|// could record them
if|if
condition|(
name|channel
operator|!=
literal|null
condition|)
block|{
name|channel
operator|.
name|onSync
argument_list|(
name|this
argument_list|,
name|diff
argument_list|,
name|DataChannel
operator|.
name|ROLLBACK_CASCADE_SYNC
argument_list|)
expr_stmt|;
block|}
name|getObjectStore
argument_list|()
operator|.
name|objectsRolledBack
argument_list|()
expr_stmt|;
name|fireDataChannelRolledback
argument_list|(
name|this
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|channel
operator|!=
literal|null
condition|)
block|{
name|channel
operator|.
name|onSync
argument_list|(
name|this
argument_list|,
operator|new
name|CompoundDiff
argument_list|()
argument_list|,
name|DataChannel
operator|.
name|ROLLBACK_CASCADE_SYNC
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * "Flushes" the changes to the parent {@link DataChannel}. If the parent      * channel is a DataContext, it updates its objects with this context's      * changes, without a database update. If it is a DataDomain (the most      * common case), the changes are written to the database. To cause cascading      * commit all the way to the database, one must use {@link #commitChanges()}      * .      *       * @since 1.2      * @see #commitChanges()      */
annotation|@
name|Override
specifier|public
name|void
name|commitChangesToParent
parameter_list|()
block|{
name|flushToParent
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Synchronizes object graph with the database. Executes needed insert,      * update and delete queries (generated internally).      */
annotation|@
name|Override
specifier|public
name|void
name|commitChanges
parameter_list|()
throws|throws
name|CayenneRuntimeException
block|{
name|flushToParent
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|GraphDiff
name|onContextFlush
parameter_list|(
name|ObjectContext
name|originatingContext
parameter_list|,
name|GraphDiff
name|changes
parameter_list|,
name|boolean
name|cascade
parameter_list|)
block|{
name|boolean
name|childContext
init|=
name|this
operator|!=
name|originatingContext
operator|&&
name|changes
operator|!=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|childContext
condition|)
block|{
name|getObjectStore
argument_list|()
operator|.
name|childContextSyncStarted
argument_list|()
expr_stmt|;
name|changes
operator|.
name|apply
argument_list|(
operator|new
name|ChildDiffLoader
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|fireDataChannelChanged
argument_list|(
name|originatingContext
argument_list|,
name|changes
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cascade
operator|)
condition|?
name|flushToParent
argument_list|(
literal|true
argument_list|)
else|:
operator|new
name|CompoundDiff
argument_list|()
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|childContext
condition|)
block|{
name|getObjectStore
argument_list|()
operator|.
name|childContextSyncStopped
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Synchronizes with the parent channel, performing a flush or a commit.      *       * @since 1.2      */
name|GraphDiff
name|flushToParent
parameter_list|(
name|boolean
name|cascade
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|getChannel
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Cannot commit changes - channel is not set."
argument_list|)
throw|;
block|}
name|int
name|syncType
init|=
name|cascade
condition|?
name|DataChannel
operator|.
name|FLUSH_CASCADE_SYNC
else|:
name|DataChannel
operator|.
name|FLUSH_NOCASCADE_SYNC
decl_stmt|;
name|ObjectStore
name|objectStore
init|=
name|getObjectStore
argument_list|()
decl_stmt|;
name|GraphDiff
name|parentChanges
init|=
literal|null
decl_stmt|;
comment|// prevent multiple commits occurring simultaneously
synchronized|synchronized
init|(
name|objectStore
init|)
block|{
name|ObjectStoreGraphDiff
name|changes
init|=
name|objectStore
operator|.
name|getChanges
argument_list|()
decl_stmt|;
name|boolean
name|noop
init|=
name|isValidatingObjectsOnCommit
argument_list|()
condition|?
name|changes
operator|.
name|validateAndCheckNoop
argument_list|()
else|:
name|changes
operator|.
name|isNoop
argument_list|()
decl_stmt|;
if|if
condition|(
name|noop
condition|)
block|{
comment|// need to clear phantom changes
name|objectStore
operator|.
name|postprocessAfterPhantomCommit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|parentChanges
operator|=
name|getChannel
argument_list|()
operator|.
name|onSync
argument_list|(
name|this
argument_list|,
name|changes
argument_list|,
name|syncType
argument_list|)
expr_stmt|;
comment|// note that this is a hack resulting from a fix to
comment|// CAY-766... To
comment|// support
comment|// valid object state in PostPersist callback,
comment|// 'postprocessAfterCommit' is
comment|// invoked by DataDomain.onSync(..). Unless the parent is
comment|// DataContext,
comment|// and
comment|// this method is not invoked!! As a result, PostPersist
comment|// will contain
comment|// temp
comment|// ObjectIds in nested contexts and perm ones in flat
comment|// contexts.
comment|// Pending better callback design .....
if|if
condition|(
name|objectStore
operator|.
name|hasChanges
argument_list|()
condition|)
block|{
name|objectStore
operator|.
name|postprocessAfterCommit
argument_list|(
name|parentChanges
argument_list|)
expr_stmt|;
block|}
comment|// this event is caught by peer nested DataContexts to
comment|// synchronize the
comment|// state
name|fireDataChannelCommitted
argument_list|(
name|this
argument_list|,
name|changes
argument_list|)
expr_stmt|;
block|}
comment|// "catch" is needed to unwrap OptimisticLockExceptions
catch|catch
parameter_list|(
name|CayenneRuntimeException
name|ex
parameter_list|)
block|{
name|Throwable
name|unwound
init|=
name|Util
operator|.
name|unwindException
argument_list|(
name|ex
argument_list|)
decl_stmt|;
if|if
condition|(
name|unwound
operator|instanceof
name|CayenneRuntimeException
condition|)
block|{
throw|throw
operator|(
name|CayenneRuntimeException
operator|)
name|unwound
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Commit Exception"
argument_list|,
name|unwound
argument_list|)
throw|;
block|}
block|}
block|}
comment|// merge changes from parent as well as changes caused by lifecycle
comment|// event
comment|// callbacks/listeners...
name|CompoundDiff
name|diff
init|=
operator|new
name|CompoundDiff
argument_list|()
decl_stmt|;
name|diff
operator|.
name|addAll
argument_list|(
name|objectStore
operator|.
name|getLifecycleEventInducedChanges
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|parentChanges
operator|!=
literal|null
condition|)
block|{
name|diff
operator|.
name|add
argument_list|(
name|parentChanges
argument_list|)
expr_stmt|;
block|}
comment|// this event is caught by child DataContexts to update temporary
comment|// ObjectIds with permanent
if|if
condition|(
operator|!
name|diff
operator|.
name|isNoop
argument_list|()
condition|)
block|{
name|fireDataChannelCommitted
argument_list|(
name|getChannel
argument_list|()
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
return|return
name|diff
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|ResultIterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|(
name|Select
argument_list|<
name|T
argument_list|>
name|query
parameter_list|)
block|{
specifier|final
name|ResultIterator
argument_list|<
name|DataRow
argument_list|>
name|rows
init|=
name|performIteratedQuery
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|QueryMetadata
name|md
init|=
name|query
operator|.
name|getMetaData
argument_list|(
name|getEntityResolver
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|md
operator|.
name|isFetchingDataRows
argument_list|()
condition|)
block|{
return|return
operator|(
name|ResultIterator
argument_list|<
name|T
argument_list|>
operator|)
name|rows
return|;
block|}
else|else
block|{
comment|// this is a bit optimized version of 'objectFromDataRow' with
comment|// resolver cached for reuse... still the rest is pretty suboptimal
name|ClassDescriptor
name|descriptor
init|=
name|md
operator|.
name|getClassDescriptor
argument_list|()
decl_stmt|;
specifier|final
name|ObjectResolver
name|resolver
init|=
operator|new
name|ObjectResolver
argument_list|(
name|this
argument_list|,
name|descriptor
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
operator|new
name|ResultIterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|ResultIteratorIterator
argument_list|<
name|T
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
specifier|public
name|List
argument_list|<
name|T
argument_list|>
name|allRows
parameter_list|()
block|{
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|hasNextRow
argument_list|()
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|nextRow
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
specifier|public
name|boolean
name|hasNextRow
parameter_list|()
block|{
return|return
name|rows
operator|.
name|hasNextRow
argument_list|()
return|;
block|}
specifier|public
name|T
name|nextRow
parameter_list|()
block|{
name|DataRow
name|row
init|=
name|rows
operator|.
name|nextRow
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|T
argument_list|>
name|objects
init|=
operator|(
name|List
argument_list|<
name|T
argument_list|>
operator|)
name|resolver
operator|.
name|synchronizedObjectsFromDataRows
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|row
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
name|T
operator|)
name|objects
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
specifier|public
name|void
name|skipRow
parameter_list|()
block|{
name|rows
operator|.
name|skipRow
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
name|rows
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
comment|/**      * Performs a single database select query returning result as a      * ResultIterator. It is caller's responsibility to explicitly close the      * ResultIterator. A failure to do so will result in a database connection      * not being released. Another side effect of an open ResultIterator is that      * an internal Cayenne transaction that originated in this method stays open      * until the iterator is closed. So users should normally close the iterator      * within the same thread that opened it.      *<p>      * Note that 'performIteratedQuery' always returns ResultIterator over      * DataRows. Use      * {@link #iterate(Select, org.apache.cayenne.ResultIteratorCallback)} to      * get access to objects.      */
comment|// TODO: deprecate once all selecting queries start implementing Select<T>
comment|// interface
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|}
argument_list|)
specifier|public
name|ResultIterator
name|performIteratedQuery
parameter_list|(
name|Query
name|query
parameter_list|)
block|{
comment|// TODO: use 3.2 TransactionManager
if|if
condition|(
name|Transaction
operator|.
name|getThreadTransaction
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|internalPerformIteratedQuery
argument_list|(
name|query
argument_list|)
return|;
block|}
else|else
block|{
comment|// manually manage a transaction, so that a ResultIterator wrapper
comment|// could close
comment|// it when it is done.
name|Transaction
name|tx
init|=
name|getParentDataDomain
argument_list|()
operator|.
name|createTransaction
argument_list|()
decl_stmt|;
name|Transaction
operator|.
name|bindThreadTransaction
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ResultIterator
name|result
decl_stmt|;
try|try
block|{
name|result
operator|=
name|internalPerformIteratedQuery
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|Transaction
operator|.
name|bindThreadTransaction
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|tx
operator|.
name|setRollbackOnly
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
comment|// note: we are keeping the transaction bound to the current
comment|// thread on
comment|// success - iterator will unbind it. Unsetting a transaction
comment|// here would
comment|// result in some strangeness, at least on Ingres
if|if
condition|(
name|tx
operator|.
name|getStatus
argument_list|()
operator|==
name|Transaction
operator|.
name|STATUS_MARKED_ROLLEDBACK
condition|)
block|{
try|try
block|{
name|tx
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|rollbackEx
parameter_list|)
block|{
block|}
block|}
block|}
return|return
operator|new
name|TransactionResultIteratorDecorator
argument_list|(
name|result
argument_list|,
name|tx
argument_list|)
return|;
block|}
block|}
comment|/**      * Runs an iterated query in a transactional context provided by the caller.      */
name|ResultIterator
name|internalPerformIteratedQuery
parameter_list|(
name|Query
name|query
parameter_list|)
block|{
comment|// note that for now DataChannel API does not support cursors (aka
comment|// ResultIterator), so we have to go directly to the DataDomain.
name|IteratedSelectObserver
name|observer
init|=
operator|new
name|IteratedSelectObserver
argument_list|()
decl_stmt|;
name|getParentDataDomain
argument_list|()
operator|.
name|performQueries
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|query
argument_list|)
argument_list|,
name|observer
argument_list|)
expr_stmt|;
return|return
name|observer
operator|.
name|getResultIterator
argument_list|()
return|;
block|}
comment|/**      * Executes a query returning a generic response.      *       * @since 1.2      */
annotation|@
name|Override
specifier|public
name|QueryResponse
name|performGenericQuery
parameter_list|(
name|Query
name|query
parameter_list|)
block|{
name|query
operator|=
name|nonNullDelegate
argument_list|()
operator|.
name|willPerformGenericQuery
argument_list|(
name|this
argument_list|,
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|GenericResponse
argument_list|()
return|;
block|}
if|if
condition|(
name|this
operator|.
name|getChannel
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Can't run query - parent DataChannel is not set."
argument_list|)
throw|;
block|}
return|return
name|onQuery
argument_list|(
name|this
argument_list|,
name|query
argument_list|)
return|;
block|}
comment|/**      * Performs a single selecting query. Various query setting control the      * behavior of this method and the results returned:      *<ul>      *<li>Query caching policy defines whether the results are retrieved from      * cache or fetched from the database. Note that queries that use caching      * must have a name that is used as a caching key.</li>      *<li>Query refreshing policy controls whether to refresh existing data      * objects and ignore any cached values.</li>      *<li>Query data rows policy defines whether the result should be returned      * as DataObjects or DataRows.</li>      *</ul>      *<p>      *<i>Since 1.2 takes any Query parameter, not just GenericSelectQuery</i>      *</p>      *       * @return A list of DataObjects or a DataRows, depending on the value      *         returned by {@link QueryMetadata#isFetchingDataRows()}.      */
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|List
name|performQuery
parameter_list|(
name|Query
name|query
parameter_list|)
block|{
name|query
operator|=
name|nonNullDelegate
argument_list|()
operator|.
name|willPerformQuery
argument_list|(
name|this
argument_list|,
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|List
name|result
init|=
name|onQuery
argument_list|(
name|this
argument_list|,
name|query
argument_list|)
operator|.
name|firstList
argument_list|()
decl_stmt|;
return|return
name|result
operator|!=
literal|null
condition|?
name|result
else|:
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|(
literal|1
argument_list|)
return|;
block|}
comment|/**      * An implementation of a {@link DataChannel} method that is used by child      * contexts to execute queries. Not intended for direct use.      *       * @since 1.2      */
specifier|public
name|QueryResponse
name|onQuery
parameter_list|(
name|ObjectContext
name|context
parameter_list|,
name|Query
name|query
parameter_list|)
block|{
return|return
operator|new
name|DataContextQueryAction
argument_list|(
name|this
argument_list|,
name|context
argument_list|,
name|query
argument_list|)
operator|.
name|execute
argument_list|()
return|;
block|}
comment|/**      * Performs a single database query that does not select rows. Returns an      * array of update counts.      *       * @since 1.1      */
specifier|public
name|int
index|[]
name|performNonSelectingQuery
parameter_list|(
name|Query
name|query
parameter_list|)
block|{
name|int
index|[]
name|count
init|=
name|performGenericQuery
argument_list|(
name|query
argument_list|)
operator|.
name|firstUpdateCount
argument_list|()
decl_stmt|;
return|return
name|count
operator|!=
literal|null
condition|?
name|count
else|:
operator|new
name|int
index|[
literal|0
index|]
return|;
block|}
comment|/**      * Performs a named mapped query that does not select rows. Returns an array      * of update counts.      *       * @since 1.1      */
specifier|public
name|int
index|[]
name|performNonSelectingQuery
parameter_list|(
name|String
name|queryName
parameter_list|)
block|{
return|return
name|performNonSelectingQuery
argument_list|(
operator|new
name|NamedQuery
argument_list|(
name|queryName
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Performs a named mapped non-selecting query using a map of parameters.      * Returns an array of update counts.      *       * @since 1.1      */
specifier|public
name|int
index|[]
name|performNonSelectingQuery
parameter_list|(
name|String
name|queryName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|parameters
parameter_list|)
block|{
return|return
name|performNonSelectingQuery
argument_list|(
operator|new
name|NamedQuery
argument_list|(
name|queryName
argument_list|,
name|parameters
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Returns a list of objects or DataRows for a named query stored in one of      * the DataMaps. Internally Cayenne uses a caching policy defined in the      * named query. If refresh flag is true, a refresh is forced no matter what      * the caching policy is.      *       * @param queryName      *            a name of a GenericSelectQuery defined in one of the DataMaps.      *            If no such query is defined, this method will throw a      *            CayenneRuntimeException.      * @param expireCachedLists      *            A flag that determines whether refresh of<b>cached lists</b>      *            is required in case a query uses caching.      * @since 1.1      */
specifier|public
name|List
argument_list|<
name|?
argument_list|>
name|performQuery
parameter_list|(
name|String
name|queryName
parameter_list|,
name|boolean
name|expireCachedLists
parameter_list|)
block|{
return|return
name|performQuery
argument_list|(
name|queryName
argument_list|,
name|Collections
operator|.
name|EMPTY_MAP
argument_list|,
name|expireCachedLists
argument_list|)
return|;
block|}
comment|/**      * Returns a list of objects or DataRows for a named query stored in one of      * the DataMaps. Internally Cayenne uses a caching policy defined in the      * named query. If refresh flag is true, a refresh is forced no matter what      * the caching policy is.      *       * @param queryName      *            a name of a GenericSelectQuery defined in one of the DataMaps.      *            If no such query is defined, this method will throw a      *            CayenneRuntimeException.      * @param parameters      *            A map of parameters to use with stored query.      * @param expireCachedLists      *            A flag that determines whether refresh of<b>cached lists</b>      *            is required in case a query uses caching.      * @since 1.1      */
specifier|public
name|List
argument_list|<
name|?
argument_list|>
name|performQuery
parameter_list|(
name|String
name|queryName
parameter_list|,
name|Map
name|parameters
parameter_list|,
name|boolean
name|expireCachedLists
parameter_list|)
block|{
name|NamedQuery
name|query
init|=
operator|new
name|NamedQuery
argument_list|(
name|queryName
argument_list|,
name|parameters
argument_list|)
decl_stmt|;
name|query
operator|.
name|setForceNoCache
argument_list|(
name|expireCachedLists
argument_list|)
expr_stmt|;
return|return
name|performQuery
argument_list|(
name|query
argument_list|)
return|;
block|}
comment|/**      * Returns<code>true</code> if the ObjectStore uses shared cache of a      * parent DataDomain.      *       * @since 1.1      */
specifier|public
name|boolean
name|isUsingSharedSnapshotCache
parameter_list|()
block|{
return|return
name|usingSharedSnaphsotCache
return|;
block|}
comment|/**      * @since 3.1      */
specifier|public
name|void
name|setUsingSharedSnapshotCache
parameter_list|(
name|boolean
name|flag
parameter_list|)
block|{
name|this
operator|.
name|usingSharedSnaphsotCache
operator|=
name|flag
expr_stmt|;
block|}
comment|// ---------------------------------------------
comment|// Serialization Support
comment|// ---------------------------------------------
specifier|private
name|void
name|writeObject
parameter_list|(
name|ObjectOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
comment|// Serialize local snapshots cache
if|if
condition|(
operator|!
name|isUsingSharedSnapshotCache
argument_list|()
condition|)
block|{
name|out
operator|.
name|writeObject
argument_list|(
name|objectStore
operator|.
name|getDataRowCache
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// serialization support
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
comment|// TODO: most of this should be in the superclass, especially the code
comment|// connecting
comment|// super transient ivars
comment|// read non-transient properties
name|in
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
comment|// deserialize local snapshots cache
if|if
condition|(
operator|!
name|isUsingSharedSnapshotCache
argument_list|()
condition|)
block|{
name|DataRowStore
name|cache
init|=
operator|(
name|DataRowStore
operator|)
name|in
operator|.
name|readObject
argument_list|()
decl_stmt|;
name|objectStore
operator|.
name|setDataRowCache
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
comment|// CayenneDataObjects have a transient DataContext
comment|// because at deserialize time the datacontext may need to be different
comment|// than the one at serialize time (for programmer defined reasons).
comment|// So, when a DataObject is resurrected because it's DataContext was
comment|// serialized, it will then set the objects DataContext to the correct
comment|// one
comment|// If deserialized "otherwise", it will not have a DataContext.
synchronized|synchronized
init|(
name|getObjectStore
argument_list|()
init|)
block|{
name|Iterator
argument_list|<
name|?
argument_list|>
name|it
init|=
name|objectStore
operator|.
name|getObjectIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Persistent
name|object
init|=
operator|(
name|Persistent
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|object
operator|.
name|setObjectContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ... deferring initialization of transient properties of this context
comment|// till first
comment|// access, so that it can attach to Cayenne runtime using appropriate
comment|// thread
comment|// injector.
block|}
comment|/**      * Returns this context's ObjectStore.      *       * @since 1.2      */
annotation|@
name|Override
specifier|public
name|GraphManager
name|getGraphManager
parameter_list|()
block|{
return|return
name|objectStore
return|;
block|}
comment|/**      * An internal version of {@link #localObject(Object)} that operates on      * ObjectId instead of Persistent, and wouldn't attempt to look up an object      * in the parent channel.      *       * @since 3.1      */
name|Persistent
name|findOrCreateObject
parameter_list|(
name|ObjectId
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Null ObjectId"
argument_list|)
throw|;
block|}
comment|// have to synchronize almost the entire method to prevent multiple
comment|// threads from
comment|// messing up dataobjects per CAY-845. Originally only parts of "else"
comment|// were
comment|// synchronized, but we had to expand the lock scope to ensure
comment|// consistent
comment|// behavior.
synchronized|synchronized
init|(
name|getGraphManager
argument_list|()
init|)
block|{
name|Persistent
name|cachedObject
init|=
operator|(
name|Persistent
operator|)
name|getGraphManager
argument_list|()
operator|.
name|getNode
argument_list|(
name|id
argument_list|)
decl_stmt|;
comment|// return an existing object
if|if
condition|(
name|cachedObject
operator|!=
literal|null
condition|)
block|{
name|int
name|state
init|=
name|cachedObject
operator|.
name|getPersistenceState
argument_list|()
decl_stmt|;
comment|// TODO: Andrus, 1/24/2006 implement smart merge for modified
comment|// objects...
if|if
condition|(
name|state
operator|!=
name|PersistenceState
operator|.
name|MODIFIED
operator|&&
name|state
operator|!=
name|PersistenceState
operator|.
name|DELETED
condition|)
block|{
name|ClassDescriptor
name|descriptor
init|=
name|getEntityResolver
argument_list|()
operator|.
name|getClassDescriptor
argument_list|(
name|id
operator|.
name|getEntityName
argument_list|()
argument_list|)
decl_stmt|;
name|descriptor
operator|.
name|injectValueHolders
argument_list|(
name|cachedObject
argument_list|)
expr_stmt|;
block|}
return|return
name|cachedObject
return|;
block|}
comment|// create and register a hollow object
name|ClassDescriptor
name|descriptor
init|=
name|getEntityResolver
argument_list|()
operator|.
name|getClassDescriptor
argument_list|(
name|id
operator|.
name|getEntityName
argument_list|()
argument_list|)
decl_stmt|;
name|Persistent
name|localObject
init|=
operator|(
name|Persistent
operator|)
name|descriptor
operator|.
name|createObject
argument_list|()
decl_stmt|;
name|localObject
operator|.
name|setObjectContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|localObject
operator|.
name|setObjectId
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|getGraphManager
argument_list|()
operator|.
name|registerNode
argument_list|(
name|id
argument_list|,
name|localObject
argument_list|)
expr_stmt|;
name|localObject
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|HOLLOW
argument_list|)
expr_stmt|;
return|return
name|localObject
return|;
block|}
block|}
comment|// this completely meaningless override is needed to expose the method as
comment|// package-private ... is there a better way?
annotation|@
name|Override
specifier|protected
name|void
name|fireDataChannelChanged
parameter_list|(
name|Object
name|postedBy
parameter_list|,
name|GraphDiff
name|changes
parameter_list|)
block|{
name|super
operator|.
name|fireDataChannelChanged
argument_list|(
name|postedBy
argument_list|,
name|changes
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

