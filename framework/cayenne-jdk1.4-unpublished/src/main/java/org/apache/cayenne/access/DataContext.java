begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************  *   Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing,  *  software distributed under the License is distributed on an  *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *  KIND, either express or implied.  See the License for the  *  specific language governing permissions and limitations  *  under the License.  ****************************************************************/
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|access
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|BaseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|CayenneException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|CayenneRuntimeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|DataChannel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|DataObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|DataObjectUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|DataRow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|DeleteDenyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|Fault
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|LifecycleListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|ObjectContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|ObjectId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|PersistenceState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|Persistent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|QueryResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|access
operator|.
name|util
operator|.
name|IteratedSelectObserver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|cache
operator|.
name|QueryCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|cache
operator|.
name|QueryCacheFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|event
operator|.
name|EventManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|CompoundDiff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|GraphDiff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|GraphEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|graph
operator|.
name|GraphManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|DbJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|DbRelationship
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|EntityResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|ObjAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|ObjEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|map
operator|.
name|ObjRelationship
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|query
operator|.
name|NamedQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|query
operator|.
name|ObjectIdQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|query
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|query
operator|.
name|QueryMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|query
operator|.
name|RefreshQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|AttributeProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|ClassDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|PropertyVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|ToManyProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|reflect
operator|.
name|ToOneProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|util
operator|.
name|EventUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|util
operator|.
name|GenericResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|cayenne
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_comment
comment|/**  * Class that provides applications with access to Cayenne persistence features. In most  * cases this is the only access class directly used in the application.  *<p>  * Most common DataContext use pattern is to create one DataContext per session. "Session"  * may be a an HttpSession in a web application, or any other similar concept in a  * multiuser application.  *</p>  *<p>  * DataObjects are registered with DataContext either implicitly when they are fetched via  * a query, or read via a relationship from another object, or explicitly via calling  * {@link #newObject(Class)}during new DataObject creation. DataContext tracks changes  * made to its DataObjects in memory, and flushes them to the database when  * {@link #commitChanges()}is called. Until DataContext is committed, changes made to its  * objects are not visible in other DataContexts.  *</p>  *<p>  * Each DataObject can belong only to a single DataContext. To create a replica of an  * object from a different DataContext in a local context, use  * {@link #localObject(ObjectId, Object)} method.  *</p>  *   * @author Andrus Adamchik  */
end_comment

begin_class
specifier|public
class|class
name|DataContext
extends|extends
name|BaseContext
implements|implements
name|DataChannel
block|{
comment|/**      * A holder of a DataContext bound to the current thread.      *       * @since 1.1      */
comment|// TODO: Andrus, 11/7/2005 - should we use InheritableThreadLocal instead?
specifier|protected
specifier|static
specifier|final
name|ThreadLocal
name|threadDataContext
init|=
operator|new
name|ThreadLocal
argument_list|()
decl_stmt|;
comment|// Set of DataContextDelegates to be notified.
specifier|private
name|DataContextDelegate
name|delegate
decl_stmt|;
specifier|protected
name|boolean
name|usingSharedSnaphsotCache
decl_stmt|;
specifier|protected
name|boolean
name|validatingObjectsOnCommit
decl_stmt|;
specifier|protected
name|ObjectStore
name|objectStore
decl_stmt|;
specifier|protected
name|QueryCache
name|queryCache
decl_stmt|;
comment|// note that entity resolver is initialized from the parent channel the first time it
comment|// is accessed, and later cached in the context
specifier|protected
specifier|transient
name|EntityResolver
name|entityResolver
decl_stmt|;
specifier|protected
specifier|transient
name|DataContextMergeHandler
name|mergeHandler
decl_stmt|;
name|DataContextGraphAction
name|graphAction
decl_stmt|;
comment|/**      * Stores user defined properties associated with this DataContext.      *       * @since 1.2      */
specifier|protected
name|Map
name|userProperties
decl_stmt|;
comment|/**      * Stores the name of parent DataDomain. Used to defer initialization of the parent      * QueryEngine after deserialization. This helps avoid an issue with certain servlet      * engines (e.g. Tomcat) where HttpSessions with DataContext's are deserialized at      * startup before Cayenne stack is fully initialized.      */
specifier|protected
specifier|transient
name|String
name|lazyInitParentDomainName
decl_stmt|;
comment|/**      * Returns the DataContext bound to the current thread.      *       * @since 1.1      * @return the DataContext associated with caller thread.      * @throws IllegalStateException if there is no DataContext bound to the current      *             thread.      * @see org.apache.cayenne.conf.WebApplicationContextFilter      */
specifier|public
specifier|static
name|DataContext
name|getThreadDataContext
parameter_list|()
throws|throws
name|IllegalStateException
block|{
name|DataContext
name|dc
init|=
operator|(
name|DataContext
operator|)
name|threadDataContext
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|dc
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Current thread has no bound DataContext."
argument_list|)
throw|;
block|}
return|return
name|dc
return|;
block|}
comment|/**      * Binds a DataContext to the current thread. DataContext can later be retrieved by      * users in the same thread by calling {@link DataContext#getThreadDataContext}.      * Using null parameter will unbind currently bound DataContext.      *       * @since 1.1      */
specifier|public
specifier|static
name|void
name|bindThreadDataContext
parameter_list|(
name|DataContext
name|context
parameter_list|)
block|{
name|threadDataContext
operator|.
name|set
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
comment|/**      * Factory method that creates and returns a new instance of DataContext based on      * default domain. If more than one domain exists in the current configuration,      * {@link DataContext#createDataContext(String)} must be used instead. ObjectStore      * associated with created DataContext will have a cache stack configured using parent      * domain settings.      */
specifier|public
specifier|static
name|DataContext
name|createDataContext
parameter_list|()
block|{
return|return
name|Configuration
operator|.
name|getSharedConfiguration
argument_list|()
operator|.
name|getDomain
argument_list|()
operator|.
name|createDataContext
argument_list|()
return|;
block|}
comment|/**      * Factory method that creates and returns a new instance of DataContext based on      * default domain. If more than one domain exists in the current configuration,      * {@link DataContext#createDataContext(String, boolean)} must be used instead.      * ObjectStore associated with newly created DataContext will have a cache stack      * configured according to the specified policy, overriding a parent domain setting.      *       * @since 1.1      */
specifier|public
specifier|static
name|DataContext
name|createDataContext
parameter_list|(
name|boolean
name|useSharedCache
parameter_list|)
block|{
return|return
name|Configuration
operator|.
name|getSharedConfiguration
argument_list|()
operator|.
name|getDomain
argument_list|()
operator|.
name|createDataContext
argument_list|(
name|useSharedCache
argument_list|)
return|;
block|}
comment|/**      * Factory method that creates and returns a new instance of DataContext using named      * domain as its parent. If there is no domain matching the name argument, an      * exception is thrown.      */
specifier|public
specifier|static
name|DataContext
name|createDataContext
parameter_list|(
name|String
name|domainName
parameter_list|)
block|{
name|DataDomain
name|domain
init|=
name|Configuration
operator|.
name|getSharedConfiguration
argument_list|()
operator|.
name|getDomain
argument_list|(
name|domainName
argument_list|)
decl_stmt|;
if|if
condition|(
name|domain
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Non-existent domain: "
operator|+
name|domainName
argument_list|)
throw|;
block|}
return|return
name|domain
operator|.
name|createDataContext
argument_list|()
return|;
block|}
comment|/**      * Creates and returns new DataContext that will use a named DataDomain as its parent.      * ObjectStore associated with newly created DataContext will have a cache stack      * configured according to the specified policy, overriding a parent domain setting.      *       * @since 1.1      */
specifier|public
specifier|static
name|DataContext
name|createDataContext
parameter_list|(
name|String
name|domainName
parameter_list|,
name|boolean
name|useSharedCache
parameter_list|)
block|{
name|DataDomain
name|domain
init|=
name|Configuration
operator|.
name|getSharedConfiguration
argument_list|()
operator|.
name|getDomain
argument_list|(
name|domainName
argument_list|)
decl_stmt|;
if|if
condition|(
name|domain
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Non-existent domain: "
operator|+
name|domainName
argument_list|)
throw|;
block|}
return|return
name|domain
operator|.
name|createDataContext
argument_list|(
name|useSharedCache
argument_list|)
return|;
block|}
comment|/**      * Creates a new DataContext that is not attached to the Cayenne stack.      */
specifier|public
name|DataContext
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new DataContext with parent DataChannel and ObjectStore.      *       * @since 1.2      */
specifier|public
name|DataContext
parameter_list|(
name|DataChannel
name|channel
parameter_list|,
name|ObjectStore
name|objectStore
parameter_list|)
block|{
comment|// use a setter to properly initialize EntityResolver
name|setChannel
argument_list|(
name|channel
argument_list|)
expr_stmt|;
comment|// inject self as parent context
if|if
condition|(
name|objectStore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|objectStore
operator|=
name|objectStore
expr_stmt|;
name|objectStore
operator|.
name|setContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|DataDomain
name|domain
init|=
name|getParentDataDomain
argument_list|()
decl_stmt|;
name|this
operator|.
name|usingSharedSnaphsotCache
operator|=
name|domain
operator|!=
literal|null
operator|&&
name|objectStore
operator|.
name|getDataRowCache
argument_list|()
operator|==
name|domain
operator|.
name|getSharedSnapshotCache
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|graphAction
operator|=
operator|new
name|DataContextGraphAction
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns {@link QueryCache} used by this DataContext, creating it on the fly if      * needed. Uses parent DataDomain {@link QueryCacheFactory} to initialize the cache      * for the first time.      *       * @since 3.0      */
specifier|public
name|QueryCache
name|getQueryCache
parameter_list|()
block|{
if|if
condition|(
name|queryCache
operator|==
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|queryCache
operator|==
literal|null
condition|)
block|{
name|queryCache
operator|=
name|getParentDataDomain
argument_list|()
operator|.
name|getQueryCacheFactory
argument_list|()
operator|.
name|getQueryCache
argument_list|(
name|Collections
operator|.
name|EMPTY_MAP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|queryCache
return|;
block|}
comment|/**      * Sets a QueryCache to be used for storing cached query results.      *       * @since 3.0      */
specifier|public
name|void
name|setQueryCache
parameter_list|(
name|QueryCache
name|queryCache
parameter_list|)
block|{
name|this
operator|.
name|queryCache
operator|=
name|queryCache
expr_stmt|;
block|}
comment|/**      * Returns a map of user-defined properties associated with this DataContext.      *       * @since 1.2      */
specifier|protected
name|Map
name|getUserProperties
parameter_list|()
block|{
comment|// as not all users will take advantage of properties, creating the
comment|// map on demand to keep DataContext lean...
if|if
condition|(
name|userProperties
operator|==
literal|null
condition|)
block|{
name|userProperties
operator|=
operator|new
name|HashMap
argument_list|()
expr_stmt|;
block|}
return|return
name|userProperties
return|;
block|}
comment|/**      * Creates and returns a new child DataContext.      *       * @since 1.2      */
specifier|public
name|DataContext
name|createChildDataContext
parameter_list|()
block|{
name|DataContextFactory
name|factory
init|=
name|getParentDataDomain
argument_list|()
operator|.
name|getDataContextFactory
argument_list|()
decl_stmt|;
comment|// child ObjectStore should not have direct access to snapshot cache, so do not
comment|// pass it in constructor.
name|ObjectStore
name|objectStore
init|=
operator|new
name|ObjectStore
argument_list|()
decl_stmt|;
name|DataContext
name|child
init|=
name|factory
operator|!=
literal|null
condition|?
name|factory
operator|.
name|createDataContext
argument_list|(
name|this
argument_list|,
name|objectStore
argument_list|)
else|:
operator|new
name|DataContext
argument_list|(
operator|(
name|DataChannel
operator|)
name|this
argument_list|,
name|objectStore
argument_list|)
decl_stmt|;
name|child
operator|.
name|setValidatingObjectsOnCommit
argument_list|(
name|isValidatingObjectsOnCommit
argument_list|()
argument_list|)
expr_stmt|;
name|child
operator|.
name|usingSharedSnaphsotCache
operator|=
name|isUsingSharedSnapshotCache
argument_list|()
expr_stmt|;
return|return
name|child
return|;
block|}
comment|/**      * Returns a user-defined property previously set via 'setUserProperty'. Note that it      * is a caller responsibility to synchronize access to properties.      *       * @since 1.2      */
specifier|public
name|Object
name|getUserProperty
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
name|getUserProperties
argument_list|()
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**      * Sets a user-defined property. Note that it is a caller responsibility to      * synchronize access to properties.      *       * @since 1.2      */
specifier|public
name|void
name|setUserProperty
parameter_list|(
name|String
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|getUserProperties
argument_list|()
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**      * @since 1.2      */
specifier|public
name|void
name|setChannel
parameter_list|(
name|DataChannel
name|channel
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|channel
operator|!=
name|channel
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|mergeHandler
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|mergeHandler
operator|.
name|setActive
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|entityResolver
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|mergeHandler
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|channel
operator|=
name|channel
expr_stmt|;
if|if
condition|(
name|channel
operator|!=
literal|null
condition|)
block|{
comment|// cache entity resolver, as we have no idea how expensive it is to query
comment|// it on the channel every time
name|this
operator|.
name|entityResolver
operator|=
name|channel
operator|.
name|getEntityResolver
argument_list|()
expr_stmt|;
name|EventManager
name|eventManager
init|=
name|channel
operator|.
name|getEventManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|eventManager
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|mergeHandler
operator|=
operator|new
name|DataContextMergeHandler
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// listen to our channel events...
comment|// note that we must reset listener on channel switch, as there is no
comment|// guarantee that a new channel uses the same EventManager.
name|EventUtil
operator|.
name|listenForChannelEvents
argument_list|(
name|channel
argument_list|,
name|mergeHandler
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|public
name|DataChannel
name|getChannel
parameter_list|()
block|{
name|awakeFromDeserialization
argument_list|()
expr_stmt|;
return|return
name|super
operator|.
name|getChannel
argument_list|()
return|;
block|}
comment|/**      * Returns a DataDomain used by this DataContext. DataDomain is looked up in the      * DataChannel hierarchy. If a channel is not a DataDomain or a DataContext, null is      * returned.      *       * @return DataDomain that is a direct or indirect parent of this DataContext in the      *         DataChannel hierarchy.      * @since 1.1      */
specifier|public
name|DataDomain
name|getParentDataDomain
parameter_list|()
block|{
name|awakeFromDeserialization
argument_list|()
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|channel
operator|instanceof
name|DataDomain
condition|)
block|{
return|return
operator|(
name|DataDomain
operator|)
name|channel
return|;
block|}
name|List
name|response
init|=
name|channel
operator|.
name|onQuery
argument_list|(
name|this
argument_list|,
operator|new
name|DataDomainQuery
argument_list|()
argument_list|)
operator|.
name|firstList
argument_list|()
decl_stmt|;
if|if
condition|(
name|response
operator|!=
literal|null
operator|&&
name|response
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|response
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|DataDomain
condition|)
block|{
return|return
operator|(
name|DataDomain
operator|)
name|response
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Sets a DataContextDelegate for this context. Delegate is notified of certain events      * in the DataContext lifecycle and can customize DataContext behavior.      *       * @since 1.1      */
specifier|public
name|void
name|setDelegate
parameter_list|(
name|DataContextDelegate
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
block|}
comment|/**      * Returns a delegate currently associated with this DataContext.      *       * @since 1.1      */
specifier|public
name|DataContextDelegate
name|getDelegate
parameter_list|()
block|{
return|return
name|delegate
return|;
block|}
comment|/**      * @return a delegate instance if it is initialized, or a shared noop implementation      *         the context has no delegate. Useful to prevent extra null checks and      *         conditional logic in the code.      * @since 1.1      */
name|DataContextDelegate
name|nonNullDelegate
parameter_list|()
block|{
return|return
operator|(
name|delegate
operator|!=
literal|null
operator|)
condition|?
name|delegate
else|:
name|NoopDelegate
operator|.
name|noopDelegate
return|;
block|}
comment|/**      * Returns ObjectStore associated with this DataContext.      */
specifier|public
name|ObjectStore
name|getObjectStore
parameter_list|()
block|{
return|return
name|objectStore
return|;
block|}
comment|/**      * Returns<code>true</code> if there are any modified, deleted or new objects      * registered with this DataContext,<code>false</code> otherwise.      */
specifier|public
name|boolean
name|hasChanges
parameter_list|()
block|{
return|return
name|getObjectStore
argument_list|()
operator|.
name|hasChanges
argument_list|()
return|;
block|}
comment|/**      * Returns a list of objects that are registered with this DataContext and have a      * state PersistenceState.NEW      */
specifier|public
name|Collection
name|newObjects
parameter_list|()
block|{
return|return
name|getObjectStore
argument_list|()
operator|.
name|objectsInState
argument_list|(
name|PersistenceState
operator|.
name|NEW
argument_list|)
return|;
block|}
comment|/**      * Returns a list of objects that are registered with this DataContext and have a      * state PersistenceState.DELETED      */
specifier|public
name|Collection
name|deletedObjects
parameter_list|()
block|{
return|return
name|getObjectStore
argument_list|()
operator|.
name|objectsInState
argument_list|(
name|PersistenceState
operator|.
name|DELETED
argument_list|)
return|;
block|}
comment|/**      * Returns a list of objects that are registered with this DataContext and have a      * state PersistenceState.MODIFIED      */
specifier|public
name|Collection
name|modifiedObjects
parameter_list|()
block|{
return|return
name|getObjectStore
argument_list|()
operator|.
name|objectsInState
argument_list|(
name|PersistenceState
operator|.
name|MODIFIED
argument_list|)
return|;
block|}
comment|/**      * Returns a collection of all uncommitted registered objects.      *       * @since 1.2      */
specifier|public
name|Collection
name|uncommittedObjects
parameter_list|()
block|{
name|int
name|len
init|=
name|getObjectStore
argument_list|()
operator|.
name|registeredObjectsCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return
name|Collections
operator|.
name|EMPTY_LIST
return|;
block|}
comment|// guess target collection size
name|Collection
name|objects
init|=
operator|new
name|ArrayList
argument_list|(
name|len
operator|>
literal|100
condition|?
name|len
operator|/
literal|2
else|:
name|len
argument_list|)
decl_stmt|;
name|Iterator
name|it
init|=
name|getObjectStore
argument_list|()
operator|.
name|getObjectIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Persistent
name|object
init|=
operator|(
name|Persistent
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|int
name|state
init|=
name|object
operator|.
name|getPersistenceState
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|PersistenceState
operator|.
name|MODIFIED
operator|||
name|state
operator|==
name|PersistenceState
operator|.
name|NEW
operator|||
name|state
operator|==
name|PersistenceState
operator|.
name|DELETED
condition|)
block|{
name|objects
operator|.
name|add
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|objects
return|;
block|}
comment|/**      * Returns a DataRow reflecting current, possibly uncommitted, object state.      *<p>      *<strong>Warning:</strong> This method will return a partial snapshot if an object      * or one of its related objects that propagate their keys to this object have      * temporary ids. DO NOT USE this method if you expect a DataRow to represent a      * complete object state.      *</p>      *       * @since 1.1      */
specifier|public
name|DataRow
name|currentSnapshot
parameter_list|(
specifier|final
name|Persistent
name|object
parameter_list|)
block|{
comment|// for a HOLLOW object return snapshot from cache
if|if
condition|(
name|object
operator|.
name|getPersistenceState
argument_list|()
operator|==
name|PersistenceState
operator|.
name|HOLLOW
operator|&&
name|object
operator|.
name|getObjectContext
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|getObjectStore
argument_list|()
operator|.
name|getSnapshot
argument_list|(
name|object
operator|.
name|getObjectId
argument_list|()
argument_list|)
return|;
block|}
name|ObjEntity
name|entity
init|=
name|getEntityResolver
argument_list|()
operator|.
name|lookupObjEntity
argument_list|(
name|object
argument_list|)
decl_stmt|;
specifier|final
name|ClassDescriptor
name|descriptor
init|=
name|getEntityResolver
argument_list|()
operator|.
name|getClassDescriptor
argument_list|(
name|entity
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|DataRow
name|snapshot
init|=
operator|new
name|DataRow
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|descriptor
operator|.
name|visitProperties
argument_list|(
operator|new
name|PropertyVisitor
argument_list|()
block|{
specifier|public
name|boolean
name|visitAttribute
parameter_list|(
name|AttributeProperty
name|property
parameter_list|)
block|{
name|ObjAttribute
name|objAttr
init|=
name|property
operator|.
name|getAttribute
argument_list|()
decl_stmt|;
comment|// processing compound attributes correctly
name|snapshot
operator|.
name|put
argument_list|(
name|objAttr
operator|.
name|getDbAttributePath
argument_list|()
argument_list|,
name|property
operator|.
name|readPropertyDirectly
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|visitToMany
parameter_list|(
name|ToManyProperty
name|property
parameter_list|)
block|{
comment|// do nothing
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|visitToOne
parameter_list|(
name|ToOneProperty
name|property
parameter_list|)
block|{
name|ObjRelationship
name|rel
init|=
name|property
operator|.
name|getRelationship
argument_list|()
decl_stmt|;
comment|// if target doesn't propagates its key value, skip it
if|if
condition|(
name|rel
operator|.
name|isSourceIndependentFromTargetChange
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|Object
name|targetObject
init|=
name|property
operator|.
name|readPropertyDirectly
argument_list|(
name|object
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetObject
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// if target is Fault, get id attributes from stored snapshot
comment|// to avoid unneeded fault triggering
if|if
condition|(
name|targetObject
operator|instanceof
name|Fault
condition|)
block|{
name|DataRow
name|storedSnapshot
init|=
name|getObjectStore
argument_list|()
operator|.
name|getSnapshot
argument_list|(
name|object
operator|.
name|getObjectId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedSnapshot
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"No matching objects found for ObjectId "
operator|+
name|object
operator|.
name|getObjectId
argument_list|()
operator|+
literal|". Object may have been deleted externally."
argument_list|)
throw|;
block|}
name|DbRelationship
name|dbRel
init|=
operator|(
name|DbRelationship
operator|)
name|rel
operator|.
name|getDbRelationships
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Iterator
name|joins
init|=
name|dbRel
operator|.
name|getJoins
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|joins
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|DbJoin
name|join
init|=
operator|(
name|DbJoin
operator|)
name|joins
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|key
init|=
name|join
operator|.
name|getSourceName
argument_list|()
decl_stmt|;
name|snapshot
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|storedSnapshot
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|// target is resolved and we have an FK->PK to it,
comment|// so extract it from target...
name|Persistent
name|target
init|=
operator|(
name|Persistent
operator|)
name|targetObject
decl_stmt|;
name|Map
name|idParts
init|=
name|target
operator|.
name|getObjectId
argument_list|()
operator|.
name|getIdSnapshot
argument_list|()
decl_stmt|;
comment|// this may happen in uncommitted objects - see the warning in the JavaDoc
comment|// of
comment|// this method.
if|if
condition|(
name|idParts
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|DbRelationship
name|dbRel
init|=
operator|(
name|DbRelationship
operator|)
name|rel
operator|.
name|getDbRelationships
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Map
name|fk
init|=
name|dbRel
operator|.
name|srcFkSnapshotWithTargetSnapshot
argument_list|(
name|idParts
argument_list|)
decl_stmt|;
name|snapshot
operator|.
name|putAll
argument_list|(
name|fk
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// process object id map
comment|// we should ignore any object id values if a corresponding attribute
comment|// is a part of relationship "toMasterPK", since those values have been
comment|// set above when db relationships where processed.
name|Map
name|thisIdParts
init|=
name|object
operator|.
name|getObjectId
argument_list|()
operator|.
name|getIdSnapshot
argument_list|()
decl_stmt|;
if|if
condition|(
name|thisIdParts
operator|!=
literal|null
condition|)
block|{
comment|// put only those that do not exist in the map
name|Iterator
name|idIterator
init|=
name|thisIdParts
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|idIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
name|entry
init|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|idIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|Object
name|nextKey
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|snapshot
operator|.
name|containsKey
argument_list|(
name|nextKey
argument_list|)
condition|)
block|{
name|snapshot
operator|.
name|put
argument_list|(
name|nextKey
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|snapshot
return|;
block|}
comment|/**      * Converts a list of data rows to a list of DataObjects.      *       * @since 1.1      */
specifier|public
name|List
name|objectsFromDataRows
parameter_list|(
name|ObjEntity
name|entity
parameter_list|,
name|List
name|dataRows
parameter_list|,
name|boolean
name|refresh
parameter_list|,
name|boolean
name|resolveInheritanceHierarchy
parameter_list|)
block|{
comment|// TODO: andrus, 10/11/2006 - instead of doing ClassDescriptor lookup, deprecate
comment|// this method, replacing it with the one that takes CD as argument. Or get rid of
comment|// it all together
name|ClassDescriptor
name|descriptor
init|=
name|getEntityResolver
argument_list|()
operator|.
name|getClassDescriptor
argument_list|(
name|entity
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|ObjectResolver
argument_list|(
name|this
argument_list|,
name|descriptor
argument_list|,
name|refresh
argument_list|,
name|resolveInheritanceHierarchy
argument_list|)
operator|.
name|synchronizedObjectsFromDataRows
argument_list|(
name|dataRows
argument_list|)
return|;
block|}
comment|/**      * Converts a list of DataRows to a List of DataObject registered with this      * DataContext. Internally calls      * {@link #objectsFromDataRows(ObjEntity,List,boolean,boolean)}.      *       * @since 1.1      * @see DataRow      */
specifier|public
name|List
name|objectsFromDataRows
parameter_list|(
name|Class
name|objectClass
parameter_list|,
name|List
name|dataRows
parameter_list|,
name|boolean
name|refresh
parameter_list|,
name|boolean
name|resolveInheritanceHierarchy
parameter_list|)
block|{
name|ObjEntity
name|entity
init|=
name|this
operator|.
name|getEntityResolver
argument_list|()
operator|.
name|lookupObjEntity
argument_list|(
name|objectClass
argument_list|)
decl_stmt|;
if|if
condition|(
name|entity
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Unmapped Java class: "
operator|+
name|objectClass
argument_list|)
throw|;
block|}
return|return
name|objectsFromDataRows
argument_list|(
name|entity
argument_list|,
name|dataRows
argument_list|,
name|refresh
argument_list|,
name|resolveInheritanceHierarchy
argument_list|)
return|;
block|}
comment|/**      * Creates a DataObject from DataRow. This is a convenience shortcut to      * {@link #objectsFromDataRows(Class,java.util.List,boolean,boolean)}.      *       * @see DataRow      */
specifier|public
name|DataObject
name|objectFromDataRow
parameter_list|(
name|Class
name|objectClass
parameter_list|,
name|DataRow
name|dataRow
parameter_list|,
name|boolean
name|refresh
parameter_list|)
block|{
name|List
name|list
init|=
name|objectsFromDataRows
argument_list|(
name|objectClass
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|dataRow
argument_list|)
argument_list|,
name|refresh
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
operator|(
name|DataObject
operator|)
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**      * @deprecated since 3.0, use {@link #newObject(String)} instead.      */
specifier|public
name|DataObject
name|createAndRegisterNewObject
parameter_list|(
name|String
name|objEntityName
parameter_list|)
block|{
return|return
operator|(
name|DataObject
operator|)
name|newObject
argument_list|(
name|objEntityName
argument_list|)
return|;
block|}
comment|/**      * Creates and registers a new persistent object.      *       * @since 1.2      */
specifier|public
name|Persistent
name|newObject
parameter_list|(
name|Class
name|persistentClass
parameter_list|)
block|{
if|if
condition|(
name|persistentClass
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Null 'persistentClass'"
argument_list|)
throw|;
block|}
name|ObjEntity
name|entity
init|=
name|getEntityResolver
argument_list|()
operator|.
name|lookupObjEntity
argument_list|(
name|persistentClass
argument_list|)
decl_stmt|;
if|if
condition|(
name|entity
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Class is not mapped with Cayenne: "
operator|+
name|persistentClass
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|newObject
argument_list|(
name|entity
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Instantiates a new object and registers it with this context. Object class is      * determined from the mapped entity. Object class must have a default constructor.      *<p/><i>Note: in most cases {@link #newObject(Class)} method should be used,      * however this method is helpful when generic persistent classes are used.</i>      *       * @since 3.0      */
specifier|public
name|Persistent
name|newObject
parameter_list|(
name|String
name|entityName
parameter_list|)
block|{
name|ClassDescriptor
name|descriptor
init|=
name|getEntityResolver
argument_list|()
operator|.
name|getClassDescriptor
argument_list|(
name|entityName
argument_list|)
decl_stmt|;
if|if
condition|(
name|descriptor
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid entity name: "
operator|+
name|entityName
argument_list|)
throw|;
block|}
name|Persistent
name|object
decl_stmt|;
try|try
block|{
name|object
operator|=
operator|(
name|Persistent
operator|)
name|descriptor
operator|.
name|createObject
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Error instantiating object."
argument_list|,
name|ex
argument_list|)
throw|;
block|}
comment|// this will initialize to-many lists
name|descriptor
operator|.
name|injectValueHolders
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|ObjectId
name|id
init|=
operator|new
name|ObjectId
argument_list|(
name|entityName
argument_list|)
decl_stmt|;
comment|// note that the order of initialization of persistence artifacts below is
comment|// important - do not change it lightly
name|object
operator|.
name|setObjectId
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|object
operator|.
name|setObjectContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|object
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|NEW
argument_list|)
expr_stmt|;
name|getObjectStore
argument_list|()
operator|.
name|registerNode
argument_list|(
name|id
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|getObjectStore
argument_list|()
operator|.
name|nodeCreated
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|// invoke callbacks
name|getEntityResolver
argument_list|()
operator|.
name|getCallbackRegistry
argument_list|()
operator|.
name|performCallbacks
argument_list|(
name|LifecycleListener
operator|.
name|PRE_PERSIST
argument_list|,
name|object
argument_list|)
expr_stmt|;
return|return
name|object
return|;
block|}
comment|/**      * Instantiates new object and registers it with itself. Object class must have a      * default constructor.      *       * @since 1.1      * @deprecated since 3.0, use {@link #newObject(Class)} instead.      */
specifier|public
name|DataObject
name|createAndRegisterNewObject
parameter_list|(
name|Class
name|objectClass
parameter_list|)
block|{
if|if
condition|(
name|objectClass
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"DataObject class can't be null."
argument_list|)
throw|;
block|}
name|ObjEntity
name|entity
init|=
name|getEntityResolver
argument_list|()
operator|.
name|lookupObjEntity
argument_list|(
name|objectClass
argument_list|)
decl_stmt|;
if|if
condition|(
name|entity
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Class is not mapped with Cayenne: "
operator|+
name|objectClass
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|createAndRegisterNewObject
argument_list|(
name|entity
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Registers a transient object with the context, recursively registering all      * transient persistent objects attached to this object via relationships.<p/><i>Note      * that since 3.0 this method takes Object as an argument instead of a      * {@link DataObject}.</i>      *       * @param object new object that needs to be made persistent.      */
specifier|public
name|void
name|registerNewObject
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|object
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Can't register null object."
argument_list|)
throw|;
block|}
name|ObjEntity
name|entity
init|=
name|getEntityResolver
argument_list|()
operator|.
name|lookupObjEntity
argument_list|(
name|object
argument_list|)
decl_stmt|;
if|if
condition|(
name|entity
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Can't find ObjEntity for DataObject class: "
operator|+
name|object
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|", class is likely not mapped."
argument_list|)
throw|;
block|}
specifier|final
name|Persistent
name|persistent
init|=
operator|(
name|Persistent
operator|)
name|object
decl_stmt|;
comment|// sanity check - maybe already registered
if|if
condition|(
name|persistent
operator|.
name|getObjectId
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|persistent
operator|.
name|getObjectContext
argument_list|()
operator|==
name|this
condition|)
block|{
comment|// already registered, just ignore
return|return;
block|}
if|else if
condition|(
name|persistent
operator|.
name|getObjectContext
argument_list|()
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"DataObject is already registered with another DataContext. "
operator|+
literal|"Try using 'localObjects()' instead."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|persistent
operator|.
name|setObjectId
argument_list|(
operator|new
name|ObjectId
argument_list|(
name|entity
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|persistent
operator|.
name|setObjectContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|persistent
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|NEW
argument_list|)
expr_stmt|;
name|getObjectStore
argument_list|()
operator|.
name|registerNode
argument_list|(
name|persistent
operator|.
name|getObjectId
argument_list|()
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|getObjectStore
argument_list|()
operator|.
name|nodeCreated
argument_list|(
name|persistent
operator|.
name|getObjectId
argument_list|()
argument_list|)
expr_stmt|;
comment|// now we need to find all arc changes, inject missing value holders and pull in
comment|// all transient connected objects
name|ClassDescriptor
name|descriptor
init|=
name|getEntityResolver
argument_list|()
operator|.
name|getClassDescriptor
argument_list|(
name|entity
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|descriptor
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid entity name: "
operator|+
name|entity
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
name|descriptor
operator|.
name|visitProperties
argument_list|(
operator|new
name|PropertyVisitor
argument_list|()
block|{
specifier|public
name|boolean
name|visitToMany
parameter_list|(
name|ToManyProperty
name|property
parameter_list|)
block|{
name|property
operator|.
name|injectValueHolder
argument_list|(
name|persistent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|property
operator|.
name|isFault
argument_list|(
name|persistent
argument_list|)
condition|)
block|{
name|Iterator
name|it
init|=
operator|(
operator|(
name|Collection
operator|)
name|property
operator|.
name|readProperty
argument_list|(
name|persistent
argument_list|)
operator|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Object
name|target
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|target
operator|instanceof
name|DataObject
condition|)
block|{
name|DataObject
name|targetDO
init|=
operator|(
name|DataObject
operator|)
name|target
decl_stmt|;
comment|// make sure it is registered
name|registerNewObject
argument_list|(
name|targetDO
argument_list|)
expr_stmt|;
name|getObjectStore
argument_list|()
operator|.
name|arcCreated
argument_list|(
name|persistent
operator|.
name|getObjectId
argument_list|()
argument_list|,
name|targetDO
operator|.
name|getObjectId
argument_list|()
argument_list|,
name|property
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|visitToOne
parameter_list|(
name|ToOneProperty
name|property
parameter_list|)
block|{
name|Object
name|target
init|=
name|property
operator|.
name|readPropertyDirectly
argument_list|(
name|persistent
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|instanceof
name|DataObject
condition|)
block|{
name|DataObject
name|targetDO
init|=
operator|(
name|DataObject
operator|)
name|target
decl_stmt|;
comment|// make sure it is registered
name|registerNewObject
argument_list|(
name|targetDO
argument_list|)
expr_stmt|;
name|getObjectStore
argument_list|()
operator|.
name|arcCreated
argument_list|(
name|persistent
operator|.
name|getObjectId
argument_list|()
argument_list|,
name|targetDO
operator|.
name|getObjectId
argument_list|()
argument_list|,
name|property
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|visitAttribute
parameter_list|(
name|AttributeProperty
name|property
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// invoke callbacks
name|getEntityResolver
argument_list|()
operator|.
name|getCallbackRegistry
argument_list|()
operator|.
name|performCallbacks
argument_list|(
name|LifecycleListener
operator|.
name|PRE_PERSIST
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
comment|/**      * Unregisters a Collection of DataObjects from the DataContext and the underlying      * ObjectStore. This operation also unsets DataContext and ObjectId for each object      * and changes its state to TRANSIENT.      *       * @see #invalidateObjects(Collection)      */
specifier|public
name|void
name|unregisterObjects
parameter_list|(
name|Collection
name|dataObjects
parameter_list|)
block|{
name|getObjectStore
argument_list|()
operator|.
name|objectsUnregistered
argument_list|(
name|dataObjects
argument_list|)
expr_stmt|;
block|}
comment|/**      * "Invalidates" a Collection of persistent objects. This operation would remove each      * object's snapshot from cache and change object's state to HOLLOW. On the next      * access to this object, it will be refetched.      *       * @see #unregisterObjects(Collection)      * @see RefreshQuery      */
specifier|public
name|void
name|invalidateObjects
parameter_list|(
name|Collection
name|objects
parameter_list|)
block|{
name|performGenericQuery
argument_list|(
operator|new
name|RefreshQuery
argument_list|(
name|objects
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Schedules all objects in the collection for deletion on the next commit of this      * DataContext. Object's persistence state is changed to PersistenceState.DELETED;      * objects related to this object are processed according to delete rules, i.e.      * relationships can be unset ("nullify" rule), deletion operation is cascaded      * (cascade rule).      *<p>      *<i>"Nullify" delete rule side effect:</i> passing a collection representing      * to-many relationship with nullify delete rule may result in objects being removed      * from collection.      *</p>      *       * @since 1.2      */
specifier|public
name|void
name|deleteObjects
parameter_list|(
name|Collection
name|objects
parameter_list|)
block|{
if|if
condition|(
name|objects
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// clone object list... this maybe a relationship collection with nullify delete
comment|// rule, so modifying
name|Iterator
name|it
init|=
operator|new
name|ArrayList
argument_list|(
name|objects
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Persistent
name|object
init|=
operator|(
name|Persistent
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|deleteObject
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Schedules an object for deletion on the next commit of this DataContext. Object's      * persistence state is changed to PersistenceState.DELETED; objects related to this      * object are processed according to delete rules, i.e. relationships can be unset      * ("nullify" rule), deletion operation is cascaded (cascade rule).      *       * @param object a persistent object that we want to delete.      * @throws DeleteDenyException if a DENY delete rule is applicable for object      *             deletion.      * @throws NullPointerException if object is null.      */
specifier|public
name|void
name|deleteObject
parameter_list|(
name|Object
name|object
parameter_list|)
throws|throws
name|DeleteDenyException
block|{
operator|new
name|DataContextDeleteAction
argument_list|(
name|this
argument_list|)
operator|.
name|performDelete
argument_list|(
operator|(
name|Persistent
operator|)
name|object
argument_list|)
expr_stmt|;
block|}
comment|/**      * Refetches object data for ObjectId. This method is used internally by Cayenne to      * resolve objects in state<code>PersistenceState.HOLLOW</code>. It can also be      * used to refresh certain objects.      *       * @throws CayenneRuntimeException if object id doesn't match any records, or if there      *             is more than one object is fetched.      * @deprecated since 3.0 use {@link ObjectIdQuery} with appropriate refresh settings.      */
specifier|public
name|DataObject
name|refetchObject
parameter_list|(
name|ObjectId
name|oid
parameter_list|)
block|{
if|if
condition|(
name|oid
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Null ObjectId"
argument_list|)
throw|;
block|}
if|if
condition|(
name|oid
operator|.
name|isTemporary
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Can't refetch ObjectId "
operator|+
name|oid
operator|+
literal|", as it is a temporary id."
argument_list|)
throw|;
block|}
synchronized|synchronized
init|(
name|getObjectStore
argument_list|()
init|)
block|{
name|DataObject
name|object
init|=
operator|(
name|DataObject
operator|)
name|objectStore
operator|.
name|getNode
argument_list|(
name|oid
argument_list|)
decl_stmt|;
comment|// clean up any cached data for this object
if|if
condition|(
name|object
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|invalidateObjects
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|DataObject
name|object
init|=
operator|(
name|DataObject
operator|)
name|DataObjectUtils
operator|.
name|objectForQuery
argument_list|(
name|this
argument_list|,
operator|new
name|ObjectIdQuery
argument_list|(
name|oid
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|object
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Refetch failure: no matching objects found for ObjectId "
operator|+
name|oid
argument_list|)
throw|;
block|}
return|return
name|object
return|;
block|}
comment|/**      * If the parent channel is a DataContext, reverts local changes to make this context      * look like the parent, if the parent channel is a DataDomain, reverts all changes.      *       * @since 1.2      */
comment|// TODO: Andrus, 1/19/2006: implement for nested DataContexts
specifier|public
name|void
name|rollbackChangesLocally
parameter_list|()
block|{
if|if
condition|(
name|getChannel
argument_list|()
operator|instanceof
name|DataDomain
condition|)
block|{
name|rollbackChanges
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Implementation pending."
argument_list|)
throw|;
block|}
block|}
comment|/**      * Reverts any changes that have occurred to objects registered with DataContext; also      * performs cascading rollback of all parent DataContexts.      */
specifier|public
name|void
name|rollbackChanges
parameter_list|()
block|{
if|if
condition|(
name|objectStore
operator|.
name|hasChanges
argument_list|()
condition|)
block|{
name|GraphDiff
name|diff
init|=
name|getObjectStore
argument_list|()
operator|.
name|getChanges
argument_list|()
decl_stmt|;
comment|// call channel with changes BEFORE reverting them, so that any interceptors
comment|// could record them
if|if
condition|(
name|channel
operator|!=
literal|null
condition|)
block|{
name|channel
operator|.
name|onSync
argument_list|(
name|this
argument_list|,
name|diff
argument_list|,
name|DataChannel
operator|.
name|ROLLBACK_CASCADE_SYNC
argument_list|)
expr_stmt|;
block|}
name|getObjectStore
argument_list|()
operator|.
name|objectsRolledBack
argument_list|()
expr_stmt|;
name|fireDataChannelRolledback
argument_list|(
name|this
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * "Flushes" the changes to the parent {@link DataChannel}. If the parent channel is      * a DataContext, it updates its objects with this context's changes, without a      * database update. If it is a DataDomain (the most common case), the changes are      * written to the database. To cause cascading commit all the way to the database, one      * must use {@link #commitChanges()}.      *       * @since 1.2      * @see #commitChanges()      */
specifier|public
name|void
name|commitChangesToParent
parameter_list|()
block|{
name|flushToParent
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Synchronizes object graph with the database. Executes needed insert, update and      * delete queries (generated internally).      */
specifier|public
name|void
name|commitChanges
parameter_list|()
throws|throws
name|CayenneRuntimeException
block|{
name|flushToParent
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns EventManager associated with the ObjectStore.      *       * @since 1.2      */
specifier|public
name|EventManager
name|getEventManager
parameter_list|()
block|{
return|return
name|channel
operator|!=
literal|null
condition|?
name|channel
operator|.
name|getEventManager
argument_list|()
else|:
literal|null
return|;
block|}
comment|/**      * An implementation of a {@link DataChannel} method that is used by child contexts to      * synchronize state with this context. Not intended for direct use.      *       * @since 1.2      */
specifier|public
name|GraphDiff
name|onSync
parameter_list|(
name|ObjectContext
name|originatingContext
parameter_list|,
name|GraphDiff
name|changes
parameter_list|,
name|int
name|syncType
parameter_list|)
block|{
comment|// sync client changes
switch|switch
condition|(
name|syncType
condition|)
block|{
case|case
name|DataChannel
operator|.
name|ROLLBACK_CASCADE_SYNC
case|:
return|return
name|onContextRollback
argument_list|(
name|originatingContext
argument_list|)
return|;
case|case
name|DataChannel
operator|.
name|FLUSH_NOCASCADE_SYNC
case|:
return|return
name|onContextFlush
argument_list|(
name|originatingContext
argument_list|,
name|changes
argument_list|,
literal|false
argument_list|)
return|;
case|case
name|DataChannel
operator|.
name|FLUSH_CASCADE_SYNC
case|:
return|return
name|onContextFlush
argument_list|(
name|originatingContext
argument_list|,
name|changes
argument_list|,
literal|true
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Unrecognized SyncMessage type: "
operator|+
name|syncType
argument_list|)
throw|;
block|}
block|}
name|GraphDiff
name|onContextRollback
parameter_list|(
name|ObjectContext
name|originatingContext
parameter_list|)
block|{
name|rollbackChanges
argument_list|()
expr_stmt|;
return|return
operator|new
name|CompoundDiff
argument_list|()
return|;
block|}
name|GraphDiff
name|onContextFlush
parameter_list|(
name|ObjectContext
name|originatingContext
parameter_list|,
name|GraphDiff
name|changes
parameter_list|,
name|boolean
name|cascade
parameter_list|)
block|{
if|if
condition|(
name|this
operator|!=
name|originatingContext
operator|&&
name|changes
operator|!=
literal|null
condition|)
block|{
name|changes
operator|.
name|apply
argument_list|(
operator|new
name|ChildDiffLoader
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|fireDataChannelChanged
argument_list|(
name|originatingContext
argument_list|,
name|changes
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cascade
operator|)
condition|?
name|flushToParent
argument_list|(
literal|true
argument_list|)
else|:
operator|new
name|CompoundDiff
argument_list|()
return|;
block|}
comment|/**      * Synchronizes with the parent channel, performing a flush or a commit.      *       * @since 1.2      */
name|GraphDiff
name|flushToParent
parameter_list|(
name|boolean
name|cascade
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|getChannel
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Cannot commit changes - channel is not set."
argument_list|)
throw|;
block|}
name|int
name|syncType
init|=
name|cascade
condition|?
name|DataChannel
operator|.
name|FLUSH_CASCADE_SYNC
else|:
name|DataChannel
operator|.
name|FLUSH_NOCASCADE_SYNC
decl_stmt|;
name|ObjectStore
name|objectStore
init|=
name|getObjectStore
argument_list|()
decl_stmt|;
comment|// prevent multiple commits occuring simulteneously
synchronized|synchronized
init|(
name|objectStore
init|)
block|{
name|ObjectStoreGraphDiff
name|changes
init|=
name|objectStore
operator|.
name|getChanges
argument_list|()
decl_stmt|;
name|boolean
name|noop
init|=
name|isValidatingObjectsOnCommit
argument_list|()
condition|?
name|changes
operator|.
name|validateAndCheckNoop
argument_list|()
else|:
name|changes
operator|.
name|isNoop
argument_list|()
decl_stmt|;
if|if
condition|(
name|noop
condition|)
block|{
comment|// need to clear phantom changes
name|objectStore
operator|.
name|postprocessAfterPhantomCommit
argument_list|()
expr_stmt|;
return|return
operator|new
name|CompoundDiff
argument_list|()
return|;
block|}
try|try
block|{
name|GraphDiff
name|returnChanges
init|=
name|getChannel
argument_list|()
operator|.
name|onSync
argument_list|(
name|this
argument_list|,
name|changes
argument_list|,
name|syncType
argument_list|)
decl_stmt|;
comment|// note that this is a hack resulting from a fix to CAY-766... To support
comment|// valid object state in PostPersist callback, 'postprocessAfterCommit' is
comment|// invoked by DataDomain.onSync(..). Unless the parent is DataContext, and
comment|// this method is not invoked!! As a result, PostPersist will contain temp
comment|// ObjectIds in nested contexts and perm ones in flat contexts.
comment|// Pending better callback design .....
if|if
condition|(
name|objectStore
operator|.
name|hasChanges
argument_list|()
condition|)
block|{
name|objectStore
operator|.
name|postprocessAfterCommit
argument_list|(
name|returnChanges
argument_list|)
expr_stmt|;
block|}
comment|// this event is caught by peer nested DataContexts to synchronize the
comment|// state
name|fireDataChannelCommitted
argument_list|(
name|this
argument_list|,
name|changes
argument_list|)
expr_stmt|;
comment|// this event is caught by child DataContexts to update temporary
comment|// ObjectIds with permanent
if|if
condition|(
operator|!
name|returnChanges
operator|.
name|isNoop
argument_list|()
condition|)
block|{
name|fireDataChannelCommitted
argument_list|(
name|getChannel
argument_list|()
argument_list|,
name|returnChanges
argument_list|)
expr_stmt|;
block|}
return|return
name|returnChanges
return|;
block|}
comment|// "catch" is needed to unwrap OptimisticLockExceptions
catch|catch
parameter_list|(
name|CayenneRuntimeException
name|ex
parameter_list|)
block|{
name|Throwable
name|unwound
init|=
name|Util
operator|.
name|unwindException
argument_list|(
name|ex
argument_list|)
decl_stmt|;
if|if
condition|(
name|unwound
operator|instanceof
name|CayenneRuntimeException
condition|)
block|{
throw|throw
operator|(
name|CayenneRuntimeException
operator|)
name|unwound
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Commit Exception"
argument_list|,
name|unwound
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**      * Performs a single database select query returning result as a ResultIterator. It is      * caller's responsibility to explicitly close the ResultIterator. A failure to do so      * will result in a database connection not being released. Another side effect of an      * open ResultIterator is that an internal Cayenne transaction that originated in this      * method stays open until the iterator is closed. So users should normally close the      * iterator within the same thread that opened it.      */
specifier|public
name|ResultIterator
name|performIteratedQuery
parameter_list|(
name|Query
name|query
parameter_list|)
throws|throws
name|CayenneException
block|{
if|if
condition|(
name|Transaction
operator|.
name|getThreadTransaction
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|internalPerformIteratedQuery
argument_list|(
name|query
argument_list|)
return|;
block|}
else|else
block|{
comment|// manually manage a transaction, so that a ResultIterator wrapper could close
comment|// it when it is done.
name|Transaction
name|tx
init|=
name|getParentDataDomain
argument_list|()
operator|.
name|createTransaction
argument_list|()
decl_stmt|;
name|Transaction
operator|.
name|bindThreadTransaction
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ResultIterator
name|result
decl_stmt|;
try|try
block|{
name|result
operator|=
name|internalPerformIteratedQuery
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|Transaction
operator|.
name|bindThreadTransaction
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|tx
operator|.
name|setRollbackOnly
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|CayenneException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
comment|// note: we are keeping the transaction bound to the current thread on
comment|// success - iterator will unbind it. Unsetting a transaction here would
comment|// result in some strangeness, at least on Ingres
if|if
condition|(
name|tx
operator|.
name|getStatus
argument_list|()
operator|==
name|Transaction
operator|.
name|STATUS_MARKED_ROLLEDBACK
condition|)
block|{
try|try
block|{
name|tx
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|rollbackEx
parameter_list|)
block|{
block|}
block|}
block|}
return|return
operator|new
name|TransactionResultIteratorDecorator
argument_list|(
name|result
argument_list|,
name|tx
argument_list|)
return|;
block|}
block|}
comment|/**      * Runs an iterated query in transactional context provided by the caller.      *       * @since 1.2      */
name|ResultIterator
name|internalPerformIteratedQuery
parameter_list|(
name|Query
name|query
parameter_list|)
throws|throws
name|CayenneException
block|{
comment|// note that for now DataChannel API does not support cursors (aka
comment|// ResultIterator), so we have to go directly to the DataDomain.
name|IteratedSelectObserver
name|observer
init|=
operator|new
name|IteratedSelectObserver
argument_list|()
decl_stmt|;
name|getParentDataDomain
argument_list|()
operator|.
name|performQueries
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|query
argument_list|)
argument_list|,
name|observer
argument_list|)
expr_stmt|;
return|return
name|observer
operator|.
name|getResultIterator
argument_list|()
return|;
block|}
comment|/**      * Executes a query returning a generic response.      *       * @since 1.2      */
specifier|public
name|QueryResponse
name|performGenericQuery
parameter_list|(
name|Query
name|query
parameter_list|)
block|{
name|query
operator|=
name|nonNullDelegate
argument_list|()
operator|.
name|willPerformGenericQuery
argument_list|(
name|this
argument_list|,
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|GenericResponse
argument_list|()
return|;
block|}
if|if
condition|(
name|this
operator|.
name|getChannel
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Can't run query - parent DataChannel is not set."
argument_list|)
throw|;
block|}
return|return
name|onQuery
argument_list|(
name|this
argument_list|,
name|query
argument_list|)
return|;
block|}
comment|/**      * Performs a single selecting query. Various query setting control the behavior of      * this method and the results returned:      *<ul>      *<li>Query caching policy defines whether the results are retrieved from cache or      * fetched from the database. Note that queries that use caching must have a name that      * is used as a caching key.</li>      *<li>Query refreshing policy controls whether to refresh existing data objects and      * ignore any cached values.</li>      *<li>Query data rows policy defines whether the result should be returned as      * DataObjects or DataRows.</li>      *</ul>      *<p>      *<i>Since 1.2 takes any Query parameter, not just GenericSelectQuery</i>      *</p>      *       * @return A list of DataObjects or a DataRows, depending on the value returned by      *         {@link QueryMetadata#isFetchingDataRows()}.      */
specifier|public
name|List
name|performQuery
parameter_list|(
name|Query
name|query
parameter_list|)
block|{
name|query
operator|=
name|nonNullDelegate
argument_list|()
operator|.
name|willPerformQuery
argument_list|(
name|this
argument_list|,
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|ArrayList
argument_list|(
literal|1
argument_list|)
return|;
block|}
name|List
name|result
init|=
name|onQuery
argument_list|(
name|this
argument_list|,
name|query
argument_list|)
operator|.
name|firstList
argument_list|()
decl_stmt|;
return|return
name|result
operator|!=
literal|null
condition|?
name|result
else|:
operator|new
name|ArrayList
argument_list|(
literal|1
argument_list|)
return|;
block|}
comment|/**      * An implementation of a {@link DataChannel} method that is used by child contexts to      * execute queries. Not intended for direct use.      *       * @since 1.2      */
specifier|public
name|QueryResponse
name|onQuery
parameter_list|(
name|ObjectContext
name|context
parameter_list|,
name|Query
name|query
parameter_list|)
block|{
return|return
operator|new
name|DataContextQueryAction
argument_list|(
name|this
argument_list|,
name|context
argument_list|,
name|query
argument_list|)
operator|.
name|execute
argument_list|()
return|;
block|}
comment|/**      * Performs a single database query that does not select rows. Returns an array of      * update counts.      *       * @since 1.1      */
specifier|public
name|int
index|[]
name|performNonSelectingQuery
parameter_list|(
name|Query
name|query
parameter_list|)
block|{
name|int
index|[]
name|count
init|=
name|performGenericQuery
argument_list|(
name|query
argument_list|)
operator|.
name|firstUpdateCount
argument_list|()
decl_stmt|;
return|return
name|count
operator|!=
literal|null
condition|?
name|count
else|:
operator|new
name|int
index|[
literal|0
index|]
return|;
block|}
comment|/**      * Performs a named mapped query that does not select rows. Returns an array of update      * counts.      *       * @since 1.1      */
specifier|public
name|int
index|[]
name|performNonSelectingQuery
parameter_list|(
name|String
name|queryName
parameter_list|)
block|{
return|return
name|performNonSelectingQuery
argument_list|(
operator|new
name|NamedQuery
argument_list|(
name|queryName
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Performs a named mapped non-selecting query using a map of parameters. Returns an      * array of update counts.      *       * @since 1.1      */
specifier|public
name|int
index|[]
name|performNonSelectingQuery
parameter_list|(
name|String
name|queryName
parameter_list|,
name|Map
name|parameters
parameter_list|)
block|{
return|return
name|performNonSelectingQuery
argument_list|(
operator|new
name|NamedQuery
argument_list|(
name|queryName
argument_list|,
name|parameters
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Returns a list of objects or DataRows for a named query stored in one of the      * DataMaps. Internally Cayenne uses a caching policy defined in the named query. If      * refresh flag is true, a refresh is forced no matter what the caching policy is.      *       * @param queryName a name of a GenericSelectQuery defined in one of the DataMaps. If      *            no such query is defined, this method will throw a      *            CayenneRuntimeException.      * @param expireCachedLists A flag that determines whether refresh of<b>cached lists</b>      *            is required in case a query uses caching.      * @since 1.1      */
specifier|public
name|List
name|performQuery
parameter_list|(
name|String
name|queryName
parameter_list|,
name|boolean
name|expireCachedLists
parameter_list|)
block|{
return|return
name|performQuery
argument_list|(
name|queryName
argument_list|,
name|Collections
operator|.
name|EMPTY_MAP
argument_list|,
name|expireCachedLists
argument_list|)
return|;
block|}
comment|/**      * Returns a list of objects or DataRows for a named query stored in one of the      * DataMaps. Internally Cayenne uses a caching policy defined in the named query. If      * refresh flag is true, a refresh is forced no matter what the caching policy is.      *       * @param queryName a name of a GenericSelectQuery defined in one of the DataMaps. If      *            no such query is defined, this method will throw a      *            CayenneRuntimeException.      * @param parameters A map of parameters to use with stored query.      * @param expireCachedLists A flag that determines whether refresh of<b>cached lists</b>      *            is required in case a query uses caching.      * @since 1.1      */
specifier|public
name|List
name|performQuery
parameter_list|(
name|String
name|queryName
parameter_list|,
name|Map
name|parameters
parameter_list|,
name|boolean
name|expireCachedLists
parameter_list|)
block|{
name|NamedQuery
name|query
init|=
operator|new
name|NamedQuery
argument_list|(
name|queryName
argument_list|,
name|parameters
argument_list|)
decl_stmt|;
name|query
operator|.
name|setForceNoCache
argument_list|(
name|expireCachedLists
argument_list|)
expr_stmt|;
return|return
name|performQuery
argument_list|(
name|query
argument_list|)
return|;
block|}
comment|/**      * Returns EntityResolver. EntityResolver can be null if DataContext has not been      * attached to an DataChannel.      */
specifier|public
name|EntityResolver
name|getEntityResolver
parameter_list|()
block|{
name|awakeFromDeserialization
argument_list|()
expr_stmt|;
return|return
name|entityResolver
return|;
block|}
comment|/**      * Returns<code>true</code> if the ObjectStore uses shared cache of a parent      * DataDomain.      *       * @since 1.1      */
specifier|public
name|boolean
name|isUsingSharedSnapshotCache
parameter_list|()
block|{
return|return
name|usingSharedSnaphsotCache
return|;
block|}
comment|/**      * Returns whether this DataContext performs object validation before commit is      * executed.      *       * @since 1.1      */
specifier|public
name|boolean
name|isValidatingObjectsOnCommit
parameter_list|()
block|{
return|return
name|validatingObjectsOnCommit
return|;
block|}
comment|/**      * Sets the property defining whether this DataContext should perform object      * validation before commit is executed.      *       * @since 1.1      */
specifier|public
name|void
name|setValidatingObjectsOnCommit
parameter_list|(
name|boolean
name|flag
parameter_list|)
block|{
name|this
operator|.
name|validatingObjectsOnCommit
operator|=
name|flag
expr_stmt|;
block|}
comment|/**      * @since 1.2      */
name|void
name|fireDataChannelCommitted
parameter_list|(
name|Object
name|postedBy
parameter_list|,
name|GraphDiff
name|changes
parameter_list|)
block|{
name|EventManager
name|manager
init|=
name|getEventManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|manager
operator|!=
literal|null
condition|)
block|{
name|GraphEvent
name|e
init|=
operator|new
name|GraphEvent
argument_list|(
name|this
argument_list|,
name|postedBy
argument_list|,
name|changes
argument_list|)
decl_stmt|;
name|manager
operator|.
name|postEvent
argument_list|(
name|e
argument_list|,
name|DataChannel
operator|.
name|GRAPH_FLUSHED_SUBJECT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @since 1.2      */
name|void
name|fireDataChannelRolledback
parameter_list|(
name|Object
name|postedBy
parameter_list|,
name|GraphDiff
name|changes
parameter_list|)
block|{
name|EventManager
name|manager
init|=
name|getEventManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|manager
operator|!=
literal|null
condition|)
block|{
name|GraphEvent
name|e
init|=
operator|new
name|GraphEvent
argument_list|(
name|this
argument_list|,
name|postedBy
argument_list|,
name|changes
argument_list|)
decl_stmt|;
name|manager
operator|.
name|postEvent
argument_list|(
name|e
argument_list|,
name|DataChannel
operator|.
name|GRAPH_ROLLEDBACK_SUBJECT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @since 1.2      */
name|void
name|fireDataChannelChanged
parameter_list|(
name|Object
name|postedBy
parameter_list|,
name|GraphDiff
name|changes
parameter_list|)
block|{
name|EventManager
name|manager
init|=
name|getEventManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|manager
operator|!=
literal|null
condition|)
block|{
name|GraphEvent
name|e
init|=
operator|new
name|GraphEvent
argument_list|(
name|this
argument_list|,
name|postedBy
argument_list|,
name|changes
argument_list|)
decl_stmt|;
name|manager
operator|.
name|postEvent
argument_list|(
name|e
argument_list|,
name|DataChannel
operator|.
name|GRAPH_CHANGED_SUBJECT
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ---------------------------------------------
comment|// Serialization Support
comment|// ---------------------------------------------
specifier|private
name|void
name|writeObject
parameter_list|(
name|ObjectOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
comment|// If the "parent" of this datacontext is a DataDomain, then just write the
comment|// name of it. Then when deserialization happens, we can get back the DataDomain
comment|// by name, from the shared configuration (which will either load it if need be,
comment|// or return an existing one.
if|if
condition|(
name|this
operator|.
name|channel
operator|==
literal|null
operator|&&
name|this
operator|.
name|lazyInitParentDomainName
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|writeObject
argument_list|(
name|lazyInitParentDomainName
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|this
operator|.
name|channel
operator|instanceof
name|DataDomain
condition|)
block|{
name|DataDomain
name|domain
init|=
operator|(
name|DataDomain
operator|)
name|this
operator|.
name|channel
decl_stmt|;
name|out
operator|.
name|writeObject
argument_list|(
name|domain
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Hope that whatever this.parent is, that it is Serializable
name|out
operator|.
name|writeObject
argument_list|(
name|this
operator|.
name|channel
argument_list|)
expr_stmt|;
block|}
comment|// Serialize local snapshots cache
if|if
condition|(
operator|!
name|isUsingSharedSnapshotCache
argument_list|()
condition|)
block|{
name|out
operator|.
name|writeObject
argument_list|(
name|objectStore
operator|.
name|getDataRowCache
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// serialization support
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
comment|// 1. read non-transient properties
name|in
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
comment|// 2. read parent or its name
name|Object
name|value
init|=
name|in
operator|.
name|readObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|DataChannel
condition|)
block|{
comment|// A real QueryEngine object - use it
name|this
operator|.
name|channel
operator|=
operator|(
name|DataChannel
operator|)
name|value
expr_stmt|;
block|}
if|else if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
comment|// The name of a DataDomain - use it
name|this
operator|.
name|lazyInitParentDomainName
operator|=
operator|(
name|String
operator|)
name|value
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|CayenneRuntimeException
argument_list|(
literal|"Parent attribute of DataContext was neither a QueryEngine nor "
operator|+
literal|"the name of a valid DataDomain:"
operator|+
name|value
argument_list|)
throw|;
block|}
comment|// 3. Deserialize local snapshots cache
if|if
condition|(
operator|!
name|isUsingSharedSnapshotCache
argument_list|()
condition|)
block|{
name|DataRowStore
name|cache
init|=
operator|(
name|DataRowStore
operator|)
name|in
operator|.
name|readObject
argument_list|()
decl_stmt|;
name|objectStore
operator|.
name|setDataRowCache
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
comment|// CayenneDataObjects have a transient datacontext
comment|// because at deserialize time the datacontext may need to be different
comment|// than the one at serialize time (for programmer defined reasons).
comment|// So, when a dataobject is resurrected because it's datacontext was
comment|// serialized, it will then set the objects datacontext to the correctone
comment|// If deserialized "otherwise", it will not have a datacontext (good)
synchronized|synchronized
init|(
name|getObjectStore
argument_list|()
init|)
block|{
name|Iterator
name|it
init|=
name|objectStore
operator|.
name|getObjectIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Persistent
name|object
init|=
operator|(
name|Persistent
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|object
operator|.
name|setObjectContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Re-attaches itself to the parent domain with previously stored name.
comment|//
comment|// TODO: Andrus 11/7/2005 - this is one of the places where Cayenne
comment|// serialization relies on shared config... This is bad. We need some
comment|// sort of thread-local solution that would allow to use an alternative configuration.
comment|//
specifier|private
specifier|final
name|void
name|awakeFromDeserialization
parameter_list|()
block|{
if|if
condition|(
name|channel
operator|==
literal|null
operator|&&
name|lazyInitParentDomainName
operator|!=
literal|null
condition|)
block|{
comment|// call a setter to ensure EntityResolver is extracted from channel
name|setChannel
argument_list|(
name|Configuration
operator|.
name|getSharedConfiguration
argument_list|()
operator|.
name|getDomain
argument_list|(
name|lazyInitParentDomainName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @since 1.2      */
specifier|public
name|void
name|propertyChanged
parameter_list|(
name|Persistent
name|object
parameter_list|,
name|String
name|property
parameter_list|,
name|Object
name|oldValue
parameter_list|,
name|Object
name|newValue
parameter_list|)
block|{
name|graphAction
operator|.
name|handlePropertyChange
argument_list|(
name|object
argument_list|,
name|property
argument_list|,
name|oldValue
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns this context's ObjectStore.      *       * @since 1.2      */
specifier|public
name|GraphManager
name|getGraphManager
parameter_list|()
block|{
return|return
name|objectStore
return|;
block|}
comment|/**      * Returns an object local to this DataContext and matching the ObjectId. If      *<code>prototype</code> is not null, local object is refreshed with the prototype      * values.      *<p>      * In case you pass a non-null second parameter, you are responsible for setting      * correct persistence state of the returned local object, as generally there is no      * way for Cayenne to determine the resulting local object state.      *       * @since 1.2      */
specifier|public
name|Persistent
name|localObject
parameter_list|(
name|ObjectId
name|id
parameter_list|,
name|Object
name|prototype
parameter_list|)
block|{
comment|// ****** Warning: when changing the code below, don't forget to change
comment|// CayenneContext's implementation which right now relies on copy/paste "reuse"
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Null ObjectId"
argument_list|)
throw|;
block|}
comment|// note that per-object ClassDescriptor lookup is needed as even if all
comment|// objects where fetched as a part of the same query, as they may belong to
comment|// different subclasses
name|ClassDescriptor
name|descriptor
init|=
name|getEntityResolver
argument_list|()
operator|.
name|getClassDescriptor
argument_list|(
name|id
operator|.
name|getEntityName
argument_list|()
argument_list|)
decl_stmt|;
name|Persistent
name|cachedObject
init|=
operator|(
name|Persistent
operator|)
name|getGraphManager
argument_list|()
operator|.
name|getNode
argument_list|(
name|id
argument_list|)
decl_stmt|;
comment|// merge into an existing object
if|if
condition|(
name|cachedObject
operator|!=
literal|null
condition|)
block|{
name|int
name|state
init|=
name|cachedObject
operator|.
name|getPersistenceState
argument_list|()
decl_stmt|;
comment|// TODO: Andrus, 1/24/2006 implement smart merge for modified objects...
if|if
condition|(
name|cachedObject
operator|!=
name|prototype
operator|&&
name|state
operator|!=
name|PersistenceState
operator|.
name|MODIFIED
operator|&&
name|state
operator|!=
name|PersistenceState
operator|.
name|DELETED
condition|)
block|{
name|descriptor
operator|.
name|injectValueHolders
argument_list|(
name|cachedObject
argument_list|)
expr_stmt|;
if|if
condition|(
name|prototype
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|Persistent
operator|)
name|prototype
operator|)
operator|.
name|getPersistenceState
argument_list|()
operator|!=
name|PersistenceState
operator|.
name|HOLLOW
condition|)
block|{
name|descriptor
operator|.
name|shallowMerge
argument_list|(
name|prototype
argument_list|,
name|cachedObject
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|PersistenceState
operator|.
name|HOLLOW
condition|)
block|{
name|cachedObject
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|COMMITTED
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|cachedObject
return|;
block|}
comment|// create and merge into a new object
else|else
block|{
name|Persistent
name|localObject
decl_stmt|;
synchronized|synchronized
init|(
name|getGraphManager
argument_list|()
init|)
block|{
name|localObject
operator|=
operator|(
name|Persistent
operator|)
name|descriptor
operator|.
name|createObject
argument_list|()
expr_stmt|;
name|localObject
operator|.
name|setObjectContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|localObject
operator|.
name|setObjectId
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|getGraphManager
argument_list|()
operator|.
name|registerNode
argument_list|(
name|id
argument_list|,
name|localObject
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prototype
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|Persistent
operator|)
name|prototype
operator|)
operator|.
name|getPersistenceState
argument_list|()
operator|!=
name|PersistenceState
operator|.
name|HOLLOW
condition|)
block|{
name|localObject
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|COMMITTED
argument_list|)
expr_stmt|;
name|descriptor
operator|.
name|injectValueHolders
argument_list|(
name|localObject
argument_list|)
expr_stmt|;
name|descriptor
operator|.
name|shallowMerge
argument_list|(
name|prototype
argument_list|,
name|localObject
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|localObject
operator|.
name|setPersistenceState
argument_list|(
name|PersistenceState
operator|.
name|HOLLOW
argument_list|)
expr_stmt|;
block|}
return|return
name|localObject
return|;
block|}
block|}
block|}
end_class

end_unit

