<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook"
    xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
    <title>Porting Existing Code to Connect to a Web Service Instead of a Database</title>
    <section xml:id="starting-command-line-cliet">
        <title>Starting Command Line Client</title>
        <para>One of the benefits of ROP is that the client code is no different from the server
            code - it uses the same ObjectContext interface for access, same query and commit API.
            So the code below will be similar to the code presented in the first Cayenne
                Getting Started Guide, although with a few ROP-specific parts required to bootstrap the
            ObjectContext.</para>
        <para>Let's start by creating an empty Main class with the standard main() method in the
            client project:</para>
        <programlisting>package org.example.cayenne.persistent.client;

public class Main {

    public static void main(String[] args) {

    }
}</programlisting>
        <para>Now the part that is actually different from regular Cayenne - establishing the server
            connection and obtaining the ObjectContext:</para>
        <programlisting>ClientConnection connection = new HessianConnection("http://localhost:8080/tutorial/cayenne-service");
DataChannel channel = new ClientChannel(connection, false, new DefaultEventManager(), false);
ObjectContext context = new CayenneContext(channel);</programlisting>
        <para>Note that the "channel" can be used to create as many peer ObjectContexts as needed
            over the same connection, while ObjectContext is a kind of isolated "persistence
            session", similar to the server-side context. A few more notes. Since we are using
            HTTP(S) to communicate with ROP server, there's no need to explicitly close the
            connection (or channel, or context).</para>
        <para>So now let's do the same persistent operaions that we did in the first tutorial "Main"
            class. Let's start by creating and saving some objects:</para>
        <programlisting>// creating new Artist
Artist picasso = context.newObject(Artist.class);
picasso.setName("Pablo Picasso");

// Creating other objects
Gallery metropolitan = context.newObject(Gallery.class);
metropolitan.setName("Metropolitan Museum of Art");

Painting girl = context.newObject(Painting.class);
girl.setName("Girl Reading at a Table");

Painting stein = context.newObject(Painting.class);
stein.setName("Gertrude Stein");

// connecting objects together via relationships
picasso.addToPaintings(girl);
picasso.addToPaintings(stein);

girl.setGallery(metropolitan);
stein.setGallery(metropolitan);

// saving all the changes above
context.commitChanges();</programlisting>
        <para>Now let's select them back:</para>
        <programlisting>// SelectQuery examples
SelectQuery select1 = new SelectQuery(Painting.class);
List&lt;Painting&gt; paintings1 = context.performQuery(select1);

Expression qualifier2 = ExpressionFactory.likeIgnoreCaseExp(
        Painting.NAME_PROPERTY, "gi%");
SelectQuery select2 = new SelectQuery(Painting.class, qualifier2);
List&lt;Painting&gt; paintings2 = context.performQuery(select2);</programlisting>
        <para>Now, delete:</para>
        <programlisting>Expression qualifier = ExpressionFactory.matchExp(Artist.NAME_PROPERTY,
                "Pablo Picasso");
SelectQuery selectToDelete = new SelectQuery(Artist.class, qualifier);
Artist picasso = (Artist) DataObjectUtils.objectForQuery(context,
        selectToDelete);

if (picasso != null) {
    context.deleteObject(picasso);
    context.commitChanges();
}</programlisting>
        <para>This code is exactly the same as in the first tutorial. So now let's try running the
            client and see what happens. In Eclipse open main class and select "Run &gt; Run As &gt;
            Java Application" from the menu (assuming the ROP server started in the previous step is
            still running). You will some output in both server and client process consoles.
            Client:</para>
        <programlisting>INFO: Connecting to [http://localhost:8080/tutorial/cayenne-service] - dedicated session.
INFO: === Connected, session: org.apache.cayenne.remote.RemoteSession@26544ec1[sessionId=17uub1h34r9x1] - took 111 ms.
INFO: --- Message 0: Bootstrap
INFO: === Message 0: Bootstrap done - took 58 ms.
INFO: --- Message 1: flush-cascade-sync
INFO: === Message 1: flush-cascade-sync done - took 1119 ms.
INFO: --- Message 2: Query
INFO: === Message 2: Query done - took 48 ms.
INFO: --- Message 3: Query
INFO: === Message 3: Query done - took 63 ms.
INFO: --- Message 4: Query
INFO: === Message 4: Query done - took 19 ms.
INFO: --- Message 5: Query
INFO: === Message 5: Query done - took 7 ms.
INFO: --- Message 6: Query
INFO: === Message 6: Query done - took 5 ms.
INFO: --- Message 7: Query
INFO: === Message 7: Query done - took 2 ms.
INFO: --- Message 8: Query
INFO: === Message 8: Query done - took 4 ms.
INFO: --- Message 9: flush-cascade-sync
INFO: === Message 9: flush-cascade-sync done - took 34 ms.</programlisting>
        <para>As you see client prints no SQL statmenets, just a bunch of query and flush messages
            sent to the server. The server side is more verbose, showing the actual client queries
            executed against the database:</para>
        <programlisting>...
INFO: SELECT NEXT_ID FROM AUTO_PK_SUPPORT WHERE TABLE_NAME = ? FOR UPDATE [bind: 1:'ARTIST']
INFO: SELECT NEXT_ID FROM AUTO_PK_SUPPORT WHERE TABLE_NAME = ? FOR UPDATE [bind: 1:'GALLERY']
INFO: SELECT NEXT_ID FROM AUTO_PK_SUPPORT WHERE TABLE_NAME = ? FOR UPDATE [bind: 1:'PAINTING']
INFO: INSERT INTO ARTIST (DATE_OF_BIRTH, ID, NAME) VALUES (?, ?, ?)
INFO: [batch bind: 1->DATE_OF_BIRTH:NULL, 2->ID:200, 3->NAME:'Pablo Picasso']
INFO: === updated 1 row.
INFO: INSERT INTO GALLERY (ID, NAME) VALUES (?, ?)
INFO: [batch bind: 1->ID:200, 2->NAME:'Metropolitan Museum of Art']
INFO: === updated 1 row.
INFO: INSERT INTO PAINTING (ARTIST_ID, GALLERY_ID, ID, NAME) VALUES (?, ?, ?, ?)
INFO: [batch bind: 1->ARTIST_ID:200, 2->GALLERY_ID:200, 3->ID:200, 4->NAME:'Girl Reading at a Table']
INFO: [batch bind: 1->ARTIST_ID:200, 2->GALLERY_ID:200, 3->ID:201, 4->NAME:'Gertrude Stein']
INFO: === updated 2 rows.
INFO: +++ transaction committed.
INFO: --- transaction started.
INFO: SELECT t0.GALLERY_ID, t0.NAME, t0.ARTIST_ID, t0.ID FROM PAINTING t0
INFO: === returned 2 rows. - took 14 ms.
INFO: +++ transaction committed.
INFO: --- transaction started.
INFO: SELECT t0.GALLERY_ID, t0.NAME, t0.ARTIST_ID, t0.ID FROM PAINTING t0 
      WHERE UPPER(t0.NAME) LIKE UPPER(?) [bind: 1->NAME:'gi%']
INFO: === returned 1 row. - took 10 ms.
INFO: +++ transaction committed.
INFO: --- transaction started.
INFO: SELECT t0.DATE_OF_BIRTH, t0.NAME, t0.ID FROM ARTIST t0 WHERE t0.NAME = ? [bind: 1->NAME:'Pablo Picasso']
INFO: === returned 1 row. - took 8 ms.
INFO: +++ transaction committed.
INFO: --- transaction started.
INFO: DELETE FROM PAINTING WHERE ID = ?
INFO: [batch bind: 1->ID:200]
INFO: [batch bind: 1->ID:201]
INFO: === updated 2 rows.
INFO: DELETE FROM ARTIST WHERE ID = ?
INFO: [batch bind: 1->ID:200]
INFO: === updated 1 row.
INFO: +++ transaction committed.</programlisting>
        <para>You are done with the basic ROP client!</para>
    </section>
</chapter>
