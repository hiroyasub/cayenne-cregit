<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
	version="5.0" xml:id="persistent-objects-objectcontext">
	<title>Persistent Objects and ObjectContext</title>
	<section xml:id="objectcontext">
		<title>ObjectContext</title>
		<para>ObjectContext is an interface that users normally work with to access the database. It
			provides the API to execute database operations and to manage persistent objects. A
			context is obtained from the
			ServerRuntime:<programlisting>ObjectContext context = runtime.getContext();</programlisting></para>
		<para>The call above creates a new instance of ObjectContext that can access the database via this
			runtime. ObjectContext is a single "work area" in Cayenne, storing persistent objects.
			ObjectContext guarantees that for each database row with a unique ID it will contain at
			most one instance of an object, thus ensuring object graph consistency between multiple
			selects (a feature called "uniquing"). At the same time different ObjectContexts will
			have independent copies of objects for each unique database row. This allows users to
			isolate object changes from one another by using separate ObjectContexts.</para>
		<para>These properties directly affect the strategies for scoping and sharing (or not
			sharing) ObjectContexts. Contexts that are only used to fetch objects from the database
			and whose objects are never modified by the application can be shared between mutliple
			users (and multiple threads). Contexts that store modified objects should be accessed
			only by a single user (e.g. a web application user might reuse a context instance
			between multiple web requests in the same HttpSession, thus carrying uncommitted changes
			to objects from request to request, until he decides to commit or rollback them). Even
			for a single user it might make sense to use mutliple ObjectContexts (e.g.
			request-scoped contexts to allow concurrent requests from the browser that change and
			commit objects independently).</para>
		<para>ObjectContext is serializable and does not permanently hold to any of the application
			resources. So it does not have to be closed. If the context is not used anymore, it
			should simply be allowed to go out of scope and get garbage collected, just like any
			other Java object.</para>
	</section>
	<section xml:id="persistent-lifecycle">
		<title>Persistent Object and its Lifecycle</title>
		<para>Cayenne can persist Java objects that implement <code>org.apache.cayenne.Persistent</code>
			interface. Generally persistent classes are generated from the model as described above,
			so users do not have to worry about superclass and property implementation details. </para>
		<para>Persistent interface provides access to 3 persistence-related properties - objectId,
			persistenceState and objectContext. All 3 are initialized by Cayenne runtime framework.
			Application code should not attempt to change them them. However it is allowed to read
			them, which provides valuable runtime information. E.g. ObjectId can be used for quick
			equality check of 2 objects, knowing persistence state would allow highlighting changed
			objects, etc.</para>
		<para>Each persistent object belongs to a single ObjectContext, and can be in one of the following
			persistence states (as defined in <code>org.apache.cayenne.PersistenceState</code>)
				:<table frame="void">
				<caption>Persistence States</caption>
				<col width="16%"/>
				<col width="84%"/>
				<tbody>
					<tr>
						<td>TRANSIENT</td>
						<td>The object is not registered with an ObjectContext and will not be
							persisted.</td>
					</tr>
					<tr>
						<td>NEW</td>
						<td>The object is freshly registered in an ObjectContext, but has not been
							saved to the database yet and there is no matching database row.</td>
					</tr>
					<tr>
						<td>COMMITTED</td>
						<td>The object is registered in an ObjectContext, there is a row in the
							database corresponding to this object, and the object state corresponds
							to the last known state of the matching database row.</td>
					</tr>
					<tr>
						<td>MODIFIED</td>
						<td>The object is registered in an ObjectContext, there is a row in the
							database corresponding to this object, but the object in-memory state
							has diverged from the last known state of the matching database
							row.</td>
					</tr>
					<tr>
						<td>HOLLOW</td>
						<td>The object is registered in an ObjectContext, there is a row in the
							database corresponding to this object, but the object state is unknown.
							Whenever an application tries to access a property of such object,
							Cayenne attempts reading its values from the database and "inflate" the
							object, turning it to COMMITED.</td>
					</tr>
					<tr>
						<td>DELETED</td>
						<td>The object is registered in an ObjectContext and has been marked for
							deletion in-memory. The corresponding row in the database will get
							deleted upon ObjectContext commit, and the object state will be turned
							into TRANSIENT.</td>
					</tr>
				</tbody>
			</table></para>
	</section>
	<section xml:id="persistent-operations">
		<title>ObjectContext Persistence API</title>
		<para>One of the first things users usually want to do with an ObjectContext is to select
			some objects from a database. This is done by calling "<emphasis role="italic"
				>performQuery</emphasis>"
			method:<programlisting>SelectQuery query = new SelectQuery(Artist.class);
List&lt;Artist> artists = context.performQuery(query);</programlisting>We'll
			discuss queries in some detail in the following chapters. The example above is
			self-explanatory - we create a SelectQuery that matches all Artist objects present in
			the database, and then call "performQuery", getting a list of Artist objects.</para>
		<para>Some queries can be quite complex, returning multiple result sets or even updating the
			database. For such queries ObjectContext provides "<emphasis role="italic"
				>performGenericQuery</emphasis>"method. While not nearly as commonly-used as
			"performQuery", it is nevertheless important in some situations.
			E.g.:<programlisting>Collection&lt;Query> queries = ... // multiple queries that need to be run together
QueryChain query = new QueryChain(queries);

QueryResponse response = context.performGenericQuery(query);</programlisting></para>
		<para>An application might modify selected objects. E.g.:</para>
		<programlisting>Artist selectedArtist = artists.get(0);
selectedArtist.setName("Dali");</programlisting>
		<para>The first time the object property is changed, the object's state is automatically set
			to "MODIFIED" by Cayenne. Cayenne tracks all in-memory changes until a user calls
				"<emphasis role="italic"
			>commitChanges</emphasis>":<programlisting>context.commitChanges();</programlisting>At
			this point all in-memory changes are analyzed and a minimal set of SQL statements is
			issued in a single transaction to synchronize the database with the in-memory state. In
			our example "commitChanges" commits just one object, but generally it can be any number
			of objects. </para>
		<para>If instead of commit, we wanted to reset all changed objects to the previously
			committed state, we'd call <emphasis>rollbackChanges</emphasis>
			instead:<programlisting>context.rollbackChanges();</programlisting></para>
		<para>"<emphasis role="italic">newObject</emphasis>" method call creates a persistent object
			and sets its state to
			"NEW":<programlisting>Artist newArtist = context.newObject(Artist.class);
newArtist.setName("Picasso");</programlisting></para>
		<para>It will only exist in memory until "commitChanges" is issued. On commit Cayenne might
			generate a new primary key (unless a user set it explicitly, or a PK was inferred from a
			relationship) and issue an INSERT SQL statement to permanently store the object.</para>
		<para><emphasis>deleteObjects</emphasis> method takes one or more Persistent objects and
			marks them as
			"DELETED":<programlisting>context.deleteObjects(artist1);
context.deleteObjects(artist2, artist3, artist4);</programlisting>Additionally
			"deleteObjects" processes all  delete rules modeled for the affected objects. This may
			result in implicitly deleting or modifying extra related objects. Same as insert and
			update, delete operations are sent to the database only when "commitChanges" is called.
			Similarly "rollbackChanges" will undo the effect of "newObject" and
			"deleteObjects".</para>
		<para>Often an appliction needs to inspect mapping metadata. This information is stored in
			the EntityResolver object, accessible via the
			ObjectContext:<programlisting>EntityResolver resolver = objectContext.getEntityResolver();</programlisting></para>
		<para>Here we discussed the most commonly used subset of the ObjectContext API. There are
			other useful methods, e.g. those allowing to inspect registered objects state en bulk,
			etc. Check the latest JavaDocs for details.</para>
	</section>
	<section xml:id="cayenne-helper-class">
		<title>Cayenne Helper Class</title>
		<para>There is a useful helper class called "Cayenne" (fully-qualified name
				<code>"org.apache.cayenne.Cayenne"</code>) that builds on ObjectContext API to
			provide a number of very common operations. E.g. get a primary key (most entities do not
			model PK as an object property)
			:<programlisting>long pk = Cayenne.longPKForObject(artist);</programlisting></para>
		<para>It also provides the reverse operation - finding an object given a known
			PK:<programlisting>Artist artist = Cayenne.objectForPK(context, Artist.class, 34579);</programlisting></para>
		<para>If a query is expected to return 0 or 1 object, Cayenne helper class can be used to find
			this object. It throws an exception if more than one object matched the
			query:<programlisting>Artist artist = (Artist) Cayenne.objectForQuery(context, new SelectQuery(Artist.class));</programlisting></para>
		<para>Feel free to explore Cayenne class API for other useful methods.</para>
	</section>
	<section xml:id="objectcontext-nesting">
		<title>ObjectContext Nesting</title>
	</section>
	<section xml:id="generic-persistent-objects">
		<title>Generic Persistent Objects</title>
	</section>
	<section xml:id="transactions">
		<title>Transactions</title>
	</section>
</chapter>
