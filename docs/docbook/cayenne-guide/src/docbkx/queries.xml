<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
	version="5.0" xml:id="queries">
	<title>Queries</title>
	<para>Queries are Java objects used by the application to communicate with the database. Cayenne
		knows how to translate queries into SQL statements appropriate for a particular database
		engine. Most often queries are used to find objects matching certain criteria, but there are
		other types of queries too. E.g. those allowing to run native SQL, call DB stored
		procedures, etc. When committing objects, Cayenne itself creates special queries to
		insert/update/delete rows in the dabase.</para>
	<para>There is a number of built-in queries in Cayenne, described later in this chapter. Users can
		also define their own query types to abstract certain DB interactions that for whatever
		reason can not be adequately described by the built-in set. </para>
	<para>Queries can be roughly categorized as "object" and "native". Object queries (most notably
		SelectQuery and EJBQLQuery) are built with abstractions originating in the object model (the
		"object" side in the "object-relational" divide). E.g. SelectQuery is assembled from a Java
		class of the objects to fetch, a qualifier expression, orderings, etc. - all of this
		expressed in terms of the object model.</para>
	<para>Native queries describe a desired DB operation as SQL code (SQLTemplate query) or a reference
		to a stored procedure (ProcedureQuery), etc. The results of native queries are usually
		presented as Lists of Maps, with each map representing a row in the DB. They can potentially
		be converted to objects, however often it takes a considerable effort to do so. Native
		queries are also less (if at all) portable across databases than object queries. </para>
	<section xml:id="selectquery">
		<title>SelectQuery</title>
		<para>SelectQuery is the most commonly used query in user applications. It returns a list of
			persistent objects of a certain type specified in the
			query:<programlisting language="java">SelectQuery query = new SelectQuery(Artist.class);
List&lt;Artist> objects = context.performQuery(query);</programlisting>This
			returned all rows in the "ARTIST" table. If the logs were turned on, you might see the
			following SQL
			printed:<programlisting>INFO: SELECT t0.DATE_OF_BIRTH, t0.NAME, t0.ID FROM ARTIST t0
INFO: === returned 5 row. - took 5 ms.</programlisting></para>
		<para>This SQL was generated by Cayenne from the SelectQuery above. SelectQuery can use a
			qualifier to select only the data that you care about. Qualifier is simply an Expression
			(Expressions where discussed in the previous chapter). If you only want artists whose
			name begins with 'Pablo', you might use the following qualifier expression:
			<programlisting language="java">SelectQuery query = new SelectQuery(Artist.class,
        ExpressionFactory.likeExp(Artist.NAME_PROPERTY, "Pablo%"));
List&lt;Artist> objects = context.performQuery(query);</programlisting>The
			SQL will look different this
			time:<programlisting>INFO: SELECT t0.DATE_OF_BIRTH, t0.NAME, t0.ID FROM ARTIST t0 WHERE t0.NAME LIKE ? 
[bind: 1->NAME:'Pablo%']
INFO: === returned 1 row. - took 6 ms.</programlisting></para>
	</section>
	<section xml:id="ejbqlquery">
		<title>EJBQLQuery</title>
	</section>
	<section xml:id="sqltemplate">
		<title>SQLTemplateQuery</title>
	</section>
	<section xml:id="procedurequery">
		<title>ProcedureQuery</title>
	</section>
	<section xml:id="namedquery">
		<title>NamedQuery</title>
	</section>
	<section xml:id="custom-queries">
		<title>Custom Queries</title>
	</section>
</chapter>
