<?xml version="1.0" encoding="UTF-8"?>
<!--
	Licensed to the Apache Software Foundation (ASF) under one or more
	contributor license agreements. See the NOTICE file distributed with
	this work for additional information regarding copyright ownership.
	The ASF licenses this file to you under the Apache License, Version
	2.0 (the "License"); you may not use this file except in compliance
	with the License. You may obtain a copy of the License at
	
	http://www.apache.org/licenses/LICENSE-2.0 Unless required by
	applicable law or agreed to in writing, software distributed under the
	License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
	CONDITIONS OF ANY KIND, either express or implied. See the License for
	the specific language governing permissions and limitations under the
	License.
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    version="5.0" xml:id="re-types-mapping">
    <title>Types Mapping</title>
    <para>
        Types mapping is a process of mapping between Database types and Java Classes through JDBC types that are represented by <code>java.sql.Types</code>.
    </para>
    <para>
        By default, <code>java.sql.Types</code> will be mapped to Java built in types or wrapper class types. Actually, Cayenne allows you to override the default mapping.
        You could use the <code>&lt;typeMapper&gt;</code> configuration section to customize how JDBC types should be identified in database and how they should be
        mapped to Java Classes during reverse engineering process.
    </para>
    <para>
        Sometimes you need to map database types to your custom Java Classes. If you really want to do this, then you should implement
        <code>org.apache.cayenne.access.types.ExtendedType</code> interface for your classes.
    </para>
    <section xml:id="basic-configuration">
        <title>Basic Configuration</title>
        <para>Here is an example of a basic typeMapper configuration:</para>
        <programlisting language="xml">
    &lt;reverseEngineering&gt;
        &lt;typeMapper&gt;
            &lt;mapperClassName&gt;CustomMapperClass&lt;/mapperClassName&gt;
            &lt;usePrimitives&gt;false&lt;/usePrimitives&gt;
            &lt;type&gt;
                &lt;!-- Java type names--&gt;
                &lt;java&gt;java.math.BigDecimal&lt;/java&gt;
                &lt;!-- JDBC tag is name for java.sql.Types --&gt;
                &lt;jdbc&gt;DECIMAL&lt;/jdbc&gt;
                &lt;!-- Length, scale and precision can be used to specify the mapping precisely --&gt;
                &lt;precision&gt;16&lt;/precision&gt;
                &lt;scale&gt;2&lt;/scale&gt;
            &lt;/type&gt;
            &lt;type&gt;
                &lt;java&gt;java.lang.Long&lt;/java&gt;
                &lt;jdbc&gt;NUMERIC&lt;/jdbc&gt;
            &lt;/type&gt;
            &lt;type&gt;
                &lt;java&gt;java.lang.String&lt;/java&gt;
                &lt;jdbc&gt;VARCHAR&lt;/jdbc&gt;
                &lt;length&gt;100&lt;/length&gt;
                &lt;notNull&gt;true&lt;/notNull&gt;
            &lt;/type&gt;
            &lt;type&gt;
                &lt;java&gt;java.util.Date&lt;/java&gt;
                &lt;jdbc&gt;TIMESTAMP&lt;/jdbc&gt;
            &lt;/type&gt;
        &lt;/typeMapper&gt;
    &lt;/reverseEngineering&gt;
        </programlisting>
        <itemizedlist>
            <listitem>
                <para>
                    <code>&lt;mapperClassName&gt;</code> - name of the fully qualified custom Java mapper class.
                </para>
            </listitem>
            <listitem>
                <para>
                    <code>&lt;usePrimitives&gt;</code> -  allows you to make a decision whether to use primitives or not. It's quite useful, because primitives are faster than objects.
                    If you want to use primitive type instead of wrapper type just set this option to true, otherwise false. It is more intuitive and has less overhead.
                    If it is not possible because generics/autoboxing reasons, or if you want it to be nullable, then use the wrapper type. All the wrapper classes
                    (Integer, Long, Byte, Double, Float, Short) are subclasses of the abstract class Number. The object of the wrapper class contains/wraps them respectively
                    to the primitive data type. Converting primitive data types into objects is called boxing and compiler takes care about this. So, you donâ€™t need to use
                    any special workarounds.
                </para>
            </listitem>
            <listitem>
                <para>
                    <code>&lt;java&gt;</code> - name of the fully qualified Java class for mapping. If the class is a primitive wrapper class such as java.lang.Integer,
                    the mapping also applies to the primitive type.
                </para>
            </listitem>
            <listitem>
                <para>
                    <code>&lt;jdbc&gt;</code> -  JDBC type which will be used by JDBC PreparedStatement, SQL Queries and for loading data from JDBC ResultSet.
                    The valid types are defined in java.sql.Types.
                </para>
            </listitem>
            <listitem>
                <para>
                    <code>&lt;notNull&gt;</code> - It's not a conditional constraint. Either your mapping are always required, in which case you should specify them as notNull="true",
                    or not.
                </para>
            </listitem>
            <listitem>
                <para>
                    <code>&lt;length&gt;, &lt;precision&gt;, &lt;scale&gt;</code> - length, scale and precision are used to specify the mapping precisely.
                </para>
            </listitem>
        </itemizedlist>
        <para>Note that you could write the elements above as attributes of <code>&lt;type&gt;</code>, for example:</para>
        <programlisting language="xml">    &lt;type java="java built-in type"
        jdbc="java.sql.Types Name"
        length="Numeric value"
        precision="Numeric value"
        scale="Numeric value"
        notNull="true|false"/&gt;</programlisting>
        <para>
            The number of attributes specified in <code>&lt;type&gt;</code> and the order of the <code>&lt;type&gt;</code> is important for types mapping.
            If <code>&lt;typeMapper&gt;</code> and <code>&lt;type&gt;</code> specifications are found in <code>&lt;reverseEngineering&gt;</code>, then they will be applied for all
            reverse engineering schemas and catalogs. Otherwise, Cayenne will automatically choose default behaviour for all schema and catalogs:
            <code>java.sql.Types</code> will be mapped to java built in types or wrapper class types.
        </para>        
    </section>
</chapter>
